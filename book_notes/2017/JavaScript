JavaScriptJavaScript代码可以直接嵌在网页的任何地方，不过通常我们都把JavaScript代码放到<head>中第二种方法是把JavaScript代码放到一个单独的.js文件，然后在HTML中通过<scriptsrc="..."></script>引入这个文件JS文件里面的代码直接写。。。//以//开头直到行末的是注释，将被浏览器忽略以file://开头的地址无法执行如联网等JavaScript代码，最终，你还是需要架设一个Web服务器，然后以http://开头的地址来正常执行所有JavaScript代码。不过，开始学习阶段，你无须关心如何搭建开发环境的问题，我们提供在页面输入JavaScript代码并直接运行的功能，让你专注于JavaScript的学习。JavaScript并不强制要求在每个语句的结尾加;，浏览器中负责执行JavaScript代码的引擎会自动在每个语句的结尾补上;。下面的一行代码就是一个完整的赋值语句：varx=1;下面的一行代码是一个字符串，但仍然可以视为一个完整的语句：'Hello,world';下面的一行代码包含两个语句，每个语句用;表示语句结束：varx=1;vary=2;//不建议一行写多个语句!语句块是一组语句的集合，例如，下面的代码先做了一个判断，如果判断成立，将执行{...}中的所有语句：if(2>1){x=1;y=2;z=3;}注意花括号{...}内的语句具有缩进，通常是4个空格。缩进不是JavaScript语法要求必须的，但缩进有助于我们理解代码的层次，所以编写代码时要遵守缩进规则。很多文本编辑器具有“自动缩进”的功能，可以帮助整理代码。{...}还可以嵌套，形成层级结构：if(2>1){x=1;y=2;z=3;if(x<y){z=4;}if(x>y){z=5;}}JavaScript本身对嵌套的层级没有限制，但是过多的嵌套无疑会大大增加看懂代码的难度。遇到这种情况，需要把部分代码抽出来，作为函数来调用，这样可以减少代码的复杂度。另一种块注释是用/*...*/把多行字符包裹起来，把一大“块”视为一个注释JavaScript不区分整数和浮点数，统一用Number表示字符串是以单引号'或双引号"括起来的任意文本，比如'abc'，"xyz"等等。请注意，''或""本身只是一种表示方式，不是字符串的一部分，因此，字符串'abc'只有a，b，c这3个字符布尔值和布尔代数的表示完全一致，一个布尔值只有true、false两种值，要么是true，要么是false，可以直接用true、false表示布尔值，也可以通过布尔运算计算出来要特别注意相等运算符==。JavaScript在设计时，有两种比较运算符：第一种是==比较，它会自动转换数据类型再比较，很多时候，会得到非常诡异的结果；第二种是===比较，它不会自动转换数据类型，如果数据类型不一致，返回false，如果一致，再比较。由于JavaScript这个设计缺陷，不要使用==比较，始终坚持使用===比较。另一个例外是NaN这个特殊的Number与所有其他值都不相等，包括它自己：NaN===NaN;//false唯一能判断NaN的方法是通过isNaN()函数：isNaN(NaN);//true最后要注意浮点数的相等比较：1/3===(1-2/3);//false这不是JavaScript的设计缺陷。浮点数在运算过程中会产生误差，因为计算机无法精确表示无限循环小数。要比较两个浮点数是否相等，只能计算它们之差的绝对值，看是否小于某个阈值：null和undefinednull表示一个“空”的值，它和0以及空字符串''不同，0是一个数值，''表示长度为0的字符串，而null表示“空”。在其他语言中，也有类似JavaScript的null的表示，例如Java也用null，Swift用nil，Python用None表示。但是，在JavaScript中，还有一个和null类似的undefined，它表示“未定义”。JavaScript的设计者希望用null表示一个空的值，而undefined表示值未定义。事实证明，这并没有什么卵用，区分两者的意义不大。大多数情况下，我们都应该用null。undefined仅仅在判断函数参数是否传递的情况下有用。数组是一组按顺序排列的集合，集合的每个值称为元素。JavaScript的数组可以包括任意数据类型。例如：[1,2,3.14,'Hello',null,true];上述数组包含6个元素。数组用[]表示，元素之间用,分隔。另一种创建数组的方法是通过Array()函数实现：newArray(1,2,3);//创建了数组[1,2,3]然而，出于代码的可读性考虑，强烈建议直接使用[]。数组的元素可以通过索引来访问。请注意，索引的起始值为0：vararr=[1,2,3.14,'Hello',null,true];arr[0];//返回索引为0的元素，即1arr[5];//返回索引为5的元素，即truearr[6];//索引超出了范围，返回undefinedJavaScript的对象是一组由键-值组成的无序集合，例如：varperson={name:'Bob',age:20,tags:['js','web','mobile'],city:'Beijing',hasCar:true,zipcode:null};JavaScript对象的键都是字符串类型，值可以是任意数据类型。上述person对象一共定义了6个键值对，其中每个键又称为对象的属性，例如，person的name属性为'Bob'，zipcode属性为null。要获取一个对象的属性，我们用对象变量.属性名的方式：person.name;//'Bob'person.zipcode;//null申明一个变量用var语句，比如：vara;//申明了变量a，此时a的值为undefinedvar$b=1;//申明了变量$b，同时给$b赋值，此时$b的值为1vars_007='007';//s_007是一个字符串varAnswer=true;//Answer是一个布尔值truevart=null;//t的值是null变量名也可以用中文，但是，请不要给自己找麻烦。在JavaScript中，使用等号=对变量进行赋值。可以把任意数据类型赋值给变量，同一个变量可以反复赋值，而且可以是不同类型的变量，但是要注意只能用var申明一次，例如：vara=123;//a的值是整数123a='ABC';//a变为字符串这种变量本身类型不固定的语言称之为动态语言，与之对应的是静态语言。静态语言在定义变量时必须指定变量类型，如果赋值的时候类型不匹配，就会报错。JavaScript在设计之初，为了方便初学者学习，并不强制要求用var申明变量。这个设计错误带来了严重的后果：如果一个变量没有通过var申明就被使用，那么该变量就自动被申明为全局变量：i=10;//i现在是全局变量在同一个页面的不同的JavaScript文件中，如果都不用var申明，恰好都使用了变量i，将造成变量i互相影响，产生难以调试的错误结果。使用var申明的变量则不是全局变量，它的范围被限制在该变量被申明的函数体内为了修补JavaScript这一严重设计缺陷，ECMA在后续规范中推出了strict模式，在strict模式下运行的JavaScript代码，强制通过var申明变量，未使用var申明变量就使用的，将导致运行错误。启用strict模式的方法是在JavaScript代码的第一行写上：'usestrict';这是一个字符串，不支持strict模式的浏览器会把它当做一个字符串语句执行，支持strict模式的浏览器将开启strict模式运行JavaScript。不用var申明的变量会被视为全局变量，为了避免这一缺陷，所有的JavaScript代码都应该使用strict模式。JavaScript的字符串就是用''或""括起来的字符表示。如果'本身也是一个字符，那就可以用""括起来，比如"I'mOK"包含的字符是I，'，m，空格，O，K这6个字符。如果字符串内部既包含'又包含"怎么办？可以用转义字符\来标识由于多行字符串用\n写起来比较费事，所以最新的ES6标准新增了一种多行字符串的表示方法，用反引号`...`表示：`这是一个多行字符串`;要把多个字符串连接起来，可以用+号连接：varname='小明';varage=20;varmessage='你好,'+name+',你今年'+age+'岁了!';alert(message);如果有很多变量需要连接，用+号就比较麻烦。ES6新增了一种模板字符串，表示方法和上面的多行字符串一样，但是它会自动替换字符串中的变量：varname='小明';varage=20;varmessage=`你好,${name},你今年${age}岁了!`;alert(message);字符串常见的操作如下：vars='Hello,world!';s.length;//13要获取字符串某个指定位置的字符，使用类似Array的下标操作，索引号从0开始：vars='Hello,world!';s[0];//'H's[6];//''s[7];//'w's[12];//'!'s[13];//undefined超出范围的索引不会报错，但一律返回undefined需要特别注意的是，字符串是不可变的，如果对字符串的某个索引赋值，不会有任何错误，但是，也没有任何效果JavaScript为字符串提供了一些常用方法，注意，调用这些方法本身不会改变原有字符串的内容，而是返回一个新字符串：indexOf()会搜索指定字符串出现的位置：vars='hello,world';s.indexOf('world');//返回7s.indexOf('World');//没有找到指定的子串，返回-1JavaScript的Array可以包含任意数据类型，并通过索引来访问每个元素。要取得Array的长度，直接访问length属性：vararr=[1,2,3.14,'Hello',null,true];arr.length;//6Array可以通过索引把对应的元素修改为新的值，因此，对Array的索引进行赋值会直接修改这个Array：vararr=['A','B','C'];arr[1]=99;arr;//arr现在变为['A',99,'C']请注意，如果通过索引赋值时，索引超过了范围，同样会引起Array大小的变化：vararr=[1,2,3];arr[5]='x';arr;//arr变为[1,2,3,undefined,undefined,'x']大多数其他编程语言不允许直接改变数组的大小，越界访问索引会报错。然而，JavaScript的Array却不会有任何错误。在编写代码时，不建议直接修改Array的大小，访问索引时要确保索引不会越界。与String类似，Array也可以通过indexOf()来搜索一个指定的元素的位置：vararr=[10,20,'30','xyz'];arr.indexOf(10);//元素10的索引为0arr.indexOf(20);//元素20的索引为1arr.indexOf(30);//元素30没有找到，返回-1arr.indexOf('30');//元素'30'的索引为2注意了，数字30和字符串'30'是不同的元素。slice()就是对应String的substring()版本，它截取Array的部分元素，然后返回一个新的Array：vararr=['A','B','C','D','E','F','G'];arr.slice(0,3);//从索引0开始，到索引3结束，但不包括索引3:['A','B','C']arr.slice(3);//从索引3开始到结束:['D','E','F','G']如果不给slice()传递任何参数，它就会从头到尾截取所有元素。利用这一点，我们可以很容易地复制一个Array：vararr=['A','B','C','D','E','F','G'];varaCopy=arr.slice();aCopy;//['A','B','C','D','E','F','G']aCopy===arr;//falsepush()向Array的末尾添加若干元素，pop()则把Array的最后一个元素删除掉：vararr=[1,2];arr.push('A','B');//返回Array新的长度:4arr;//[1,2,'A','B']arr.pop();//pop()返回'B'arr;//[1,2,'A']arr.pop();arr.pop();arr.pop();//连续pop3次arr;//[]arr.pop();//空数组继续pop不会报错，而是返回undefinedarr;//[]unshift和shift如果要往Array的头部添加若干元素，使用unshift()方法，shift()方法则把Array的第一个元素删掉：vararr=[1,2];arr.unshift('A','B');//返回Array新的长度:4arr;//['A','B',1,2]arr.shift();//'A'arr;//['B',1,2]arr.shift();arr.shift();arr.shift();//连续shift3次arr;//[]arr.shift();//空数组继续shift不会报错，而是返回undefinedarr;//[]sortsort()可以对当前Array进行排序，它会直接修改当前Array的元素位置，直接调用时，按照默认顺序排序：vararr=['B','C','A'];arr.sort();arr;//['A','B','C']reverse()把整个Array的元素给掉个个，也就是反转：vararr=['one','two','three'];arr.reverse();arr;//['three','two','one']splicesplice()方法是修改Array的“万能方法”，它可以从指定的索引开始删除若干元素，然后再从该位置添加若干元素：vararr=['Microsoft','Apple','Yahoo','AOL','Excite','Oracle'];//从索引2开始删除3个元素,然后再添加两个元素:arr.splice(2,3,'Google','Facebook');//返回删除的元素['Yahoo','AOL','Excite']arr;//['Microsoft','Apple','Google','Facebook','Oracle']//只删除,不添加:arr.splice(2,2);//['Google','Facebook']arr;//['Microsoft','Apple','Oracle']//只添加,不删除:arr.splice(2,0,'Google','Facebook');//返回[],因为没有删除任何元素arr;//['Microsoft','Apple','Google','Facebook','Oracle']concatconcat()方法把当前的Array和另一个Array连接起来，并返回一个新的Array：vararr=['A','B','C'];varadded=arr.concat([1,2,3]);added;//['A','B','C',1,2,3]arr;//['A','B','C']请注意，concat()方法并没有修改当前Array，而是返回了一个新的Array。实际上，concat()方法可以接收任意个元素和Array，并且自动把Array拆开，然后全部添加到新的Array里：vararr=['A','B','C'];arr.concat(1,2,[3,4]);//['A','B','C',1,2,3,4]joinjoin()方法是一个非常实用的方法，它把当前Array的每个元素都用指定的字符串连接起来，然后返回连接后的字符串：vararr=['A','B','C',1,2,3];arr.join('-');//'A-B-C-1-2-3'如果Array的元素不是字符串，将自动转换为字符串后再连接。如果数组的某个元素又是一个Array，则可以形成多维数组，例如：vararr=[[1,2,3],[400,500,600],'-'];上述Array包含3个元素，其中头两个元素本身也是Array。vaScript的对象是一种无序的集合数据类型，它由若干键值对组成。JavaScript的对象用于描述现实世界中的某个对象。例如，为了描述“小明”这个淘气的小朋友，我们可以用若干键值对来描述他：varxiaoming={name:'小明',birth:1990,school:'No.1MiddleSchool',height:1.70,weight:65,score:null};JavaScript用一个{...}表示一个对象，键值对以xxx:xxx形式申明，用,隔开。注意，最后一个键值对不需要在末尾加,访问属性是通过.操作符完成的，但这要求属性名必须是一个有效的变量名。如果属性名包含特殊字符，就必须用''括起来：varxiaohong={name:'小红','middle-school':'No.1MiddleSchool'};xiaohong的属性名middle-school不是一个有效的变量，就需要用''括起来。访问这个属性也无法使用.操作符，必须用['xxx']来访问：xiaohong['middle-school'];//'No.1MiddleSchool'xiaohong['name'];//'小红'xiaohong.name;//'小红'也可以用xiaohong['name']来访问xiaohong的name属性，不过xiaohong.name的写法更简洁。我们在编写JavaScript代码的时候，属性名尽量使用标准的变量名，这样就可以直接通过object.prop的形式访问一个属性了。由于JavaScript的对象是动态类型，你可以自由地给一个对象添加或删除属性：varxiaoming={name:'小明'};xiaoming.age;//undefinedxiaoming.age=18;//新增一个age属性xiaoming.age;//18deletexiaoming.age;//删除age属性xiaoming.age;//undefineddeletexiaoming['name'];//删除name属性xiaoming.name;//undefineddeletexiaoming.school;//删除一个不存在的school属性也不会报错如果我们要检测xiaoming是否拥有某一属性，可以用in操作符：varxiaoming={name:'小明',birth:1990,school:'No.1MiddleSchool',height:1.70,weight:65,score:null};'name'inxiaoming;//true'grade'inxiaoming;//false不过要小心，如果in判断一个属性存在，这个属性不一定是xiaoming的，它可能是xiaoming继承得到的：'toString'inxiaoming;//true因为toString定义在object对象中，而所有对象最终都会在原型链上指向object，所以xiaoming也拥有toString属性。要判断一个属性是否是xiaoming自身拥有的，而不是继承得到的，可以用hasOwnProperty()方法：varxiaoming={name:'小明'};xiaoming.hasOwnProperty('name');//truexiaoming.hasOwnProperty('toString');//falseJavaScript使用if(){...}else{...}来进行条件判断。例如，根据年龄显示不同内容，可以用if语句实现如下：varage=20;if(age>=18){//如果age>=18为true，则执行if语句块alert('adult');}else{//否则执行else语句块alert('teenager');}其中else语句是可选的。如果语句块只包含一条语句，那么可以省略{}：varage=20;if(age>=18)alert('adult');elsealert('teenager');省略{}的危险之处在于，如果后来想添加一些语句，却忘了写{}，就改变了if...else...的语义，例如：varage=20;if(age>=18)alert('adult');elseconsole.log('age<18');//添加一行日志alert('teenager');//<-这行语句已经不在else的控制范围了上述代码的else子句实际上只负责执行console.log('age<18');，原有的alert('teenager');已经不属于if...else...的控制范围了，它每次都会执行。相反地，有{}的语句就不会出错：varage=20;if(age>=18){alert('adult');}else{console.log('age<18');alert('teenager');}这就是为什么我们建议永远都要写上{}。请注意，if...else...语句的执行特点是二选一，在多个if...else...语句中，如果某个条件成立，则后续就不再继续判断了。JavaScript把null、undefined、0、NaN和空字符串''视为false，其他值一概视为trueBMI公式（体重除以身高的平方）低于18.5：过轻18.5-25：正常25-28：过重28-32：肥胖高于32：严重肥胖'usestrict';varheight=parseFloat(prompt('请输入身高(m):'));varweight=parseFloat(prompt('请输入体重(kg):'));varbmi=weight/(height*height);if(bmi<18.5);alert('过轻');elseif(bmi<25);alert('正常');elseif(bmi<28);alert('过重');elseif(bmi<32);alert('肥胖');elsealert('严重肥胖');为了和Python区别开来，加分号吧。。。;JavaScript的循环有两种，一种是for循环，通过初始条件、结束条件和递增条件来循环执行语句块：varx=0;vari;for(i=1;i<=10000;i++){x=x+i;}x;//50005000for循环最常用的地方是利用索引来遍历数组：vararr=['Apple','Google','Microsoft'];vari,x;for(i=0;i<arr.length;i++){x=arr[i];alert(x);}for循环的3个条件都是可以省略的，如果没有退出循环的判断条件，就必须使用break语句退出循环，否则就是死循环：varx=0;for(;;){//将无限循环下去if(x>100){break;//通过if判断来退出循环}x++;}for...infor循环的一个变体是for...in循环，它可以把一个对象的所有属性依次循环出来：varo={name:'Jack',age:20,city:'Beijing'};for(varkeyino){alert(key);//'name','age','city'}要过滤掉对象继承的属性，用hasOwnProperty()来实现：varo={name:'Jack',age:20,city:'Beijing'};for(varkeyino){if(o.hasOwnProperty(key)){alert(key);//'name','age','city'}}由于Array也是对象，而它的每个元素的索引被视为对象的属性，因此，for...in循环可以直接循环出Array的索引：vara=['A','B','C'];for(variina){alert(i);//'0','1','2'alert(a[i]);//'A','B','C'}for循环在已知循环的初始和结束条件时非常有用。而上述忽略了条件的for循环容易让人看不清循环的逻辑，此时用while循环更佳。while循环只有一个判断条件，条件满足，就不断循环，条件不满足时则退出循环。比如我们要计算100以内所有奇数之和，可以用while循环实现：varx=0;varn=99;while(n>0){x=x+n;n=n-2;}x;//2500循环是让计算机做重复任务的有效的方法，有些时候，如果代码写得有问题，会让程序陷入“死循环”，也就是永远循环下去。JavaScript的死循环会让浏览器无法正常显示或执行当前页面的逻辑，有的浏览器会直接挂掉，有的浏览器会在一段时间后提示你强行终止JavaScript的执行，因此，要特别注意死循环的问题。在编写循环代码时，务必小心编写初始条件和判断条件，尤其是边界值。特别注意i<100和i<=100是不同的判断逻辑。JavaScript的默认对象表示方式{}可以视为其他语言中的Map或Dictionary的数据结构，即一组键值对。但是JavaScript的对象有个小问题，就是键必须是字符串。但实际上Number或者其他数据类型作为键也是非常合理的。为了解决这个问题，最新的ES6规范引入了新的数据类型Map。Map是一组键值对的结构，具有极快的查找速度。用JavaScript写一个Map如下：varm=newMap([['Michael',95],['Bob',75],['Tracy',85]]);m.get('Michael');//95初始化Map需要一个二维数组，或者直接初始化一个空Map。Map具有以下方法：varm=newMap();//空Mapm.set('Adam',67);//添加新的key-valuem.set('Bob',59);m.has('Adam');//是否存在key'Adam':truem.get('Adam');//67m.delete('Adam');//删除key'Adam'm.get('Adam');//undefined由于一个key只能对应一个value，所以，多次对一个key放入value，后面的值会把前面的值冲掉Set和Map类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在Set中，没有重复的key。要创建一个Set，需要提供一个Array作为输入，或者直接创建一个空Set：vars1=newSet();//空Setvars2=newSet([1,2,3]);//含1,2,3遍历Array可以采用下标循环，遍历Map和Set就无法使用下标。为了统一集合类型，ES6标准引入了新的iterable类型，Array、Map和Set都属于iterable类型。具有iterable类型的集合可以通过新的for...of循环来遍历。for...of循环是ES6引入的新的语法(就是Python和bash里面的for.in...)...用for...of循环遍历集合，用法如下：vara=['A','B','C'];vars=newSet(['A','B','C']);varm=newMap([[1,'x'],[2,'y'],[3,'z']]);for(varxofa){//遍历Arrayalert(x);}for(varxofs){//遍历Setalert(x);}for(varxofm){//遍历Mapalert(x[0]+'='+x[1]);}你可能会有疑问，for...of循环和for...in循环有何区别？for...in循环由于历史遗留问题，它遍历的实际上是对象的属性名称。一个Array数组实际上也是一个对象，它的每个元素的索引被视为一个属性。当我们手动给Array对象添加了额外的属性后，for...in循环将带来意想不到的意外效果：vara=['A','B','C'];a.name='Hello';for(varxina){alert(x);//'0','1','2','name'}for...in循环将把name包括在内，但Array的length属性却不包括在内。for...of循环则完全修复了这些问题，它只循环集合本身的元素vara=['A','B','C'];a.name='Hello';for(varxofa){alert(x);//'A','B','C'}这就是为什么要引入新的for...of循环。然而，更好的方式是直接使用iterable内置的forEach方法，它接收一个函数，每次迭代就自动回调该函数。以Array为例：vara=['A','B','C'];a.forEach(function(element,index,array){//element:指向当前元素的值//index:指向当前索引//array:指向Array对象本身alert(element);});Set与Array类似，但Set没有索引，因此回调函数的前两个参数都是元素本身：vars=newSet(['A','B','C']);s.forEach(function(element,sameElement,set){alert(element);});Map的回调函数参数依次为value、key和map本身：varm=newMap([[1,'x'],[2,'y'],[3,'z']]);m.forEach(function(value,key,map){alert(value);});如果对某些参数不感兴趣，由于JavaScript的函数调用不要求参数必须一致，因此可以忽略它们。例如，只需要获得Array的element：vara=['A','B','C'];a.forEach(function(element){alert(element);});在JavaScript中，定义函数的方式如下：functionabs(x){if(x>=0){returnx;}else{return-x;}}由于JavaScript的函数也是一个对象，上述定义的abs()函数实际上是一个函数对象，而函数名abs可以视为指向该函数的变量。因此，第二种定义函数的方式如下：varabs=function(x){if(x>=0){returnx;}else{return-x;}};在这种方式下，function(x){...}是一个匿名函数，它没有函数名。但是，这个匿名函数赋值给了变量abs，所以，通过变量abs就可以调用该函数。上述两种定义完全等价，注意第二种方式按照完整语法需要在函数体末尾加一个;，表示赋值语句结束。由于JavaScript允许传入任意个参数而不影响调用，因此传入的参数比定义的参数多也没有问题，虽然函数内部并不需要这些参数：abs(10,'blablabla');//返回10abs(-9,'haha','hehe',null);//返回9传入的参数比定义的少也没有问题：abs();//返回NaNJavaScript还有一个免费赠送的关键字arguments，它只在函数内部起作用，并且永远指向当前函数的调用者传入的所有参数。arguments类似Array但它不是一个Array利用arguments，你可以获得调用者传入的所有参数。也就是说，即使函数不定义任何参数，还是可以拿到参数的值：functionabs(){if(arguments.length===0){return0;}varx=arguments[0];returnx>=0?x:-x;}abs();//0abs(10);//10abs(-9);//9实际上arguments最常用于判断传入参数的个数。//foo(a[,b],c)//接收2~3个参数，b是可选参数，如果只传2个参数，b默认为null：functionfoo(a,b,c){if(arguments.length===2){//实际拿到的参数是a和b，c为undefinedc=b;//把b赋给cb=null;//b变为默认值}//...}要把中间的参数b变为“可选”参数，就只能通过arguments判断，然后重新调整参数并赋值。由于JavaScript函数允许接收任意个参数，于是我们就不得不用arguments来获取所有参数：functionfoo(a,b){vari,rest=[];if(arguments.length>2){for(i=2;i<arguments.length;i++){rest.push(arguments[i]);}}console.log('a='+a);console.log('b='+b);console.log(rest);}为了获取除了已定义参数a、b之外的参数，我们不得不用arguments，并且循环要从索引2开始以便排除前两个参数，这种写法很别扭，只是为了获得额外的rest参数，有没有更好的方法？ES6标准引入了rest参数，上面的函数可以改写为：functionfoo(a,b,...rest){console.log('a='+a);console.log('b='+b);console.log(rest);}foo(1,2,3,4,5);//结果://a=1//b=2//Array[3,4,5]foo(1);//结果://a=1//b=undefined//Array[]rest参数只能写在最后，前面用...标识，从运行结果可知，传入的参数先绑定a、b，*多余的参数*以数组形式交给变量rest，所以，不再需要arguments我们就获取了全部参数。如果传入的参数连正常定义的参数都没填满，也不要紧，rest参数会接收一个空数组（注意不是undefined）。functionsum(...rest){varsums=0;for(iofrest){sums=sums+i}returnsums}JavaScript的函数定义有个特点，它会先扫描整个函数体的语句，把所有申明的变量“提升”到函数顶部虽然是strict模式，但语句varx='Hello,'+y;并不报错，原因是变量y在稍后申明了。但是alert显示Hello,undefined，说明变量y的值为undefined。这正是因为JavaScript引擎自动提升了变量y的声明，但不会提升变量y的赋值。由于JavaScript的这一怪异的“特性”，我们在函数内部定义变量时，请严格遵守“在函数内部首先申明所有变量”这一规则。最常见的做法是用一个var申明函数内部用到的所有变量：functionfoo(){varx=1,//x初始化为1y=x+1,//y初始化为2z,i;//z和i为undefined//其他语句:for(i=0;i<100;i++){...}}不在任何函数内定义的变量就具有全局作用域。实际上，JavaScript默认有一个全局对象window，全局作用域的变量实际上被绑定到window的一个属性：'usestrict';varcourse='LearnJavaScript';alert(course);//'LearnJavaScript'alert(window.course);//'LearnJavaScript'因此，直接访问全局变量course和访问window.course是完全一样的。你可能猜到了，由于函数定义有两种方式，以变量方式varfoo=function(){}定义的函数实际上也是一个全局变量，因此，顶层函数的定义也被视为一个全局变量，并绑定到window对象：'usestrict';functionfoo(){alert('foo');}foo();//直接调用foo()window.foo();//通过window.foo()调用进一步大胆地猜测，我们每次直接调用的alert()函数其实也是window的一个变量：'usestrict';window.alert('调用window.alert()');//把alert保存到另一个变量:varold_alert=window.alert;//给alert赋一个新函数:window.alert=function(){}alert('无法用alert()显示了!');//恢复alert:window.alert=old_alert;alert('又可以用alert()了!');这说明JavaScript实际上只有一个全局作用域。任何变量（函数也视为变量），如果没有在当前函数作用域中找到，就会继续往上查找，最后如果在全局作用域中也没有找到，则报ReferenceError错误。全局变量会绑定到window上，不同的JavaScript文件如果使用了相同的全局变量，或者定义了相同名字的顶层函数，都会造成命名冲突，并且很难被发现。减少冲突的一个方法是把自己的所有变量和函数全部绑定到一个全局变量中。例如：//唯一的全局变量MYAPP:varMYAPP={};//其他变量:MYAPP.name='myapp';MYAPP.version=1.0;//其他函数:MYAPP.foo=function(){return'foo';};把自己的代码全部放入唯一的名字空间MYAPP中，会大大减少全局变量冲突的可能。许多著名的JavaScript库都是这么干的：jQuery，YUI，underscore等等。由于JavaScript的变量作用域实际上是函数内部，我们在for循环等语句块中是无法定义具有局部作用域的变量的为了解决块级作用域，ES6引入了新的关键字let，用let替代var可以申明一个块级作用域的变量：'usestrict';functionfoo(){varsum=0;for(leti=0;i<100;i++){sum+=i;}i+=1;//SyntaxError}由于var和let申明的是变量，如果要申明一个常量，在ES6之前是不行的，我们通常用全部大写的变量来表示“这是一个常量，不要修改它的值”：varPI=3.14;ES6标准引入了新的关键字const来定义常量，const与let都具有块级作用域：'usestrict';constPI=3.14;PI=3;//某些浏览器不报错，但是无效果！PI;//3.14在一个对象中绑定函数，称为这个对象的方法。如果我们给xiaoming绑定一个函数，就可以做更多的事情。比如，写个age()方法，返回xiaoming的年龄：varxiaoming={name:'小明',birth:1990,age:function(){vary=newDate().getFullYear();returny-this.birth;}};xiaoming.age;//functionxiaoming.age()xiaoming.age();//今年调用是25,明年调用就变成26了绑定到对象上的函数称为方法，和普通函数也没啥区别，但是它在内部使用了一个this关键字，这个东东是什么？在一个方法内部，this是一个特殊变量，它始终指向当前对象，也就是xiaoming这个变量。所以，this.birth可以拿到xiaoming的birth属性。单独调用函数getAge()怎么返回了NaN？请注意，我们已经进入到了JavaScript的一个大坑里。JavaScript的函数内部如果调用了this，那么这个this到底指向谁？答案是，视情况而定！如果以对象的方法形式调用，比如xiaoming.age()，该函数的this指向被调用的对象，也就是xiaoming，这是符合我们预期的。如果单独调用函数，比如getAge()，此时，该函数的this指向全局对象，也就是window。更坑爹的是，如果这么写：varfn=xiaoming.age;//先拿到xiaoming的age函数fn();//NaN也是不行的！要保证this指向正确，必须用obj.xxx()的形式调用！虽然在一个独立的函数调用中，根据是否是strict模式，this指向undefined或window，不过，我们还是可以控制this的指向的！要指定函数的this指向哪个对象，可以用函数本身的apply方法，它接收两个参数，第一个参数就是需要绑定的this变量，第二个参数是Array，表示函数本身的参数。用apply修复getAge()调用：functiongetAge(){vary=newDate().getFullYear();returny-this.birth;}varxiaoming={name:'小明',birth:1990,age:getAge};xiaoming.age();//25getAge.apply(xiaoming,[]);//25,this指向xiaoming,参数为空另一个与apply()类似的方法是call()，唯一区别是：apply()把参数打包成Array再传入；call()把参数按顺序传入。利用apply()，我们还可以动态改变函数的行为。JavaScript的所有对象都是动态的，即使内置的函数，我们也可以重新指向新的函数。现在假定我们想统计一下代码一共调用了多少次parseInt()，可以把所有的调用都找出来，然后手动加上count+=1，不过这样做太傻了。最佳方案是用我们自己的函数替换掉默认的parseInt()：varcount=0;varoldParseInt=parseInt;//保存原函数window.parseInt=function(){count+=1;returnoldParseInt.apply(null,arguments);//调用原函数};//测试:parseInt('10');parseInt('20');parseInt('30');count;//3JavaScript的函数其实都指向某个变量。既然变量可以指向函数，函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数。由于map()方法定义在JavaScript的Array中，我们调用Array的map()方法，传入我们自己的函数，就得到了一个新的Array作为结果：functionpow(x){returnx*x;}vararr=[1,2,3,4,5,6,7,8,9];arr.map(pow);//[1,4,9,16,25,36,49,64,81]循环代码，我们无法一眼看明白“把f(x)作用在Array的每一个元素并把结果生成一个新的Array”。所以，map()作为高阶函数，事实上它把运算规则抽象了，因此，我们不但可以计算简单的f(x)=x2，还可以计算任意复杂的函数，比如，把Array的所有数字转为字符串：vararr=[1,2,3,4,5,6,7,8,9];arr.map(String);//['1','2','3','4','5','6','7','8','9']只需要一行代码。Array的reduce()把一个函数作用在这个Array的[x1,x2,x3...]上，这个函数必须接收两个参数，reduce()把结果继续和序列的下一个元素做累积计算.比方说对一个Array求和，就可以用reduce实现：vararr=[1,3,5,7,9];arr.reduce(function(x,y){returnx+y;});//25利用reduce()求积：'usestrict';functionproduct(arr){returnarr.reduce(function(x,y){returnx*y})}和map()类似，Array的filter()也接收一个函数。和map()不同的是，filter()把传入的函数依次作用于每个元素，然后根据返回值是true还是false决定保留还是丢弃该元素。例如，在一个Array中，删掉偶数，只保留奇数，可以这么写：vararr=[1,2,4,5,6,9,10,15];varr=arr.filter(function(x){returnx%2!==0;});r;//[1,5,9,15]JavaScript的Array的sort()方法就是用于排序的，但是排序结果可能让你大吃一惊：//看上去正常的结果:['Google','Apple','Microsoft'].sort();//['Apple','Google','Microsoft'];//apple排在了最后:['Google','apple','Microsoft'].sort();//['Google','Microsoft",'apple']//无法理解的结果:[10,20,1,2].sort();//[1,10,2,20]第二个排序把apple排在了最后，是因为字符串根据ASCII码进行排序，而小写字母a的ASCII码在大写字母之后。第三个排序结果是什么鬼？简单的数字排序都能错？这是因为Array的sort()方法默认把所有元素先转换为String再排序，结果'10'排在了'2'的前面，因为字符'1'比字符'2'的ASCII码小。幸运的是，sort()方法也是一个高阶函数，它还可以接收一个比较函数来实现自定义的排序。要按数字大小排序，我们可以这么写：vararr=[10,20,1,2];arr.sort(function(x,y){if(x<y){return-1;}if(x>y){return1;}return0;});//[1,2,10,20]sort()方法会直接对Array进行修改，它返回的结果仍是当前Array：vara1=['B','A','C'];vara2=a1.sort();a1;//['A','B','C']a2;//['A','B','C']a1===a2;//true,a1和a2是同一对象高阶函数除了可以接受函数作为参数外，还可以把函数作为结果值返回。但是，如果不需要立刻求和，而是在后面的代码中，根据需要再计算怎么办？可以不返回求和的结果，而是返回求和的函数！functionlazy_sum(arr){varsum=function(){returnarr.reduce(function(x,y){returnx+y;});}returnsum;}当我们调用lazy_sum()时，返回的并不是求和结果，而是求和函数：varf=lazy_sum([1,2,3,4,5]);//functionsum()调用函数f时，才真正计算求和的结果：f();//15在这个例子中，我们在函数lazy_sum中又定义了函数sum，并且，内部函数sum可以引用外部函数lazy_sum的参数和局部变量，当lazy_sum返回函数sum时，相关参数和变量都保存在返回的函数中，这种称为“闭包（Closure）”的程序结构拥有极大的威力。请再注意一点，当我们调用lazy_sum()时，每次调用都会返回一个新的函数，即使传入相同的参数varf1=lazy_sum([1,2,3,4,5]);varf2=lazy_sum([1,2,3,4,5]);f1===f2;//falsef1()和f2()的调用结果互不影响注意到返回的函数在其定义内部引用了局部变量arr，所以，当一个函数返回了一个函数后，其内部的局部变量还被新函数引用，所以，闭包用起来简单，实现起来可不容易。返回闭包时牢记的一点就是：返回函数不要引用任何循环变量，或者后续会发生变化的变量。如果一定要引用循环变量怎么办？方法是再创建一个函数，用该函数的参数绑定循环变量当前的值，无论该循环变量后续如何更改，已绑定到函数参数的值不变在返回的对象中，实现了一个闭包，该闭包携带了局部变量x，并且，从外部代码根本无法访问到变量x。换句话说，闭包就是携带状态的函数，并且它的状态可以完全对外隐藏起来。闭包还可以把多参数的函数变成单参数的函数。例如，要计算xy可以用Math.pow(x,y)函数，不过考虑到经常计算x2或x3，我们可以利用闭包创建新的函数pow2和pow3：functionmake_pow(n){returnfunction(x){returnMath.pow(x,n);}}//创建两个新函数:varpow2=make_pow(2);varpow3=make_pow(3);pow2(5);//25pow3(7);//343ES6标准新增了一种新的函数：ArrowFunction（箭头函数）。为什么叫ArrowFunction？因为它的定义用的就是一个箭头：x=>x*x上面的箭头函数相当于：function(x){returnx*x;}(像lambdax:x*x)箭头函数相当于匿名函数，并且简化了函数定义。箭头函数有两种格式，一种像上面的，只包含一个表达式，连{...}和return都省略掉了。还有一种可以包含多条语句，这时候就不能省略{...}和return：x=>{if(x>0){returnx*x;}else{return-x*x;}}如果参数不是一个，就需要用括号()括起来：//两个参数:(x,y)=>x*x+y*y//无参数:()=>3.14//可变参数:(x,y,...rest)=>{vari,sum=x+y;for(i=0;i<rest.length;i++){sum+=rest[i];}returnsum;}如果要返回一个对象，就要注意，如果是单表达式，这么写的话会报错：//SyntaxError:x=>{foo:x}因为和函数体的{...}有语法冲突，所以要改为：//ok:x=>({foo:x})箭头函数看上去是匿名函数的一种简写，但实际上，箭头函数和匿名函数有个明显的区别：箭头函数内部的this是词法作用域，由上下文确定。由于this在箭头函数中已经按照词法作用域绑定了，所以，用call()或者apply()调用箭头函数时，无法对this进行绑定，即传入的第一个参数被忽略generator（生成器）是ES6标准引入的新的数据类型。一个generator看上去像一个函数，但可以返回多次。generator跟函数很像，定义如下：function*foo(x){yieldx+1;yieldx+2;returnx+3;}generator和函数不同的是，generator由function*定义（注意多出的*号），并且，除了return语句，还可以用yield返回多次。直接调用一个generator和调用函数不一样，fib(5)仅仅是创建了一个generator对象，还没有去执行它。调用generator对象有两个方法，一是不断地调用generator对象的next()方法：varf=fib(5);f.next();//{value:0,done:false}f.next();//{value:1,done:false}f.next();//{value:1,done:false}f.next();//{value:2,done:false}f.next();//{value:3,done:true}next()方法会执行generator的代码，然后，每次遇到yieldx;就返回一个对象{value:x,done:true/false}，然后“暂停”。返回的value就是yield的返回值，done表示这个generator是否已经执行结束了。如果done为true，则value就是return的返回值。当执行到done为true时，这个generator对象就已经全部执行完毕，不要再继续调用next()了。第二个方法是直接用for...of循环迭代generator对象，这种方式不需要我们自己判断done：for(varxoffib(5)){console.log(x);//依次输出0,1,1,2,3}generator和普通函数相比，有什么用？因为generator可以在执行过程中多次返回，所以它看上去就像一个可以记住执行状态的函数，利用这一点，写一个generator就可以实现需要用面向对象才能实现的功能。用对象的属性来保存状态，相当繁琐。在JavaScript的世界里，一切都是对象。但是某些对象还是和其他对象不太一样。为了区分对象的类型，我们用typeof操作符获取对象的类型number、boolean和string都有包装对象。没错，在JavaScript中，字符串也区分string类型和它的包装类型。包装对象用new创建：varn=newNumber(123);//123,生成了新的包装类型varb=newBoolean(true);//true,生成了新的包装类型vars=newString('str');//'str',生成了新的包装类型虽然包装对象看上去和原来的值一模一样，显示出来也是一模一样，但他们的类型已经变为object了！所以，包装对象和原始值用===比较会返回false：typeofnewNumber(123);//'object'newNumber(123)===123;//falsetypeofnewBoolean(true);//'object'newBoolean(true)===true;//falsetypeofnewString('str');//'object'newString('str')==='str';//false所以闲的蛋疼也不要使用包装对象！尤其是针对string类型！！！如果我们在使用Number、Boolean和String时，没有写new会发生什么情况？此时，Number()、Boolean和String()被当做普通函数，把任何类型的数据转换为number、boolean和string类型（注意不是其包装类型）是不是感觉头大了？这就是JavaScript特有的催眠魅力！总结一下，有这么几条规则需要遵守：不要使用newNumber()、newBoolean()、newString()创建包装对象；用parseInt()或parseFloat()来转换任意类型到number；用String()来转换任意类型到string，或者直接调用某个对象的toString()方法；通常不必把任意类型转换为boolean再判断，因为可以直接写if(myVar){...}；typeof操作符可以判断出number、boolean、string、function和undefined；判断Array要使用Array.isArray(arr)；判断null请使用myVar===null；判断某个全局变量是否存在用typeofwindow.myVar==='undefined'；函数内部判断某个变量是否存在用typeofmyVar==='undefined'。最后有细心的同学指出，任何对象都有toString()方法吗？null和undefined就没有！确实如此，这两个特殊值要除外，虽然null还伪装成了object类型。更细心的同学指出，number对象调用toString()报SyntaxError：123.toString();//SyntaxError遇到这种情况，要特殊处理一下：123..toString();//'123',注意是两个点！(123).toString();//'123'不要问为什么，这就是JavaScript代码的乐趣！在JavaScript中，Date对象用来表示日期和时间。要获取系统当前时间，用：varnow=newDate();now;//WedJun24201519:49:22GMT+0800(CST)now.getFullYear();//2015,年份now.getMonth();//5,月份，注意月份范围是0~11，5表示六月now.getDate();//24,表示24号now.getDay();//3,表示星期三now.getHours();//19,24小时制now.getMinutes();//49,分钟now.getSeconds();//22,秒now.getMilliseconds();//875,毫秒数now.getTime();//1435146562875,以number形式表示的时间戳注意，当前时间是浏览器从本机操作系统获取的时间，所以不一定准确，因为用户可以把当前时间设定为任何值。如果要创建一个指定日期和时间的Date对象，可以用：vard=newDate(2015,5,19,20,15,30,123);d;//FriJun19201520:15:30GMT+0800(CST)第二种创建一个指定日期和时间的方法是解析一个符合ISO8601格式的字符串：vard=Date.parse('2015-06-24T19:49:22.875+08:00');d;//1435146562875但它返回的不是Date对象，而是一个时间戳。不过有时间戳就可以很容易地把它转换为一个Date：vard=newDate(1435146562875);d;//WedJun24201519:49:22GMT+0800(CST)Date对象表示的时间总是按浏览器所在时区显示的，不过我们既可以显示本地时间，也可以显示调整后的UTC时间：vard=newDate(1435146562875);d.toLocaleString();//'2015/6/24下午7:49:22'，本地时间（北京时区+8:00），显示的字符串与操作系统设定的格式有关d.toUTCString();//'Wed,24Jun201511:49:22GMT'，UTC时间，与本地时间相差8小时那么在JavaScript中如何进行时区转换呢？实际上，只要我们传递的是一个number类型的时间戳，我们就不用关心时区转换。任何浏览器都可以把一个时间戳正确转换为本地时间。时间戳是个什么东西？时间戳是一个自增的整数，它表示从1970年1月1日零时整的GMT时区开始的那一刻，到现在的毫秒数。假设浏览器所在电脑的时间是准确的，那么世界上无论哪个时区的电脑，它们此刻产生的时间戳数字都是一样的，所以，时间戳可以精确地表示一个时刻，并且与时区无关。所以，我们只需要传递时间戳，或者把时间戳从数据库里读出来，再让JavaScript自动转换为当地时间就可以了。要获取当前时间戳，可以用：if(Date.now){alert(Date.now());//老版本IE没有now()方法}else{alert(newDate().getTime());}小明为了和女友庆祝情人节，特意制作了网页，并提前预定了法式餐厅。小明打算用JavaScript给女友一个惊喜留言：'usestrict';vartoday=newDate();if(today.getMonth()===2&&today.getDate()===14){alert('亲爱的，我预定了晚餐，晚上6点在餐厅见！');}结果女友并未出现。小明非常郁闷，请你帮忙分析他的JavaScript代码有何问题。2是3月。:JavaScript学艺不精，注定孤独一生。。。知道问题处在哪里吗？小明根本没有女朋友字符串是编程时涉及到的最多的一种数据结构，对字符串进行操作的需求几乎无处不在。比如判断一个字符串是否是合法的Email地址，虽然可以编程提取@前后的子串，再分别判断是否是单词和域名，但这样做不但麻烦，而且代码难以复用。正则表达式是一种用来匹配字符串的强有力的武器。它的设计思想是用一种描述性的语言来给字符串定义一个规则，凡是符合规则的字符串，我们就认为它“匹配”了，否则，该字符串就是不合法的。avaScript有两种方式创建一个正则表达式：第一种方式是直接通过/正则表达式/写出来，第二种方式是通过newRegExp('正则表达式')创建一个RegExp对象。两种写法是一样的：varre1=/ABC\-001/;varre2=newRegExp('ABC\\-001');re1;///ABC\-001/re2;///ABC\-001/注意，如果使用第二种写法，因为字符串的转义问题，字符串的两个\\实际上是一个\。先看看如何判断正则表达式是否匹配：varre=/^\d{3}\-\d{3,8}$/;re.test('010-12345');//truere.test('010-1234x');//falsere.test('01012345');//falseRegExp对象的test()方法用于测试给定的字符串是否符合条件。切分字符串用正则表达式切分字符串比用固定的字符更灵活，请看正常的切分代码：'abc'.split('');//['a','b','','','c']嗯，无法识别连续的空格，用正则表达式试试：'abc'.split(/\s+/);//['a','b','c']无论多少个空格都可以正常分割。加入,试试：'a,b,cd'.split(/[\s\,]+/);//['a','b','c','d']再加入;试试：'a,b;;cd'.split(/[\s\,\;]+/);//['a','b','c','d']除了简单地判断是否匹配之外，正则表达式还有提取子串的强大功能。用()表示的就是要提取的分组（Group）。^(\d{3})-(\d{3,8})$分别定义了两个组，可以直接从匹配的字符串中提取出区号和本地号码：varre=/^(\d{3})-(\d{3,8})$/;re.exec('010-12345');//['010-12345','010','12345']re.exec('01012345');//null如果正则表达式中定义了组，就可以在RegExp对象上用exec()方法提取出子串来。exec()方法在匹配成功后，会返回一个Array，第一个元素是正则表达式匹配到的整个字符串，后面的字符串表示匹配成功的子串。exec()方法在匹配失败时返回null。需要特别指出的是，正则匹配默认是贪婪匹配，也就是匹配尽可能多的字符。必须让\d+采用非贪婪匹配（也就是尽可能少匹配），才能把后面的0匹配出来，加个?就可以让\d+采用非贪婪匹配：varre=/^(\d+?)(0*)$/;re.exec('102300');//['102300','1023','00']JavaScript的正则表达式还有几个特殊的标志，最常用的是g，表示全局匹配：varr1=/test/g;//等价于:varr2=newRegExp('test','g');全局匹配可以多次执行exec()方法来搜索一个匹配的字符串。当我们指定g标志后，每次运行exec()，正则表达式本身会更新lastIndex属性，表示上次匹配到的最后索引：vars='JavaScript,VBScript,JScriptandECMAScript';varre=/[a-zA-Z]+Script/g;//使用全局匹配:re.exec(s);//['JavaScript']re.lastIndex;//10re.exec(s);//['VBScript']re.lastIndex;//20re.exec(s);//['JScript']re.lastIndex;//29re.exec(s);//['ECMAScript']re.lastIndex;//44re.exec(s);//null，直到结束仍没有匹配到全局匹配类似搜索，因此不能使用/^...$/，那样只会最多匹配一次。正则表达式还可以指定i标志，表示忽略大小写，m标志，表示执行多行匹配。正则表达式非常强大，要在短短的一节里讲完是不可能的。要讲清楚正则的所有内容，可以写一本厚厚的书了。如果你经常遇到正则表达式的问题，你可能需要一本正则表达式的参考书（经常用的，必须通，注意，是经常。）JSON是JavaScriptObjectNotation的缩写，它是一种数据交换格式。在JSON出现之前，大家一直用XML来传递数据。因为XML是一种纯文本格式，所以它适合在网络上交换数据。XML本身不算复杂，但是，加上DTD、XSD、XPath、XSLT等一大堆复杂的规范以后，任何正常的软件开发人员碰到XML都会感觉头大了，最后大家发现，即使你努力钻研几个月，也未必搞得清楚XML的规范。终于，在2002年的一天，道格拉斯·克罗克福特（DouglasCrockford）同学为了拯救深陷水深火热同时又被某几个巨型软件企业长期愚弄的软件工程师，发明了JSON这种超轻量级的数据交换格式。道格拉斯同学长期担任雅虎的高级架构师，自然钟情于JavaScript。他设计的JSON实际上是JavaScript的一个子集。在JSON中，一共就这么几种数据类型：number：和JavaScript的number完全一致；boolean：就是JavaScript的true或false；string：就是JavaScript的string；null：就是JavaScript的null；array：就是JavaScript的Array表示方式——[]；object：就是JavaScript的{...}表示方式。以及上面的任意组合。并且，JSON还定死了字符集必须是UTF-8，表示多语言就没有问题了。为了统一解析，JSON的字符串规定必须用双引号""，Object的键也必须用双引号""。由于JSON非常简单，很快就风靡Web世界，并且成为ECMA标准。几乎所有编程语言都有解析JSON的库，而在JavaScript中，我们可以直接使用JSON，因为JavaScript内置了JSON的解析。把任何JavaScript对象变成JSON，就是把这个对象序列化成一个JSON格式的字符串，这样才能够通过网络传递给其他计算机。如果我们收到一个JSON格式的字符串，只需要把它反序列化成一个JavaScript对象，就可以在JavaScript中直接使用这个对象了。JavaScript的原型链和Java的Class区别就在，它没有“Class”的概念，所有对象都是实例，所谓继承关系不过是把一个对象的原型指向另一个对象而已。JavaScript对每个创建的对象都会设置一个原型，指向它的原型对象。当我们用obj.xxx访问一个对象的属性时，JavaScript引擎先在当前对象上查找该属性，如果没有找到，就到其原型对象上找，如果还没有找到，就一直上溯到Object.prototype对象，最后，如果还没有找到，就只能返回undefined。例如，创建一个Array对象：vararr=[1,2,3];其原型链是：arr---->Array.prototype---->Object.prototype---->null在传统的基于Class的语言如Java、C++中，继承的本质是扩展一个已有的Class，并生成新的Subclass。由于这类语言严格区分类和实例，继承实际上是类型的扩展。但是，JavaScript由于采用原型继承，我们无法直接扩展一个Class，因为根本不存在Class这种类型。JavaScript的原型继承实现方式就是：定义新的构造函数，并在内部用call()调用希望“继承”的构造函数，并绑定this；借助中间函数F实现原型链继承，最好通过封装的inherits函数完成；继续在新的构造函数的原型上定义新方法在上面的章节中我们看到了JavaScript的对象模型是基于原型实现的，特点是简单，缺点是理解起来比传统的类－实例模型要困难，最大的缺点是继承的实现需要编写大量代码，并且需要正确实现原型链。有没有更简单的写法？有！新的关键字class从ES6开始正式被引入到JavaScript中。class的目的就是让定义类更简单。JavaScript可以获取浏览器提供的很多对象，并进行操作。windowwindow对象不但充当全局作用域，而且表示浏览器窗口。window对象有innerWidth和innerHeight属性，可以获取浏览器窗口的内部宽度和高度。内部宽高是指除去菜单栏、工具栏、边框等占位元素后，用于显示网页的净宽高。对应的，还有一个outerWidth和outerHeight属性，可以获取浏览器窗口的整个宽高。navigatornavigator对象表示浏览器的信息，最常用的属性包括：navigator.appName：浏览器名称；navigator.appVersion：浏览器版本；navigator.language：浏览器设置的语言；navigator.platform：操作系统类型；navigator.userAgent：浏览器设定的User-Agent字符串。请注意，navigator的信息可以很容易地被用户修改，所以JavaScript读取的值不一定是正确的。这样既可能判断不准确，也很难维护代码。正确的方法是充分利用JavaScript对不存在属性返回undefined的特性，直接用短路运算符||计算：varwidth=window.innerWidth||document.body.clientWidth;screenscreen对象表示屏幕的信息，常用的属性有：screen.width：屏幕宽度，以像素为单位；screen.height：屏幕高度，以像素为单位；screen.colorDepth：返回颜色位数，如8、16、24。locationlocation对象表示当前页面的URL信息。可以用location.href获取。要获得URL各个部分的值，可以这么写：location.protocol;//'http'location.host;//'www.example.com'location.port;//'8080'location.pathname;//'/path/index.html'location.search;//'?a=1&b=2'location.hash;//'TOP'要加载一个新页面，可以调用location.assign()。如果要重新加载当前页面，调用location.reload()方法非常方便。documentdocument对象表示当前页面。由于HTML在浏览器中以DOM形式表示为树形结构，document对象就是整个DOM树的根节点。document的title属性是从HTML文档中的<title>xxx</title>读取的，但是可以动态改变。。。要查找DOM树的某个节点，需要从document对象开始查找。最常用的查找是根据ID和TagName。用document对象提供的getElementById()和getElementsByTagName()可以按ID获得一个DOM节点和按Tag名称获得一组DOM节点：document对象还有一个cookie属性，可以获取当前页面的Cookie。Cookie是由服务器发送的key-value标示符。因为HTTP协议是无状态的，但是服务器要区分到底是哪个用户发过来的请求，就可以用Cookie来区分。当一个用户成功登录后，服务器发送一个Cookie给浏览器，例如user=ABC123XYZ(加密的字符串)...，此后，浏览器访问该网站时，会在请求头附上这个Cookie，服务器根据Cookie即可区分出用户。Cookie还可以存储网站的一些设置，例如，页面显示的语言等等。JavaScript可以通过document.cookie读取到当前页面的Cookie：document.cookie;//'v=123;remember=true;prefer=zh'由于JavaScript能读取到页面的Cookie，而用户的登录信息通常也存在Cookie中，这就造成了巨大的安全隐患，这是因为在HTML页面中引入第三方的JavaScript代码是允许的为了解决这个问题，服务器在设置Cookie时可以使用httpOnly，设定了httpOnly的Cookie将不能被JavaScript读取。这个行为由浏览器实现，主流浏览器均支持httpOnly选项，IE从IE6SP1开始支持。为了确保安全，服务器端在设置Cookie时，应该始终坚持使用httpOnly。historyhistory对象保存了浏览器的历史记录，JavaScript可以调用history对象的back()或forward()，相当于用户点击了浏览器的“后退”或“前进”按钮。这个对象属于历史遗留对象，对于现代Web页面来说，由于大量使用AJAX和页面交互，简单粗暴地调用history.back()可能会让用户感到非常愤怒。新手开始设计Web页面时喜欢在登录页登录成功时调用history.back()，试图回到登录前的页面。这是一种错误的方法。任何情况，你都不应该使用history这个对象了。由于HTML文档被浏览器解析后就是一棵DOM树，要改变HTML的结构，就需要通过JavaScript来操作DOM。始终记住DOM是一个树形结构。操作一个DOM节点实际上就是这么几个操作：更新：更新该DOM节点的内容，相当于更新了该DOM节点表示的HTML的内容；遍历：遍历该DOM节点下的子节点，以便进行进一步操作；添加：在该DOM节点下新增一个子节点，相当于动态增加了一个HTML节点；删除：将该节点从HTML中删除，相当于删掉了该DOM节点的内容以及它包含的所有子节点。在操作一个DOM节点前，我们需要通过各种方式先拿到这个DOM节点。最常用的方法是document.getElementById()和document.getElementsByTagName()，以及CSS选择器document.getElementsByClassName()。由于ID在HTML文档中是唯一的，所以document.getElementById()可以直接定位唯一的一个DOM节点。document.getElementsByTagName()和document.getElementsByClassName()总是返回一组DOM节点。要精确地选择DOM，可以先定位父节点，再从父节点开始选择，以缩小范围。拿到一个DOM节点后，我们可以对它进行更新。插入。删除。用JavaScript操作表单和操作DOM是类似的，因为表单本身也是DOM树。不过表单的输入框、下拉框等可以接收用户输入，所以用JavaScript来操作表单，可以获得用户输入的内容，或者对一个输入框设置新的内容。HTML表单的输入控件主要有以下几种：文本框，对应的<inputtype="text">，用于输入文本；口令框，对应的<inputtype="password">，用于输入口令；单选框，对应的<inputtype="radio">，用于选择一项；复选框，对应的<inputtype="checkbox">，用于选择多项；下拉框，对应的<select>，用于选择一项；隐藏文本，对应的<inputtype="hidden">，用户不可见，但表单提交时会把隐藏文本发送到服务器。获取值如果我们获得了一个<input>节点的引用，就可以直接调用value获得对应的用户输入值：//<inputtype="text"id="email">varinput=document.getElementById('email');input.value;//'用户输入的值'这种方式可以应用于text、password、hidden以及select。但是，对于单选框和复选框，value属性返回的永远是HTML预设的值，而我们需要获得的实际是用户是否“勾上了”选项，所以应该用checked判断：//<label><inputtype="radio"name="weekday"id="monday"value="1">Monday</label>//<label><inputtype="radio"name="weekday"id="tuesday"value="2">Tuesday</label>varmon=document.getElementById('monday');vartue=document.getElementById('tuesday');mon.value;//'1'tue.value;//'2'mon.checked;//true或者falsetue.checked;//true或者false设置值设置值和获取值类似，对于text、password、hidden以及select，直接设置value就可以：//<inputtype="text"id="email">varinput=document.getElementById('email');input.value='test@example.com';//文本框的内容已更新对于单选框和复选框，设置checked为true或false即可。HTML5控件HTML5新增了大量标准控件，常用的包括date、datetime、datetime-local、color等，它们都使用<input>标签：type="date"类型的input的value将保证是一个有效的YYYY-MM-DD格式的日期，或者空字符串。最后，JavaScript可以以两种方式来处理表单的提交（AJAX方式在后面章节介绍）。方式一是通过<form>元素的submit()方法提交一个表单，例如，响应一个<button>的click事件，在JavaScript代码中提交表单：<!--HTML--><formid="test-form"><inputtype="text"name="test"><buttontype="button"onclick="doSubmitForm()">Submit</button></form><script>functiondoSubmitForm(){varform=document.getElementById('test-form');//可以在此修改form的input...//提交form:form.submit();}</script>这种方式的缺点是扰乱了浏览器对form的正常提交。浏览器默认点击<buttontype="submit">时提交表单，或者用户在最后一个输入框按回车键。因此，第二种方式是响应<form>本身的onsubmit事件，在提交form时作修改：<!--HTML--><formid="test-form"onsubmit="returncheckForm()"><inputtype="text"name="test"><buttontype="submit">Submit</button></form><script>functioncheckForm(){varform=document.getElementById('test-form');//可以在此修改form的input...//继续下一步:returntrue;}</script>注意要returntrue来告诉浏览器继续提交，如果returnfalse，浏览器将不会继续提交form，这种情况通常对应用户输入有误，提示用户错误信息后终止提交form。在检查和修改<input>时，要充分利用<inputtype="hidden">来传递数据。例如，很多登录表单希望用户输入用户名和口令，但是，安全考虑，提交表单时不传输明文口令，而是口令的MD5。用户输入了口令提交时，口令框的显示会突然从几个*变成32个*（因为MD5有32个字符）。要想不改变用户的输入，可以利用<inputtype="hidden">实现：<!--HTML--><formid="login-form"method="post"onsubmit="returncheckForm()"><inputtype="text"id="username"name="username"><inputtype="password"id="input-password"><inputtype="hidden"id="md5-password"name="password"><buttontype="submit">Submit</button></form><script>functioncheckForm(){varinput_pwd=document.getElementById('input-password');varmd5_pwd=document.getElementById('md5-password');//把用户输入的明文变为MD5:md5_pwd.value=toMD5(input_pwd.value);//继续下一步:returntrue;}</script>注意到id为md5-password的<input>标记了name="password"，而用户输入的id为input-password的<input>没有name属性。没有name属性的<input>的数据不会被提交。在HTML表单中，可以上传文件的唯一控件就是<inputtype="file">。注意：当一个表单包含<inputtype="file">时，表单的enctype必须指定为multipart/form-data，method必须指定为post，浏览器才能正确编码并以multipart/form-data格式发送表单的数据。出于安全考虑，浏览器只允许用户点击<inputtype="file">来选择本地文件，用JavaScript对<inputtype="file">的value赋值是没有任何效果的。当用户选择了上传某个文件后，JavaScript也无法获得该文件的真实路径由于JavaScript对用户上传的文件操作非常有限，尤其是无法读取文件内容，使得很多需要操作文件的网页不得不用Flash这样的第三方插件来实现。随着HTML5的普及，新增的FileAPI允许JavaScript读取文件内容，获得更多的文件信息。HTML5的FileAPI提供了File和FileReader两个主要对象，可以获得文件信息并读取文件。以DataURL的形式读取到的文件是一个字符串，类似于data:image/jpeg;base64,/9j/4AAQSk...(base64编码)...，常用于设置图像。如果需要服务器端处理，把字符串base64,后面的字符发送给服务器并用Base64解码就可以得到原始文件的二进制内容。上面的代码还演示了JavaScript的一个重要的特性就是单线程执行模式。在JavaScript中，浏览器的JavaScript执行引擎在执行JavaScript代码时，总是以单线程模式执行，也就是说，任何时候，JavaScript代码都不可能同时有多于1个线程在执行。你可能会问，单线程模式执行的JavaScript，如何处理多任务？在JavaScript中，执行多任务实际上都是异步调用，比如上面的代码：reader.readAsDataURL(file);就会发起一个异步操作来读取文件内容。因为是异步操作，所以我们在JavaScript代码中就不知道什么时候操作结束，因此需要先设置一个回调函数：reader.onload=function(e){//当文件读取完成后，自动调用此函数:};当文件读取完成后，JavaScript引擎将自动调用我们设置的回调函数。执行回调函数时，文件已经读取完毕，所以我们可以在回调函数内部安全地获得文件内容。AJAX不是JavaScript的规范，它只是一个哥们“发明”的缩写：AsynchronousJavaScriptandXML，意思就是用JavaScript执行异步网络请求。如果仔细观察一个Form的提交，你就会发现，一旦用户点击“Submit”按钮，表单开始提交，浏览器就会刷新页面，然后在新页面里告诉你操作是成功了还是失败了。如果不幸由于网络太慢或者其他原因，就会得到一个404页面。这就是Web的运作原理：一次HTTP请求对应一个页面。如果要让用户留在当前页面中，同时发出新的HTTP请求，就必须用JavaScript发送这个新请求，接收到数据后，再用JavaScript更新页面，这样一来，用户就感觉自己仍然停留在当前页面，但是数据却可以不断地更新。最早大规模使用AJAX的就是Gmail，Gmail的页面在首次加载后，剩下的所有数据都依赖于AJAX来更新。用JavaScript写一个完整的AJAX代码并不复杂，但是需要注意：AJAX请求是异步执行的，也就是说，要通过回调函数获得响应。在现代浏览器上写AJAX主要依靠XMLHttpRequest对象通过检测window对象是否有XMLHttpRequest属性来确定浏览器是否支持标准的XMLHttpRequest。。默认情况下，JavaScript在发送AJAX请求时，URL的域名必须和当前页面完全一致。完全一致的意思是，域名要相同（www.example.com和example.com不同），协议要相同（http和https不同），端口号要相同（默认是:80端口，它和:8080就不同）。有的浏览器口子松一点，允许端口不同，大多数浏览器都会严格遵守这个限制。那是不是用JavaScript无法请求外域（就是其他网站）的URL了呢？方法还是有的，大概有这么几种：一是通过Flash插件发送HTTP请求，这种方式可以绕过浏览器的安全限制，但必须安装Flash，并且跟Flash交互。不过Flash用起来麻烦，而且现在用得也越来越少了。二是通过在同源域名下架设一个代理服务器来转发，JavaScript负责把请求发送到代理服务器：'/proxy?url=http://www.sina.com.cn'代理服务器再把结果返回，这样就遵守了浏览器的同源策略。这种方式麻烦之处在于需要服务器端额外做开发。第三种方式称为JSONP，它有个限制，只能用GET请求，并且要求返回JavaScript。这种方式跨域实际上是利用了浏览器允许跨域引用JavaScript资源如果浏览器支持HTML5，那么就可以一劳永逸地使用新的跨域策略：CORS了。CORS全称Cross-OriginResourceSharing，是HTML5规范定义的如何跨域访问资源。Origin表示本域，也就是浏览器当前页面的域。当JavaScript向外域（如sina.com）发起请求后，浏览器收到响应后，首先检查Access-Control-Allow-Origin是否包含本域，如果是，则此次跨域请求成功，如果不是，则请求失败，JavaScript将无法获取到响应的任何数据。假设本域是my.com，外域是sina.com，只要响应头Access-Control-Allow-Origin为http://my.com，或者是*，本次请求就可以成功。可见，跨域能否成功，取决于对方服务器是否愿意给你设置一个正确的Access-Control-Allow-Origin，决定权始终在对方手中。（特意的限制规则，是为了更安全，更有序，这样“浪费”一点资源的分，是为了全局的更有益。分别，是好的，混合，是恶的）在JavaScript的世界中，所有代码都是单线程执行的。由于这个“缺陷”，导致JavaScript的所有网络操作，浏览器事件，都必须是异步执行。异步执行可以用回调函数实现：可见，异步操作会在将来的某个时间点触发一个函数调用。AJAX就是典型的异步操作。先统一执行AJAX逻辑，不关心如何处理结果，然后，根据结果是成功还是失败，在将来的某个时候调用success函数或fail函数。古人云：“君子一诺千金”，这种“承诺将来会执行”的对象在JavaScript中称为Promise对象。Promise有各种开源实现，在ES6中被统一规范，由浏览器直接支持。Promise最大的好处是在异步执行的流程中，把执行代码和处理结果的代码清晰地分离了Canvas是HTML5新增的组件，它就像一块幕布，可以用JavaScript在上面绘制各种图表、动画等。没有Canvas的年代，绘图只能借助Flash插件实现，页面不得不用JavaScript和Flash进行交互。有了Canvas，我们就再也不需要Flash了，直接使用JavaScript完成绘制。一个Canvas定义了一个指定尺寸的矩形框，在这个范围内我们可以随意绘制：<canvasid="test-canvas"width="300"height="200"></canvas>由于浏览器对HTML5标准支持不一致，所以，通常在<canvas>内部添加一些说明性HTML代码，如果浏览器支持Canvas，它将忽略<canvas>内部的HTML，如果浏览器不支持Canvas，它将显示<canvas>内部的HTML：<canvasid="test-stock"width="300"height="200"><p>CurrentPrice:25.51</p></canvas>在使用Canvas前，用canvas.getContext来测试浏览器是否支持Canvas：<!--HTML代码--><canvasid="test-canvas"width="200"heigth="100"><p>你的浏览器不支持Canvas</p></canvas>getContext('2d')方法让我们拿到一个CanvasRenderingContext2D对象，所有的绘图操作都需要通过这个对象完成。varctx=canvas.getContext('2d');如果需要绘制3D怎么办？HTML5还有一个WebGL规范，允许在Canvas中绘制3D图形：gl=canvas.getContext("webgl");CanvasRenderingContext2D对象有若干方法来绘制图形：'usestrict';varcanvas=document.getElementById('test-shape-canvas'),ctx=canvas.getContext('2d');ctx.clearRect(0,0,200,200);//擦除(0,0)位置大小为200x200的矩形，擦除的意思是把该区域变为透明ctx.fillStyle='#dddddd';//设置颜色ctx.fillRect(10,10,130,130);//把(10,10)位置大小为130x130的矩形涂色//利用Path绘制复杂路径:varpath=newPath2D();path.arc(75,75,50,0,Math.PI*2,true);path.moveTo(110,75);path.arc(75,75,35,0,Math.PI,false);path.moveTo(65,65);path.arc(60,65,5,0,Math.PI*2,true);path.moveTo(95,65);path.arc(90,65,5,0,Math.PI*2,true);ctx.strokeStyle='#0000ff';ctx.stroke(path);绘制文本就是在指定的位置输出文本，可以设置文本的字体、样式、阴影等，与CSS完全一致：'usestrict';varcanvas=document.getElementById('test-text-canvas'),ctx=canvas.getContext('2d');ctx.clearRect(0,0,canvas.width,canvas.height);ctx.shadowOffsetX=2;ctx.shadowOffsetY=2;ctx.shadowBlur=2;ctx.shadowColor='#666666';ctx.font='24pxArial';ctx.fillStyle='#333333';ctx.fillText('带阴影的文字',20,40);Canvas除了能绘制基本的形状和文本，还可以实现动画、缩放、各种滤镜和像素转换等高级操作。如果要实现非常复杂的操作，考虑以下优化方案：通过创建一个不可见的Canvas来绘图，然后将最终绘制结果复制到页面的可见Canvas中；尽量使用整数坐标而不是浮点数；可以创建多个重叠的Canvas绘制不同的层，而不是在一个Canvas中绘制非常复杂的图；背景图片如果不变可以直接用<img>标签并放到最底层。你可能听说过jQuery，它名字起得很土，但却是JavaScript世界中使用最广泛的一个库。江湖传言，全世界大约有80~90%的网站直接或间接地使用了jQuery。鉴于它如此流行，又如此好用，所以每一个入门JavaScript的前端工程师都应该了解和学习它。jQuery这么流行，肯定是因为它解决了一些很重要的问题。实际上，jQuery能帮我们干这些事情：消除浏览器差异：你不需要自己写冗长的代码来针对不同的浏览器来绑定事件，编写AJAX等代码；简洁的操作DOM的方法：写$('#test')肯定比document.getElementById('test')来得简洁；轻松实现动画、修改CSS等各种操作。jQuery的理念“WriteLess,DoMore“，让你写更少的代码，完成更多的工作！使用jQuery只需要在页面的<head>引入jQuery文件即可$是著名的jQuery符号。实际上，jQuery把所有功能全部封装在一个全局变量jQuery中，而$也是一个合法的变量名，它是变量jQuery的别名用JavaScript实现动画，原理非常简单：我们只需要以固定的时间间隔（例如，0.1秒），每次把DOM元素的CSS样式修改一点（例如，高宽各增加10%），看起来就像动画了。但是要用JavaScript手动实现动画效果，需要编写非常复杂的代码。如果想要把动画效果用函数封装起来便于复用，那考虑的事情就更多了。使用jQuery实现动画，代码已经简单得不能再简化了：只需要一行代码！用JavaScript写AJAX前面已经介绍过了，主要问题就是不同浏览器需要写不同代码，并且状态和错误处理写起来很麻烦。用jQuery的相关对象来处理AJAX，不但不需要考虑浏览器问题，代码也能大大简化高级语言通常都提供了更抽象的错误处理逻辑try...catch...finally，JavaScript也不例外。前面我们已经讲过了，JavaScript是函数式编程语言，支持高阶函数和闭包。函数式编程非常强大，可以写出非常简洁的代码。例如Array的map()和filter()方法：'usestrict';vara1=[1,4,9,16];vara2=a1.map(Math.sqrt);//[1,2,3,4]vara3=a2.filter((x)=>{returnx%2===0;});//[2,4]现在问题来了，Array有map()和filter()方法，可是Object没有这些方法。此外，低版本的浏览器例如IE6～8也没有这些方法，怎么办？方法一，自己把这些方法添加到Array.prototype中，然后给Object.prototype也加上mapObject()等类似的方法。方法二，直接找一个成熟可靠的第三方开源库，使用统一的函数来实现map()、filter()这些操作。我们采用方法二，选择的第三方库就是underscore。正如jQuery统一了不同浏览器之间的DOM操作的差异，让我们可以简单地对DOM进行操作，underscore则提供了一套完善的函数式编程的接口，让我们更方便地在JavaScript中实现函数式编程。jQuery在加载时，会把自身绑定到唯一的全局变量$上，underscore与其类似，会把自身绑定到唯一的全局变量_上，这也是为啥它的名字叫underscore的原因。开启JavaScript的后端开发之旅。Node.js是目前非常火热的技术，但是它的诞生经历却很奇特。话说有个叫RyanDahl的歪果仁，他的工作是用C/C++写高性能Web服务。对于高性能，异步IO、事件驱动是基本原则，但是用C/C++写就太痛苦了。于是这位仁兄开始设想用高级语言开发Web服务。他评估了很多种高级语言，发现很多语言虽然同时提供了同步IO和异步IO，但是开发人员一旦用了同步IO，他们就再也懒得写异步IO了，所以，最终，Ryan瞄向了JavaScript。因为JavaScript是单线程执行，根本不能进行同步IO操作，所以，JavaScript的这一“缺陷”导致了它只能使用异步IO。选定了开发语言，还要有运行时引擎。这位仁兄曾考虑过自己写一个，不过明智地放弃了，因为V8就是开源的JavaScript引擎。让Google投资去优化V8，咱只负责改造一下拿来用，还不用付钱，这个买卖很划算。于是在2009年，Ryan正式推出了基于JavaScript语言和V8引擎的开源Web服务器项目，命名为Node.js。虽然名字很土，但是，Node第一次把JavaScript带入到后端服务器开发，加上世界上已经有无数的JavaScript开发人员，所以Node一下子就火了起来。在Node上运行的JavaScript相比其他后端开发语言有何优势？最大的优势是借助JavaScript天生的事件驱动机制加V8高性能引擎，使编写高性能Web服务轻而易举。其次，JavaScript语言本身是完善的函数式语言，在前端开发时，开发人员往往写得比较随意，让人感觉JavaScript就是个“玩具语言”。但是，在Node环境下，通过模块化的JavaScript代码，加上函数式编程，并且无需考虑浏览器兼容性问题，直接使用最新的ECMAScript6标准，可以完全满足工程上的需求。我还听说过io.js，这又是什么鬼？因为Node.js是开源项目，虽然由社区推动，但幕后一直由Joyent公司资助。由于一群开发者对Joyent公司的策略不满，于2014年从Node.js项目fork出了io.js项目，决定单独发展，但两者实际上是兼容的。然而中国有句古话，叫做“分久必合，合久必分”。分家后没多久，Joyent公司表示要和解，于是，io.js项目又决定回归Node.js。具体做法是将来io.js将首先添加新的特性，如果大家测试用得爽，就把新特性加入Node.js。io.js是“尝鲜版”，而Node.js是线上稳定版，相当于FedoraLinux和RHEL的关系。由于Node.js平台是在后端运行JavaScript代码，所以，必须首先在本机安装Node环境。在正式开始Node.js学习之前，我们先认识一下npm。npm是什么东东？npm其实是Node.js的包管理工具（packagemanager）。为啥我们需要一个包管理工具呢？因为我们在Node.js上开发时，会用到很多别人写的JavaScript代码。如果我们要使用别人写的某个包，每次都根据名称搜索一下官方网站，下载代码，解压，再使用，非常繁琐。于是一个集中管理的工具应运而生：大家都把自己开发的模块打包后放到npm官网上，如果要使用，直接通过npm安装就可以直接用，不用管代码存在哪，应该从哪下载。更重要的是，如果我们要使用模块A，而模块A又依赖于模块B，模块B又依赖于模块X和模块Y，npm可以根据依赖关系，把所有依赖的包都下载下来并管理起来。否则，靠我们自己手动管理，肯定既麻烦又容易出错。讲了这么多，npm究竟在哪？其实npm已经在Node.js安装的时候顺带装好了。在前面的所有章节中，我们编写的JavaScript代码都是在浏览器中运行的，因此，我们可以直接在浏览器中敲代码，然后直接运行。从本章开始，我们编写的JavaScript代码将不能在浏览器环境中执行了，而是在Node环境中执行，因此，JavaScript代码将直接在你的计算机上以命令行的方式运行，所以，我们要先选择一个文本编辑器来编写JavaScript代码，并且把它保存到本地硬盘的某个目录，才能够执行。第一行总是写上'usestrict';是因为我们总是以严格模式运行JavaScript代码，避免各种潜在陷阱。然后，选择一个目录，例如C:\Workspace，把文件保存为hello.js，就可以打开命令行窗口，把当前目录切换到hello.js所在目录，然后输入以下命令运行这个程序了：C:\Workspace>nodehello.jsHello,world.也可以保存为别的名字，比如first.js，但是必须要以.js结尾。此外，文件名只能是英文字母、数字和下划线的组合。在Node交互式环境下，我们可以输入JavaScript代码并立刻执行。此外，在命令行模式运行.js文件和在Node交互式环境下直接运行JavaScript代码有所不同。Node交互式环境会把每一行JavaScript代码的结果自动打印出来，但是，直接运行JavaScript文件却不会。如果在JavaScript文件开头写上'usestrict';，那么Node在执行该JavaScript时将使用严格模式。但是，在服务器环境下，如果有很多JavaScript文件，每个文件都写上'usestrict';很麻烦。我们可以给Nodejs传递一个参数，让Node直接为所有js文件开启严格模式：node--use_strictcalc.js后续代码，如无特殊说明，我们都会直接给Node传递--use_strict参数来开启严格模式。使用文本编辑器来开发Node程序，最大的缺点是效率太低，运行Node程序还需要在命令行单独敲命令。如果还需要调试程序，就更加麻烦了。所以我们需要一个IDE集成开发环境，让我们能在一个环境里编码、运行、调试，这样就可以大大提升开发效率。Java的集成开发环境有Eclipse，Intellijidea等，C#的集成开发环境有VisualStudio，那么问题又来了：Node.js的集成开发环境到底哪家强？考察Node.js的集成开发环境，重点放在启动速度快，执行简单，调试方便这三点上。当然，免费使用是一个加分项。综合考察后，我们隆重向大家推荐Node.js集成开发环境：VisualStudioCodeVisualStudioCode由微软出品，但它不是那个大块头的VisualStudio，它是一个精简版的迷你VisualStudio，并且，VisualStudioCode可以跨！平！台！Windows、Mac和Linux通用。最早的软件都是运行在大型机上的，软件使用者通过“哑终端”登陆到大型机上去运行软件。后来随着PC机的兴起，软件开始主要运行在桌面上，而数据库这样的软件运行在服务器端，这种Client/Server模式简称CS架构。随着互联网的兴起，人们发现，CS架构不适合Web，最大的原因是Web应用程序的修改和升级非常迅速，而CS架构需要每个客户端逐个升级桌面App，因此，Browser/Server模式开始流行，简称BS架构。在BS架构下，客户端只需要浏览器，应用程序的逻辑和数据都存储在服务器端。浏览器只需要请求服务器，获取Web页面，并把Web页面展示给用户即可。当然，Web页面也具有极强的交互性。由于Web页面是用HTML编写的，而HTML具备超强的表现力，并且，服务器端升级后，客户端无需任何部署就可以使用到新的版本，因此，BS架构迅速流行起来。由于Node.js把JavaScript引入了服务器端，因此，原来必须使用PHP/Java/C#/Python/Ruby等其他语言来开发服务器端程序，现在可以使用Node.js开发了！用Node.js开发Web服务器端，有几个显著的优势：一是后端语言也是JavaScript，以前掌握了前端JavaScript的开发人员，现在可以同时编写后端代码；二是前后端统一使用JavaScript，就没有切换语言的障碍了；三是速度快，非常快！这得益于Node.js天生是异步的。在Node.js诞生后的短短几年里，出现了无数种Web框架、ORM框架、模版引擎、测试框架、自动化构建工具，数量之多，即使是JavaScript老司机，也不免眼花缭乱。目前，在npm上已发布的开源Node.js模块数量超过了30万个。有选择恐惧症的朋友，看到这里可以洗洗睡了。
