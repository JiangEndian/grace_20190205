   1 #!/bin/bash
   2 # Bash脚本正确的头部.
   3 
   4 # Cleanup, 版本 2
   5 
   6 # 需要以root运行.
   7 # 如果不是root用户，在此处添加错误信息打印代码和退出代码.
   8 
   9 LOG_DIR=/var/log
  10 # 使用变量比使用硬编码（hard-coded）更好。
  11 cd $LOG_DIR
  12 
  13 cat /dev/null > messages
  14 cat /dev/null > wtmp
  15 
  16 
  17 echo "Logs cleaned up."
  18 
  19 exit # 这是从一个脚本中退出正确合适的方法
  
     1 #!/bin/bash
   2 # Cleanup, 版本 3
   3 
   4 #  注意:
   5 #  -------
   6 #  这个脚本使用了相当多的特性，这些我们稍后将会解释.
   7 #
   8 #  到那时，你已经学了这本书的一半了，你将不会再对shell感觉神秘了。
   9 #
  10 
  11 
  12 
  13 LOG_DIR=/var/log
  14 ROOT_UID=0     # 只有用户ID变量$UID值为0的用户才有root权限.
  15 LINES=50       # 默认的行数
  16 E_XCD=66       # 不能进入到目录时的退出代码值
  17 E_NOTROOT=67   # 不是root用户时退出的代码值
  18 
  19 
  20 # 必须以root用户运行，以下进行检测
  21 if [ "$UID" -ne "$ROOT_UID" ]
  22 then
  23   echo "Must be root to run this script."
  24   exit $E_NOTROOT
  25 fi  
  26 
  27 if [ -n "$1" ]
  28 # 测试是否提供了命令行参数(即是测试命令行参数至少有一个参数)
  29 then
  30   lines=$1
  31 else  
  32   lines=$LINES # Default, if not specified on command line.
  33 fi  
  34 
  35 
  36 #  Stephane Chazelas建议,
  37 #+ 下面是一种更好的检测命令行参数的方法，
  38 #+ 但是对于现在来说还是有些高级。
  39 #
  40 #    E_WRONGARGS=65  # 不是数字参数 (参数格式不对)时的退出码
  41 #
  42 #    case "$1" in
  43 #    ""      ) lines=50;;
  44 #    *[!0-9]*) echo "Usage: `basename $0` file-to-cleanup"; exit $E_WRONGARGS;;
  45 #    *       ) lines=$1;;
  46 #    esac
  47 #
  48 #* 可以跳到"循环"那章阅读开头一部分去了解上面的代码意思.
  49 
  50 
  51 cd $LOG_DIR
  52 
  53 if [ `pwd` != "$LOG_DIR" ]  # 也可以用  if [ "$PWD" != "$LOG_DIR" ]
  54                             # 如果工作目录不在/var/log里?
  55 then
  56   echo "Can't change to $LOG_DIR."
  57   exit $E_XCD
  58 fi  #在操作清空日志文件之前再次检查是否在正确的目录里
  59 
  60 # 可以像下面再次确定是否在正确的目录里：
  61 #
  62 # cd /var/log || {
  63 #   echo "Cannot change to necessary directory." >&2
  64 #   exit $E_XCD;
  65 # }
  66 
  67 
  68 
  69 
  70 tail -$lines messages > mesg.temp # 保存message日志文件最后面几行日志信息到临时文件.
  71 mv mesg.temp messages             # 然后用临时文件覆盖messages日志文件
  72 
  73 
  74 # cat /dev/null > messages
  75 #* 上面这句把messages日志文件全部清空，这样没有上面那样保留最后几行安全
  76 
  77 cat /dev/null > wtmp  #  ': > wtmp' and '> wtmp'  have the same effect.
  78 echo "Logs cleaned up."
  79 
  80 exit 0
  81 #  
  82 #一个脚本以0为退出代码表明脚本执行成功.
  
  一些令人喜爱的UNIX系统（它们都基于4.2BSD）的脚本是四个字节的魔数，在字符”!”后面要求一个空格 -- #! /bin/sh.
  The #!行将会命令解释器(sh或是bash)在Shell脚本中最先看到的。因为这行以#字符开头，命令解释器最终执行脚本时将会正确的把这一行当做注释行来对待。这行刚刚好只起到了它调用命令解释器的作用。

事实上，如果脚本包含了额外的#!行，bash将会把它当作一个注释.

在脚本开头的 sha-bang (	#!) 是告诉系统这个文件是由特定命令解释器解释的一组命令。 那个 #! 实际上是两个字节的 [1] 魔数, 魔数是指定文件类型的特殊记号，在此是表示这是一个可执行的shell脚本（键入 man magic可了解更多的信息）。紧跟着#!的是一个路径名.这个路径名是解释这个脚本内命令的命令解释器程序的路径：可能是一个shell，也可能是一个编程语言或者是一个软件包程序。这个命令解释器能执行脚本内的命令语句。它从脚本开头（即从#!所在行的下一行）起执行，但是忽略注释行。

   1 #!/bin/rm
   2 # 删除自身的脚本.
   3 
   4 # 当你运行这个脚本时，除了这个脚本消失了之外，你不会发现更多其他的东西。
   5 
   6 WHATEVER=65
   7 
   8 echo "This line will never print (betcha!)."
   9 
  10 exit $WHATEVER  # 不要紧，脚本绝不会运行到这儿.
  
  也可以写一个以#!/bin/more,开头的文件，并执行它。执行结果会发现这是一个自我显示的文件。
  
  注释也可以出现在一个命令语句的后面。

   1 echo "A comment will follow." # 这里可以添加注释.
   2 #                            ^ 注意在#前面可以有空白符 #
   
   在同一行中，命令不会跟在一个注释的后面。因为这种情况下没有办法分辨注释的结尾，命令只能放在同一行的行首。用另外的一个新行开始下一个注释。
   
   当然了，在echo命令给出的一个转义的#字符并不会开始一个注释。同样地，出现在一些参数代换结构和在数值常量表达式中的#字符也同样不会开始一个注释。
   1 echo "The # here does not begin a comment."
   2 echo 'The # here does not begin a comment.'
   3 echo The \# here does not begin a comment.
   4 echo The # here begins a comment.
   5 
   6 echo ${PATH#*:}       # 前面的#是参数代换，不是注释.
   7 echo $(( 2#101011 ))  # 基本转换，不是注释.
   8 
   9 # 多谢, S.C.
标准的引用和转义 符（"'\）可以转义#。

当然，模式匹配操作也可以使用#，而不必把它当做注释的开始。

命令分割符[分号]. 分割符允许在同一行里有两个或更多的命令.

   1 echo hello; echo there
   2 
   3 
   4 if [ -x "$filename" ]; then    # 注意："if" and "then"需要分隔符
   5                                # 思考一下这是为什么?
   6   echo "File $filename exists."; cp $filename $filename.bak
   7 else
   8   echo "File $filename not found."; touch $filename
   9 fi; echo "File test complete."

注意”;”有时需要转义.

case语句分支的结束符[双分号].

   1 case "$variable" in
   2 abc)  echo "\$variable = abc" ;;
   3 xyz)  echo "\$variable = xyz" ;;
   4 esac
   
   部分引用[双引号]. "STRING"的引用会使STRING里的特殊字符能够被解释。
   完全引用[单引号]. 'STRING'能引用STRING里的所有字符（包括特殊字符也会被原样引用）. 这是一个比使用双引号(“)更强的引用。
   逗号操作符[逗号]. 逗号操作符用于连接一连串的数学表达式。这一串的数学表达式每一个都被求值，但只有最后一个被返回。（译者注：换句话说，就是整个表达式的值取决于最后一个表达式的值。）
   1 let "t2 = ((a = 9, 15 / 3))"  # Set "a = 9" and "t2 = 15 / 3"
   
   命令替换.`command` 结构使字符(`)[译者注：这个字符不是单引号，而是在标准美国键盘上的ESC键下面，在字符1左边，在TAB键上面的那个键，要特别留心]引住的命令（command）执行结果能赋值给一个变量。它也被称为后引号（backquotes）或是斜引号（backticks）.
   
   空命令[冒号]. 这个命令意思是空操作(即什么操作也不做). 它一般被认为是和shell的内建命令true是一样的。冒号":" 命令是Bash自身内建的, and its它的退出状态码是真(即0)。[译者注：shell中真用数字0表示].

   1 :
   2 echo $?   # 0

死循环可以这么写：

   1 while :
   2 do
   3    operation-1
   4    operation-2
   5    ...
   6    operation-n
   7 done
   8 
   9 # 等同于:
  10 #    while true
  11 #    do
  12 #      ...
  13 #    done

在if/then的测试结构中用作占位符:

   1 if condition
   2 then :   # 什么也不做的分支
   3 else
   4    take-some-action
   5 fi
   
   和重定向操作符（>）连用, 可以把一个文件的长度截短为零，文件的权限不变。如果文件不存在，则会创建一个新文件。
   1 : > data.xxx   # 文件"data.xxx"现在长度为0了	      
   2 
   3 # 作用相同于：cat /dev/null >data.xxx（译者注：echo >data.xxx也可以）
   4 # 但是，用NULL（:）操作符不会产生一个新的进程，因为NULL操作符是内建的。
   
   和添加重定向操作符（>>）连用(: >> target_file).如果目标文件存在则什么也没有发生，如果目标文件不存在，则创建它。这只能应用在普通文件中，不能用在管道，符号链接和其他的特殊文件。
   
   字符”:”也用于域分割符。比如说在/etc/passwd和环境变量$PATH里.
 bash$ echo $PATH
 /usr/local/bin:/bin:/usr/bin:/usr/X11R6/bin:/sbin:/usr/sbin:/usr/games
 
 取反一个测试结果或退出状态[感叹号]. 取反操作符(!)取反一个命令的退出状态(参考例子 6-2).它也取反一个测试操作。例如，它能改相等符( = )为不等符( != ).取反操作符(!)是一个Bash的关键字.
 还有一种环境里，在命令行中，感叹号（!）调用属于历史命令机制的调用(详细请看附录 J).值得一提的是，在一个脚本里，命令历史机制是被禁止的。
 
 算术操作符. 在计算时，星号（*）表示乘法运算符。两个星号(**)表示求幂运算符。
 变量替换 (引用一个变量的内容).
   1 var1=5
   2 var2=23skidoo
   3 
   4 echo $var1     # 5
   5 echo $var2     # 23skidoo

一个变量名前面加一个$字符前缀表示引用该变量的内容。

一组由圆括号括起来的命令是新开一个子shell来执行的.

因为是在子shell里执行，在圆括号里的变量不能被脚本的其他部分访问。因为父进程（即脚本进程）不能存取子进程（即子shell）创建的变量。
(a=hello; echo $a)
1 a=123
   2 ( a=321; )	      
   3 
   4 echo "a = $a"   # a = 123
   5 # 在圆括号里的变量"a"实际上是一个局部变量，作用局域只是在圆括号内用于数组始初化
   数组初始化.
   1 Array=(element1 element2 element3)
    1 cat {file1,file2,file3} > combined_file
   2 # 连接file1,file2,和file3的内容并写到文件combined_file里去.
   3 
   4 
   5 cp file22.{txt,backup}
   6 # 拷贝"file22.txt"内容为"file22.backup"
   ${}
参数替换.

$*, $@
位置参数.

$?
保存退出码值的变量. 变量$?保存了一个命令，一个函数，或一个脚本的退出状态码的值。

$$
进程ID变量. 变量$$保存了脚本运行时的进程ID值。
一个命令可以在文件名扩展中从逗号分隔的各模式来扩展参数列表。 [1] 文件名将会依照列表中逗号分隔开的模式匹配扩展。

	
在扩展中的所有模式都不能包含空白字符，除非空白字符是被转义或引用的。

echo {file1,file2}\ :{\ A," B",' C'}

file1 : A file1 : B file1 : C file2 : A file2 : B file2 : C

代码块[花括号]. 这个结构也是一组命令代码块，事实上，它是匿名的函数。然而与一个函数所不同的,在代码块里的变量仍然能被脚本后面的代码访问。

 bash$ { local a;
	      a=123; }
 bash: local: can only be used in a
function
 	      

   1 a=123
   2 { a=321; }
   3 echo "a = $a"   # a = 321   (结果是在代码块里的值)
   4 
   5 # 多谢, S.C.

由花括号括起的代码块可以引起输入输出的I/O重定向。

例子 3-1. 代码块与I/O重定向

   1 #!/bin/bash
   2 # 从/etc/fstab文件里按一次一行地读.
   3 
   4 File=/etc/fstab
   5 
   6 {
   7 read line1
   8 read line2
   9 } < $File
  10 
  11 echo "First line in $File is:"
  12 echo "$line1"
  13 echo
  14 echo "Second line in $File is:"
  15 echo "$line2"
  16 
  17 exit 0
  18 
  19 # 现在，你如何解析每一行的分割符?
  20 # 提示: 使用awk.
  
  例子 3-2. 把一个代码块的结果写进一个文件

   1 #!/bin/bash
   2 # rpm-check.sh
   3 
   4 # 查询一个rpm安装包的描述，软件清单，和是否它能够被安装.
   5 # 并把结果保存到一个文件中.
   6 # 
   7 # 这个脚本使用一个代码块来举例说明。
   8 
   9 SUCCESS=0
  10 E_NOARGS=65
  11 
  12 if [ -z "$1" ]
  13 then
  14   echo "Usage: `basename $0` rpm-file"
  15   exit $E_NOARGS
  16 fi  
  17 
  18 { 
  19   echo
  20   echo "Archive Description:"
  21   rpm -qpi $1       # 查询软件包的描述.
  22   echo
  23   echo "Archive Listing:"
  24   rpm -qpl $1       # 查询软件包中的软件清单.
  25   echo
  26   rpm -i --test $1  # 查询该软件包能否被安装.
  27   if [ "$?" -eq $SUCCESS ]
  28   then
  29     echo "$1 can be installed."
  30   else
  31     echo "$1 cannot be installed."
  32   fi  
  33   echo
  34 } > "$1.test"       # 把代码块的所有输出重定向到一个文件中。
  35 
  36 echo "Results of rpm test in file $1.test"
  37 
  38 # 参考rpm的man手册来理解上面所用的选项。
  39 
  40 exit 0
  不像一个用圆括号括起来的命令组，一个用花括号括起的代码块不会以一个子shell运行。
  
  在数组的上下文中,方括号表示数组的每个元素的数字编号.
   1 Array[1]=slot_1
   2 echo ${Array[1]}
   扩展并计算(( ))里的整数表达式[译者注：粗心的读者要注意了，是整数计算，可不能用来做浮点计算].
   
   scriptname >filename重定向scriptname的输出到文件filename中去. 如果文件filename存在则将会被覆盖.

command &>filename 会重定向命令command标准输出（stdout）和标准错误（stderr）到文件filename中.

command >&2 把命令command的标准输出（stdout）重定向到标准错误（stderr）.

scriptname >>filename appends把脚本scriptname的输出追加到文件filename.如果filename不存在，则它会被创建.

ASCII比较.
   1 veg1=carrots
   2 veg2=tomatoes
   3 
   4 if [[ "$veg1" < "$veg2" ]]
   5 then
   6   echo "Although $veg1 precede $veg2 in the dictionary,"
   7   echo "this implies nothing about my culinary preferences."
   8 else
   9   echo "What kind of dictionary are you using, anyhow?"
  10 fi
  
  管道. 把上一个命令的输出传给下一个命令，或是shell. 这是连接命令的一种方法.

   1 echo ls -l | sh
   2 #  把"echo ls -l"的输出传给shell,
   3 #+ 这等同与直接的"ls -l".
   4 
   5 
   6 cat *.lst | sort | uniq
   7 # 合并且排序所有的".lst"文件,然后删除多余的相同行.
   一个命令或一组命令的输出可以由管道传给一个脚本.
   1 #!/bin/bash
   2 # uppercase.sh : 把输入字符改为大写.
   3 
   4 tr 'a-z' 'A-Z'
   5 #  字母的范围一定要引号引起来，
   6 #+ 这样才能保护文件名而不会被扩展成单个字母的文件名.
   7 
   8 exit 0
现在,让我们把ls -l的输出用管道与这个脚本连起来.
 bash$ ls -l | ./uppercase.sh
 -RW-RW-R--    1 BOZO  BOZO       109 APR  7 19:49 1.TXT
 -RW-RW-R--    1 BOZO  BOZO       109 APR 14 16:48 2.TXT
 -RW-R--R--    1 BOZO  BOZO       725 APR 20 20:56 DATA-FILE
 
 管道里的每一个进程的标准输出都被当成下一个命令的标准输入. 如果不是这种情况，那么数据流会阻塞,并且管道不会引起预期的效果。
   1 cat file1 file2 | ls -l | sort
   2 # 来自"cat file1 file2"的输出会消失.

管道以子进程来运行, 因此不能引起变量的改变。
   1 variable="initial_value"
   2 echo "new_value" | read variable
   3 echo "variable = $variable"     # variable = initial_value

如果在管道中的一个命令失败了,会过早的终结整个管道的执行。这称为管道破坏（broken pipe),这时会发送一个叫SIGPIPE 的信号.

在后台运行作业. 一个后面跟一个&的命令会在后台运行.

 bash$ sleep 10 &
 [1] 850
 [1]+  Done                    sleep 10
 	      

在一个脚本里,在后台运行的命令或是偶数的循环可以在后台运行.

例子 3-3. 在后台运行一个循环

   1 #!/bin/bash
   2 # background-loop.sh
   3 
   4 for i in 1 2 3 4 5 6 7 8 9 10            # 第一个循环.
   5 do
   6   echo -n "$i "
   7 done & # 把这个循环放到后台去.
   8        # 它有时会后于第二个循环执行.
   9 
  10 echo   # 这个'echo'有时不会打印出来.
  11 
  12 for i in 11 12 13 14 15 16 17 18 19 20   # 第二个循环.
  13 do
  14   echo -n "$i "
  15 done  
  16 
  17 echo   # 这个'echo'有时不会打印出来.
  18 
  19 # ======================================================
  20 
  21 # 这个脚本的输出是:
  22 # 1 2 3 4 5 6 7 8 9 10 
  23 # 11 12 13 14 15 16 17 18 19 20 
  24 
  25 # 然而有时你也有可能得到如下的输出:
  26 # 11 12 13 14 15 16 17 18 19 20 
  27 # 1 2 3 4 5 6 7 8 9 10 bozo $
  28 # (第二个 'echo'没有执行. 为什么?)
  29 
  30 # 偶尔也会:
  31 # 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
  32 # (第一个 'echo' 没有执行. 为什么?)
  33 
  34 # 非常罕有的情况可能是:
  35 # 11 12 13 1 2 3 4 5 6 7 8 9 10 14 15 16 17 18 19 20 
  36 # 前台的循环抢占了后台的循环输出.
  37 
  38 exit 0
  39 
  40 #  Nasimuddin Ansari 建议在第6行和第14行的：echo -n "$i"　加入sleep 1
  41 #+ 将会更有趣
  42 #
  
   1 if [ $file1 -ot $file2 ]
   2 then
   3   echo "File $file1 is older than $file2."
   4 fi
   5 
   6 if [ "$a" -eq "$b" ]
   7 then
   8   echo "$a is equal to $b."
   9 fi
  10 
  11 if [ "$c" -eq 24 -a "$d" -eq 47 ]
  12 then
  13   echo "$c equals 24 and $d equals 47."
  14 fi
  
  用于stdin或stdout重定向的源或目的[dash].

   1 (cd /source/directory && tar cf - . ) | (cd /dest/directory && tar xpvf -)
   2 # 把整个目录树从一个目录移到另外一个目录
   3 # [谦逊的 Alan Cox <a.cox@swansea.ac.uk>,作了一些修改]
   4 
   5 # 1) cd /source/directory    源目录,这是要移动的目录所在地.
   6 # 2) &&                     逻辑与: 如果'cd'命令操作成功，然后就执行下一条命令.
   7 # 3) tar cf - .              tar命令的'c'选项创建一个新的归档文件,
   8 #                            而'f'(file)选项，后跟一个'-'表示创建的目标文件是标准输出,
   9 #                            并且要操作的源目录是当前目录 ('.').
  10 # 4) |                       然后由管道输出...
  11 # 5) ( ... )                 一个子shell
  12 # 6) cd /dest/directory      将当前目录切换到目的目录.
  13 # 7) &&                     逻辑与,和上面的解释一样
  14 # 8) tar xpvf -              解开归档文件('x'),保持文件属主和文件的权限('p'),
  15 #                            并且把输出的详细信息打印到标准输出 ('v'),
  16 #                            从标准输入读('f'后跟'-').
  17 #
  18 #                            注意'x'是一个命令,而'p', 'v', 'f'是选项.
  19 # 哇!
  20 
  21 
  22 
  23 # 更优雅的,但作用一样的:
  24 #   cd source/directory
  25 #   tar cf - . | (cd ../dest/directory; tar xpvf -)
  26 #
  27 #     也可以这样:
  28 # cp -a /source/directory/* /dest/directory
  29 #     或:
  30 # cp -a /source/directory/* /source/directory/.[^.]* /dest/directory
  31 #     如果在/source/directory有隐藏文件.
  
  注意"-"环境不是一个Bash操作符提供的,而是被由一些写标准输出的UNIX软件包来验证的，比如tar, cat,等等.

 bash$ echo "whatever" | cat -
 whatever 

当希望提供一个文件名时, '-' 重定向输出到标准输出(有时像tar cf),或者从标准输入接受输入,就好像它们是一个文件一样 . 这是在管道中使用文件导向（file-oriented）软件包作为一个过滤器的方法.

 bash$ file
 Usage: file [-bciknvzL] [-f namefile] [-m magicfiles] file...
 	      
只在命令行单独给出命令file，会引起一个错误信息.

加一个"-"来看看结果，这会使shell等候用户的输入。
 bash$ file -
 abc
 standard input:              ASCII text
 
 
 
 bash$ file -
 #!/bin/bash
 standard input:              Bourne-Again shell script text executable
 	      
现在命令从标准输入接受输入并分析它.

"-"能被用来把标准输出由管道输出到其他的命令.这样就允许使用在文件开头增加几行的技巧.

使用 diff 来比较一个文件和另一个文件的某一段:

grep Linux file1 | diff file2 -

例子 3-4. 备份前24小时被修改的文件

   1 #!/bin/bash
   2 
   3 #  备份当前目录下所有前24小时被修改的文件为一个归档压缩包（归档并且压缩）
   4 #
   5 
   6 BACKUPFILE=backup-$(date +%m-%d-%Y)
   7 #                 在备份文件中嵌入日期.
   8 #                 多谢Joshua Tschida的这个主意.
   9 archive=${1:-$BACKUPFILE}
  10 #  如果没有在命令行上指定备份的归档文件名,
  11 #+ 会以"backup-MM-DD-YYYY.tar.gz."作为默认的文件名
  12 
  13 tar cvf - `find . -mtime -1 -type f -print` > $archive.tar
  14 gzip $archive.tar
  15 echo "Directory $PWD backed up in archive file \"$archive.tar.gz\"."
  16 
  17 
  18 #  Stephane Chazelas指出：如果有许多文件被找到
  19 #+ 或任何一个文件名中包含有空白字符
  20 #+ 上面的代码将会失败.
  21 
  22 # 他建议用下面的代码:
  23 # -------------------------------------------------------------------
  24 #   find . -mtime -1 -type f -print0 | xargs -0 tar rvf "$archive.tar"
  25 #      using the GNU version of "find".
  26 
  27 
  28 #   find . -mtime -1 -type f -exec tar rvf "$archive.tar" '{}' \;
  29 #         portable to other UNIX flavors, but much slower.
  30 # -------------------------------------------------------------------
  31 
  32 
  33 exit 0
  
  以"-"字符开头为文件名的文件当加上"-"的定向操作符时可能会引起问题.脚本应该检查这种情况并且给这种文件增加合适的路径前缀,例如 ./-FILENAME, $PWD/-FILENAME, 或$PATHNAME/-FILENAME.

如果一个变量的值以-开头，同样也可能会产生问题.
   1 var="-n"
   2 echo $var		
   3 # 和"echo -n"一样,什么也不会输出.
   
   先前的工作目录. 命令cd - 可以回到原来的工作目录.它使用了$OLDPWD 环境变量.
   
   主目录或称为家目录[波浪号]. 它与内部变量 $HOME 是一致的. ~bozo是bozo'的主目录,而ls ~bozo 会列出此目录的内容. ~/ 是当前用户的主目录,并且ls ~/ 会列出此目录的内容.
 bash$ echo ~bozo
 /home/bozo
 
 bash$ echo ~
 /home/bozo
 
 bash$ echo ~/
 /home/bozo/
 
 bash$ echo ~:
 /home/bozo:
 
 bash$ echo ~nonexistent-user
 ~nonexistent-user
 	      
~+
当前工作目录. 它与外部变量$PWD是一致的.

~-
先前的工作目录. 它与外部变量$OLDPWD是一致的.

Ctl-B

退格 (非破坏性的).

Ctl-C

中断. 终结一个前台作业.


Ctl-D

从一个shell中退出 (类似于exit).

"EOF" (文件结尾：end of file).它也用于表示标准输入（stdin）的结束.

在控制台或xterm 窗口输入文本时, Ctl-D删除在光标下的字符.如果没有字符存在，Ctl-D 则会登录出该会话. 在一个xterm窗口中，则会产生关闭此窗口的效果。

Ctl-G

"哔" (beep).在一些老式的打字机终端上，它会响一下铃.

Ctl-H

"杀掉" (破坏性的退格). 删除光标前的一个字符＝＝＝.

   1 #!/bin/bash
   2 # 在一个字符串里嵌入 Ctl-H.
   3 
   4 a="^H^H"                  # 两个 Ctl-H (退格).
   5 echo "abcdef"             # abcdef
   6 echo -n "abcdef$a "       # abcd f
   7 #以一个空格结尾  ^              ^ 退二格.
   8 echo -n "abcdef$a"        # abcdef
   9 #  现在没有尾部的空格            不退格了 (为什么?).
  10                           # 结果和预料的不一样.
  11 echo; echo

Ctl-I

水平制表符.

Ctl-J

新行(换一行并到行首).

Ctl-K

垂直制表符.

在控制台或xterm 窗口输入文本时, Ctl-K 会删除从光标所在处到行尾的所有字符。


Ctl-L

清屏 (重绘屏幕，清除前面的打印信息).这与clear命令作用相同.

Ctl-M

回车.

   1 #!/bin/bash
   2 # 多谢Lee Maschmeyer的例子.
   3 
   4 read -n 1 -s -p $'Control-M leaves cursor at beginning of this line. Press Enter. \x0d'
   5                                   # 是的, '0d'是Control-M的十六进制值.
   6 echo >&2   #  '-s'使所有被键入的字符都不回显,
   7            #+ 所以需要明确地键入新行.
   8 
   9 read -n 1 -s -p $'Control-J leaves cursor on next line. \x0a'
  10 echo >&2   #  Control-J 是换行.
  11 
  12 ###
  13 
  14 read -n 1 -s -p $'And Control-K\x0bgoes straight down.'
  15 echo >&2   #  Control-K 是垂直制表符.
  16 
  17 # 展示垂直制表符作用的更好的例子是:
  18 
  19 var=$'\x0aThis is the bottom line\x0bThis is the top line\x0a'
  20 echo "$var"
  21 #  这和上面的例子一样工作.但是:
  22 echo "$var" | col
  23 #  这使行的右端比左端更高.
  24 #  这也解释了为什么我们以一个换行符开始和结束 --
  25 #+ 是为了避免屏幕显示混乱.
  26 
  27 # 这是Lee Maschmeyer的解释:
  28 # --------------------------
  29 #  在第一个垂直制表符例子中 . . . 垂直制表符使还未打印回车就直接垂直打印下来。
  30 #
  31 #  这只在不能“倒后”的设备里才成立,比如在Linux控制台,
  32 #
  33 #  垂直制表符真正的意图是能垂直地往上移，而不是往下移.
  34 #  可以在打印机里用于打印上标.
  35 #  这个要点的作用被用于仿效垂直制表符正确的功能.
  36 
  37 exit 0

Ctl-Q

解冻 (XON).

它解冻终端的标准输入.

Ctl-S

挂起输入 (XOFF).

它冻结终端的标准输入. (用 Ctl-Q 可恢复输入.)

Ctl-U

删除从光标到行首的一行输入.在某些设置里，Ctl-U 删除整行的输入，而不管光标的位置.

Ctl-V

当输入一个文本, Ctl-V允许插入控制字符。例如，下面两个命令是相等的:
   1 echo -e '\x0a'
   2 echo <Ctl-V><Ctl-J>

Ctl-V 主要用于文本编辑.

Ctl-W

当在控制台或一个xterm窗口敲入文本时, Ctl-W 会删除从在光标处往后的第一个空白符之间的内容.在某些设置里, Ctl-W 删除光标往后到第一个非文字和数字之间的字符.

Ctl-Z

暂停一个前台作业.

用做函数的分隔符,分隔命令或变量. 空白是由空格(spaces),制表(tabs),空行(blank lines),或是由上述的组合造成的. [3] 在一些上下文中,比如说变量赋值, 空白是不被允许的，它会导致语法错误.

空行不会影响脚本的行为，因此使用它可以很好的划分独立的函数段以增加可读性。

特殊变量$IFS用来分隔一些输入命令的分隔符，默认是空白符。

为了在字符串或在变量中产生空白，应该使用引用.

例外: 作用管道一部分的花括号代码块可以在子shell中运行.
   1 ls | { read firstline; read secondline; }
   2 #  错误.在花括号内的代码块在一个子shell里运行,
   3 #+ 以致"ls"的输出不能把值传到代码块里.
   4 echo "First line is $firstline; second line is $secondline"  # 这不会工作.
   5 
   6 # 多谢, S.C.

[3]	
一个换行("新行")也是一个空白字符。这就解释了为什么一个只包含一个换行符的空白行也被认为是空白了。

在一个双引号（" "）里的变量引用不会禁止变量替换。所以双引号被称为部分引用，有时也称为"弱引用"。而在一个单引号里(' ')的变量替换是被禁止的，变量名只被解释为普通的字面意思。所以单引号被称为"全局引用"，有时也被称为强引用。

注意$variable实际上只是${variable}的简单的简写形式。在某些场合使用$variable形式会引起错误，这时你可能需要使用${variable}的形式了。

例子 4-1. 变量赋值与替换

   1 #!/bin/bash
   2 
   3 # Variables: 赋值和替换
   4 
   5 a=375
   6 hello=$a
   7 
   8 #-------------------------------------------------------------------------
   9 # =号的左右两边都不能有空白符.
  10 # 如果有一个空白符会怎么样？
  11 
  12 #  如果用 "VARIABLE =value",
  13 #              ^
  14 #+ 脚本会以为"VARIABLE"是一个命令并且此命令带了一个参数"=value"。
  15 
  16 #  如果用 "VARIABLE= value",
  17 #               　　^
  18 #+ 脚本会以为"value"是一个命令，
  19 #+ 并且把环境变量"VARIABLE"赋为空值：""。
  20 #-------------------------------------------------------------------------
  21 
  22 
  23 echo hello    # 没有引用变量，只是输出字符串 "hello".
  24 
  25 echo $hello
  26 echo ${hello} # 这句和上面的一句一样
  27 
  28 echo "$hello"
  29 echo "${hello}"
  30 
  31 echo
  32 
  33 hello="A B  C   D"
  34 echo $hello   # A B C D
  35 echo "$hello" # A B  C   D
  36 # 正如你所看到的：echo $hello和echo "$hello"产生不同的输出。
  37 #                                 　^      ^
  38 # 把变量引起来会保留空白字符.
  39 
  40 echo
  41 
  42 echo '$hello'  # $hello
  43 #    ^      ^
  44 #  在单引号中的变量引用会被禁止,
  45 #+ 字符"$"会仅仅被认为是一个普通的字符，而不是变量的前缀.
  46 
  47 # 注意不同引用的不同效果.
  48 
  49 
  50 hello=    # Setting it to a null value.
  51 echo "\$hello (null value) = $hello"
  52 #  注意具有null值的变量不等同于废弃(unset)此变量
  53 #+ 虽然最后的结果都是一样的（看下面的）.
  54 
  55 # --------------------------------------------------------------
  56 
  57 #  在同一行里用空白字符隔开为多个变量赋值是可以的。
  58 #
  59 #  警告：这可能减少可读性，并且可能是不可移植的。
  60 
  61 var1=21  var2=22  var3=$V3
  62 echo
  63 echo "var1=$var1   var2=$var2   var3=$var3"
  64 
  65 # 在老版本的sh中这可能会引起问题
  66 
  67 # --------------------------------------------------------------
  68 
  69 echo; echo
  70 
  71 numbers="one two three"
  72 #           ^   ^
  73 other_numbers="1 2 3"
  74 #               ^ ^
  75 #  如果给变量赋的值中有空白字符，引号是必须的。
  76 #
  77 echo "numbers = $numbers"
  78 echo "other_numbers = $other_numbers"   # other_numbers = 1 2 3
  79 echo
  80 
  81 echo "uninitialized_variable = $uninitialized_variable"
  82 # 未初始化的变量具有null值 (即是没有值).
  83 uninitialized_variable=   #  声明，但没有初始化它 --
  84                           #+ 这就好像上面一样给它设置一个null 值
  85 echo "uninitialized_variable = $uninitialized_variable"
  86                           # 它仍然是null值.
  87 
  88 uninitialized_variable=23       # 赋值
  89 unset uninitialized_variable    # 销毁变量.
  90 echo "uninitialized_variable = $uninitialized_variable"
  91                                 # 结果仍然是null值.
  92 echo
  93 
  94 exit 0
  
  一个未初始化的变量有一个”null”值――表示从没有被赋值过（注意null值不等于零）。在一个变量从未赋值之前就使用它通常会引起问题。

然而，仍然有可能在执行算术计算时使用一个未初始化的变量。
   1 echo "$uninitialized"                                # (blank line)
   2 let "uninitialized += 5"                             # Add 5 to it.
   3 echo "$uninitialized"                                # 5
   4 
   5 #  结论:
   6 #  一个未初始化的变量没有值，
   7 #+ 但是似乎它在算术计算中的值是零。
   8 #  这个无法证实（也可能是不可移植）的行为。
   
   例子 4-2. 简单的变量赋值

   1 #!/bin/bash
   2 # 裸变量
   3 
   4 echo
   5 
   6 # 什么时候变量是“裸”的？比如说，变量名前面没有$？
   7 #当变量被赋值而不是引用时，我们称它为是裸变量。
   8 
   9 # 赋值
  10 a=879
  11 echo "The value of \"a\" is $a."
  12 
  13 # 用命令'let'赋值。
  14 let a=16+5
  15 echo "The value of \"a\" is now $a."
  16 
  17 echo
  18 
  19 # 在一个for循环里赋值（其实，这是一种伪赋值）:
  20 echo -n "Values of \"a\" in the loop are: "
  21 for a in 7 8 9 11
  22 do
  23   echo -n "$a "
  24 done
  25 
  26 echo
  27 echo
  28 
  29 # 用'read'命令 (这也是一种赋值):
  30 echo -n "Enter \"a\" "
  31 read a
  32 echo "The value of \"a\" is now $a."
  33 
  34 echo
  35 
  36 exit 0
  
  例子 4-3. 简单且奇特的变量赋值

   1 #!/bin/bash
   2 
   3 a=23              # 简单的情况
   4 echo $a
   5 b=$a
   6 echo $b
   7 
   8 # 现在，来一点奇怪的赋值（命令替换）
   9 
  10 a=`echo Hello!`   # 把'echo'命令的结果赋值给变量'a'
  11 echo $a
  12 #  注意在一个#+的命令替换结构中包含一个感叹号(!)，
  13 #+ 将不会工作。
  14 #+ 因为感叹号触发了Bash"历史命令机制"
  15 #  不过，在脚本里，历史命令机制是被禁用的.
  16 
  17 a=`ls -l`         # 把'ls -l'命令的结果赋给变量'a'
  18 echo $a           # 如果没有引号，则会删除多余tab键和空白符
  19 echo
  20 echo "$a"         # 加了双引号，则能够原样保留空白符
  21                   # (参考"引用"章节)
  22 
  23 exit 0
变量赋值也可以使用$(...) 机制(它是比斜引号更新的方法). 它实际是命令替换的一种形式.
   1 # 摘自/etc/rc.d/rc.local
   2 R=$(cat /etc/redhat-release)
   3 arch=$(uname -m)
   例子 4-4. 整数还是字符串?

   1 #!/bin/bash
   2 # int-or-string.sh: Integer or string?
   3 
   4 a=2334                   # 整数.
   5 let "a += 1"
   6 echo "a = $a "           # a = 2335
   7 echo                     # 仍然是整数.
   8 
   9 
  10 b=${a/23/BB}             # 把变量a中的"23"替换为"BB"并赋给变量b
  11                          # 这使变量$b成为字符串
  12 echo "b = $b"            # b = BB35
  13 declare -i b             # 即使明确地声明它是整数也没有用
  14 echo "b = $b"            # b = BB35
  15 
  16 let "b += 1"             # BB35 + 1 =
  17 echo "b = $b"            # b = 1
  18 echo
  19 
  20 c=BB34
  21 echo "c = $c"            # c = BB34
  22 d=${c/BB/23}             # 把"BB"替换成"23"
  23                          # 这使变量$d成为一个整数
  24 echo "d = $d"            # d = 2334
  25 let "d += 1"             # 2334 + 1 =
  26 echo "d = $d"            # d = 2335
  27 echo
  28 
  29 # What about null variables?
  30 e=""
  31 echo "e = $e"            # e =
  32 let "e += 1"             # 数值计算允许有null值操作?
  33 echo "e = $e"            # e = 1
  34 echo                     # 空值(null)变量变成了整数
  35 
  36 # 如果没有声明变量会怎么样?
  37 echo "f = $f"            # f =
  38 let "f += 1"             # 算术计算能通过吗?
  39 echo "f = $f"            # f = 1
  40 echo                     # 没有预先声明的变量变为整数
  41 
  42 
  43 
  44 # 在Bash中的变量确实是无类型的.
  45 
  46 exit 0
  
  位置参数
命令行传递给脚本的参数是: $0, $1, $2, $3 . . .

$0是脚本的名字，$1是第一个参数，$2是第二个参数，$3是第三个，以此类推。[1] After $9, 在位置参数$9之后的参数必须用括号括起来，例如：${10}, ${11}, ${12}.

特殊变量$*和$@ 表示所有的位置参数。

例子 4-5. 位置参数

   1 #!/bin/bash
   2 
   3 # 至少以10个参数运行这个脚本，例如：
   4 # ./scriptname 1 2 3 4 5 6 7 8 9 10
   5 MINPARAMS=10
   6 
   7 echo
   8 
   9 echo "The name of this script is \"$0\"."
  10 # 用./表示当前目录
  11 echo "The name of this script is \"`basename $0`\"."
  12 # 去掉路径名（查看'basename'命令）
  13 
  14 echo
  15 
  16 if [ -n "$1" ]              # 被测试的变量被双引号引起
  17 then
  18  echo "Parameter #1 is $1"  # 使用引号来使#被转义
  19 fi 
  20 
  21 if [ -n "$2" ]
  22 then
  23  echo "Parameter #2 is $2"
  24 fi 
  25 
  26 if [ -n "$3" ]
  27 then
  28  echo "Parameter #3 is $3"
  29 fi 
  30 
  31 # ...
  32 
  33 
  34 if [ -n "${10}" ]  # 大于 $9的参数必须用花括号括起来.
  35 then
  36  echo "Parameter #10 is ${10}"
  37 fi 
  38 
  39 echo "-----------------------------------"
  40 echo "All the command-line parameters are: "$*""
  41 
  42 if [ $# -lt "$MINPARAMS" ]
  43 then
  44   echo
  45   echo "This script needs at least $MINPARAMS command-line arguments!"
  46 fi  
  47 
  48 echo
  49 
  50 exit 0
  
  由不同的执行名字来调用脚本，一些脚本能够以不同的操作来执行。如果要能办到这一点，脚本需要检查变量$0来确定脚本是如何被调用的。也有可能存在符号链接的路径来调用脚本的情况。
  
  例子 4-7. 使用shift

   1 #!/bin/bash
   2 # 用 'shift'命令逐步存取所有的位置参数
   3 
   4 #  给这个脚本一个命名，比如说shft，
   5 #+ 然后以一些参数来调用这个脚本,例如
   6 #          ./shft a b c def 23 skidoo
   7 
   8 until [ -z "$1" ]  # 直到所有的位置参数被存取完...
   9 do
  10   echo -n "$1 "
  11   shift
  12 done
  13 
  14 echo               # 换行.
  15 
  16 exit 0
  
  引用意味着保护在引号中的字符串. 引用在保护被引起字符串中的特殊字符被shell或shell脚本解释或扩展. (如果一个字符能被特殊解释为不同于它字面上表示的意思，那么这个字符是“特殊”的,比如说通配符 -- *.)
  
  bash$ ls -l [Vv]*
 -rw-rw-r--    1 bozo  bozo       324 Apr  2 15:05 VIEWDATA.BAT
 -rw-rw-r--    1 bozo  bozo       507 May  4 14:25 vartrace.sh
 -rw-rw-r--    1 bozo  bozo       539 Apr 14 17:11 viewdata.sh
 
 bash$ ls -l '[Vv]*'
 ls: [Vv]*: No such file or directory
 
 引号也能改掉echo's不换行的“习惯”。

 bash$ echo $(ls -l)
 total 8 -rw-rw-r-- 1 bozo bozo 130 Aug 21 12:57 t222.sh -rw-rw-r-- 1 bozo bozo 78 Aug 21 12:57 t71.sh
 
 
 bash$ echo "$(ls -l)"
 total 8
 -rw-rw-r--  1 bozo bozo 130 Aug 21 12:57 t222.sh
 -rw-rw-r--  1 bozo bozo  78 Aug 21 12:57 t71.sh
 当要引用一个变量的值时，一般推荐使用双引号。使用双引号除了变量名[2]前缀($)、后引符(`)和转义符(\)外，会使shell不再解释引号中其它所有的特殊字符。[3] 用双引号时$仍被当成特殊字符，允许引用一个被双引号引起的变量("$variable"), 那也是说$variable会被它的值所代替。
 用双引号还能使句子不被分割开. [4] 一个参数用双引号引起来能使它被看做一个单元，这样即使参数里面包含有空白字符也不会被shell分割开了。
   1 variable1="a variable containing five words"
   2 COMMAND This is $variable1    # 用下面7个参数执行COMMAND命令:
   3 # "This" "is" "a" "variable" "containing" "five" "words"
   4 
   5 COMMAND "This is $variable1"  # 用下面1个参数执行COMMAND命令:
   6 # "This is a variable containing five words"
   7 
   8 
   9 variable2=""    # 空字符串。
  10 
  11 COMMAND $variable2 $variable2 $variable2        # 没有带参数执行COMMAND 命令
  12 COMMAND "$variable2" "$variable2" "$variable2"  # 用三个含空字符串的参数执行COMMAND命令
  13 COMMAND "$variable2 $variable2 $variable2"      # 用一个包含两个空白符的参数执行COMMAND命令
  14 
  15 # Thanks, St閜hane Chazelas.

	
在echo语句中，只有句子分割和保存空白符的时候，才需要把参数用双引号引起来。

例子 5-1. 引号引起奇怪的变量

   1 #!/bin/bash
   2 # weirdvars.sh: Echoing weird variables.
   3 
   4 var="'(]\\{}\$\""
   5 echo $var        # '(]\{}$"
   6 echo "$var"      # '(]\{}$"     和上面一句没什么不同.
   7 
   8 echo
   9 
  10 IFS='\'
  11 echo $var        # '(] {}$"     \字符被空白符替换了，为什么?
  12 echo "$var"      # '(]\{}$"
  13 
  14 # 以上例子由Stephane Chazelas提供..
  15 
  16 exit 0
  
  单引号（' '）和双引号类似，但它不允许解释变量引用，因此，在单引号内的字符$的特殊意思无效了。在单引号内，除了字符'，每个特殊字符都只是字面的意思。单引号（全局引用）比双引号（部分引用）更严格的处理引用部分。

	
由于在单引号里的转义字符（\）也只是被局限于字面上的意思，所以想在一双单引号里再加单引号是不行的。
   1 echo "Why can't I write 's between single quotes"
   2 
   3 echo
   4 
   5 # The roundabout method.
   6 echo 'Why can'\''t I write '"'"'s between single quotes'
   7 #    |-------|  |----------|   |-----------------------|
   8 # 三个单引号引起的字符串之间有一个转义的单引号和一个由双引号引起的单引号.
   9 
  10 # 这个例子得到 St閜hane Chazelas同意.
  
  在命令行上，把感叹号"!"放在双引号里执行命令会出错（译者注：比如说：echo "hello!"）. 因为感叹号被解释成了一个历史命令. 然而在一个脚本文件里，这么写则是正确的，因为在脚本文件里Bash的历史机制被禁用了。

在双号号里在字符"\"也会引起许多不一致的行为。
 bash$ echo hello\!
 hello!
 
 
 bash$ echo "hello\!"
 hello\!
 
 
 
 
 bash$ echo -e x\ty
 xty
 
 
 bash$ echo -e "x\ty"
 x       y
 	      
 	      
例子 5-2. 转义字符

   1 #!/bin/bash
   2 # escaped.sh: 转义字符
   3 
   4 echo; echo
   5 
   6 echo "\v\v\v\v"      # 打印出 \v\v\v\v literally.
   7 # 用带着选项-e的'echo'会打印出转义字符串.
   8 echo "============="
   9 echo "VERTICAL TABS"
  10 echo -e "\v\v\v\v"   # 打印四个垂直的制表符.
  11 echo "=============="
  12 
  13 echo "QUOTATION MARK"
  14 echo -e "\042"       # 打印出字符" (引号, 它的八进制ASCII码为42).
  15 echo "=============="
  16 
  17 # 当使用像$'\X'的结构时，-e选项是多余的.
  18 echo; echo "NEWLINE AND BEEP"
  19 echo $'\n'           # 新行.
  20 echo $'\a'           # 警告 (蜂鸣).
  21 
  22 echo "==============="
  23 echo "QUOTATION MARKS"
  24 # 版本2开始Bash已经允许使用$'\nnn'结构了.
  25 # 注意在这里,'\nnn'表示一个八进制的值.
  26 echo $'\t \042 \t'   # Quote (") framed by tabs.
  27 
  28 # 使用$'\xhhh'结构也可以使用十六进制数来转义.
  29 echo $'\t \x22 \t'  # Quote (") framed by tabs.
  30 # 多谢Greg Keraunen指出这个..
  31 # 早期的Bash版本允许用'\x022'.（译者注，现在不行了）
  32 echo "==============="
  33 echo
  34 
  35 
  36 # 用ASCII码值把字符赋给变量.
  37 # ----------------------------------------
  38 quote=$'\042'        # 引号"被赋给变量quote了.
  39 echo "$quote This is a quoted string, $quote and this lies outside the quotes."
  40 
  41 echo
  42 
  43 # 用连串的ASCII码把一串字符赋给变量..
  44 triple_underline=$'\137\137\137'  # 137是字符'_'的ASCII码.
  45 echo "$triple_underline UNDERLINE $triple_underline"
  46 
  47 echo
  48 
  49 ABC=$'\101\102\103\010'           # 101, 102, 103分别是A, B, C字符的八进制ASCII码.
  50 echo $ABC
  51 
  52 echo; echo
  53 
  54 escape=$'\033'                    # 033是ESC的ASCII码的八进制值
  55 echo "\"escape\" echoes as $escape"
  56 #                                   不可见的输出.
  57 
  58 echo; echo
  59 
  60 exit 0
  
  反斜杠的作用要看它是否是自我转义，被引用，或出现在命令替换结构或是在here document里.
   1                       #  简单的转义和引用
   2 echo \z               #  z
   3 echo \\z              # \z
   4 echo '\z'             # \z
   5 echo '\\z'            # \\z
   6 echo "\z"             # \z
   7 echo "\\z"            # \z
   8 
   9                       #  命令替换
  10 echo `echo \z`        #  z
  11 echo `echo \\z`       #  z
  12 echo `echo \\\z`      # \z
  13 echo `echo \\\\z`     # \z
  14 echo `echo \\\\\\z`   # \z
  15 echo `echo \\\\\\\z`  # \\z
  16 echo `echo "\z"`      # \z
  17 echo `echo "\\z"`     # \z
  18 
  19                       # Here document
  20 cat <<EOF              
  21 \z                      
  22 EOF                   # \z
  23 
  24 cat <<EOF              
  25 \\z                     
  26 EOF                   # \z
  27 
  28 # 这些例子由Stéphane Chazelas提供..
  
  一个字符串赋给变量时里面的组成部分可能会被转义，但如果单独一个转义字符（\）是不能赋给变量的。
   1 variable=\
   2 echo "$variable"
   3 # 不能工作 - 给出一个错误信息:
   4 # test.sh: : command not found
   5 # 单独一个转义字符是不能正确地赋给变量的.
   6 #
   7 #  那上面语句究竟发生了什么呢？实际上转义符"\"转义了新行符，
   8 #+ 产生的作用如同       variable=echo "$variable"
   9 #+                      而这是无效的变量赋值
  10 
  11 variable=\
  12 23skidoo
  13 echo "$variable"        #  23skidoo
  14                         #  这样就能工作,因为第二行的变量赋值是有效的
  15                         #
  16 
  17 variable=\ 
  18 #        \^    转义后面的空格（译者注：粗心的读者一定要注意上面最后的空格）
  19 echo "$variable"        # 空格
  20 
  21 variable=\\
  22 echo "$variable"        # \
  23 
  24 variable=\\\
  25 echo "$variable"
  26 # 不能工作 - 产生一个错误:
  27 # test.sh: \: command not found
  28 #
  29 #  第一个\转义第二个\,结果只剩单独的第三个\字符,
  30 #+ 这样又会发生上面的情况.
  31 
  32 variable=\\\\
  33 echo "$variable"        # \\
  34                         # 第二和第四个\字符被转义.
  35                         # 这样不会出错了.
  
  转义一个空格可以防止一个字符串参数被分割成多个命令行参数。
   1 file_list="/bin/cat /bin/gzip /bin/more /usr/bin/less /usr/bin/emacs-20.7"
   2 # 文件列表作为参数传递给命令.
   3 
   4 # 再加两个参数给命令ls，一同列出文件信息.
   5 ls -l /usr/X11R6/bin/xsetroot /sbin/dump $file_list
   6 
   7 echo "-------------------------------------------------------------------------"
   8 
   9 # 如果我们转义上面的一对空格会发生什么?
  10 ls -l /usr/X11R6/bin/xsetroot\ /sbin/dump\ $file_list
  11 # 出错: 开头的三个文件名被连成一个文件名并传递给了命令'ls -l'
  12 #        因为两个转义字符禁止了空格分割参数的作用。

转义符也提供了写一个多行命令的手段。一般地，每个单独的行有一个不同的命令，而在一行末尾的转义符转义新行符，命令序列则由下一行继续。

   1 (cd /source/directory && tar cf - . ) | \
   2 (cd /dest/directory && tar xpvf -)
   3 # 把Alan Cox目录树全部复制到另外一个目录里,
   4 # 但分为两行可以增加可读性.
   5 
   6 # 你也可以用下面的命令达到一样的效果:
   7 tar cf - -C /source/directory . |
   8 tar xpvf - -C /dest/directory
   9 # 看看下面的注释.
  10 # (多谢，Stéphane Chazelas.)
  
  如果一个脚本行用一个管道线"|"结束行尾，后面可以再跟一个不必一定要的转义符"\"。然而，好的编程习惯最好加上一个转义符“\”。

   1 echo "foo
   2 bar" 
   3 #foo
   4 #bar
   5 
   6 echo
   7 
   8 echo 'foo
   9 bar'    # 没什么不同.
  10 #foo
  11 #bar
  12 
  13 echo
  14 
  15 echo foo\
  16 bar     # 新行符被转义.
  17 #foobar
  18 
  19 echo
  20 
  21 echo "foo\
  22 bar"     # 还是一样,字符\在弱引用中还是被解释为转义字符
  23 #foobar
  24 
  25 echo
  26 
  27 echo 'foo\
  28 bar'     # 由于转义符"\"在强引用符里，所以只能解释为字面上的意思
  29 #foo\
  30 #bar
  31 
  32 # 由Stéphane Chazelas提示写成的例子.
  
  除了一些例外的情况，一个行为端庄的UNIX命令，程序或是软件包执行成功能返回0的作为退出码。

同样的，在脚本里的函数和脚本自身都会返回一个退出状态码。在脚本或函数里被执行的最后一个命令将决定退出状态码。在一个脚本里，exit nnn 命令将会返回shell一个nnn的退出状态码。（nnn必须是一个在0-255范围的十进制整数）。

脚本结束没有exit,不带参数的exit和exit $?三者是等价的。

   1 #!/bin/bash
   2 
   3 COMMAND_1
   4 
   5 . . .
   6 
   7 # 会以最后命令的退出码退出脚本.
   8 COMMAND_LAST
   9 
  10 exit $?

   1 #!/bin/bash
   2 
   3 COMMAND1
   4 
   5 . . . 
   6 
   7 # 会以最后命令的退出码退出脚本.
   8 COMMAND_LAST


$?变量保存了最后一个命令执行后的退出状态。当一个函数返回时，$?保存了函数里最后一个命令的退出状态码。这就是Bash里函数返回值的处理办法。当一个脚本运行结束，$? 变量保存脚本的退出状态，而脚本的退出状态则是脚本中最后一个已执行命令的退出状态。并且依照惯例，0表示执行成功，1-255的整数范围表示错误。

逻辑非操作符!反转一个命令或一个测试的结果，它也能反转退出状态.

例子 6-2. 逻辑非一个条件结果的用法

   1 true  # ture命令是内建的.
   2 echo "exit status of \"true\" = $?"     # 0
   3 
   4 ! true
   5 echo "exit status of \"! true\" = $?"   # 1
   6 # 注意逻辑非字符"!"需要一个空格.
   7 #    !true   会导致一个"command not found"（命令没有发现）的错误。
   8 #
   9 # 操作符'!'放在一个命令前面会导致调用Bash的历史机制。
  10 
  11 true
  12 !true
  13 # 这次没有错误，也没有反转结果.
  14 # 它只是重复执行上次的命令(true).
  15 
  16 # 多谢, Stéphane Chazelas and Kristopher Newsome.
  
  if 命令不仅能测试由方括号括起来的条件，也能测试任何命令。
   1 if cmp a b &> /dev/null  # 禁止输出.
   2 then echo "Files a and b are identical."
   3 else echo "Files a and b differ."
   4 fi
   5 
   6 # 非常有用的"if-grep"组合:
   7 # ----------------------------------- 
   8 if grep -q Bash file
   9 then echo "File contains at least one occurrence of Bash."
  10 fi
  11 
  12 word=Linux
  13 letter_sequence=inu
  14 if echo "$word" | grep -q "$letter_sequence"
  15 # 选项"-q"使grep禁止输出.
  16 then
  17   echo "$letter_sequence found in $word"
  18 else
  19   echo "$letter_sequence not found in $word"
  20 fi
  21 
  22 
  23 if COMMAND_WHOSE_EXIT_STATUS_IS_0_UNLESS_ERROR_OCCURRED
  24 then echo "Command succeeded."
  25 else echo "Command failed."
  26 fi

一个if/then结构能包含嵌套的比较和测试。
   1 if echo "Next *if* is part of the comparison for the first *if*."
   2 
   3   if [[ $comparison = "integer" ]]
   4     then (( a < b ))
   5   else
   6     [[ $a < $b ]]
   7   fi
   8 
   9 then
  10   echo '$a is less than $b'
  11 fi
  
  例子 7-1. 事实是什么？

   1 #!/bin/bash
   2 
   3 #  小技巧:
   4 #  如果你不确定某一条件怎么被求值,
   5 #+ 可以用一个if-test结构来测试.
   6 
   7 echo
   8 
   9 echo "Testing \"0\""
  10 if [ 0 ]      # 0
  11 then
  12   echo "0 is true."
  13 else
  14   echo "0 is false."
  15 fi            # 0为真.
  16 
  17 echo
  18 
  19 echo "Testing \"1\""
  20 if [ 1 ]      # 1
  21 then
  22   echo "1 is true."
  23 else
  24   echo "1 is false."
  25 fi            # 1为真.
  26 
  27 echo
  28 
  29 echo "Testing \"-1\""
  30 if [ -1 ]     # -1
  31 then
  32   echo "-1 is true."
  33 else
  34   echo "-1 is false."
  35 fi            # -1为真.
  36 
  37 echo
  38 
  39 echo "Testing \"NULL\""
  40 if [ ]        # NULL (空条件)
  41 then
  42   echo "NULL is true."
  43 else
  44   echo "NULL is false."
  45 fi            # NULL为假.
  46 
  47 echo
  48 
  49 echo "Testing \"xyz\""
  50 if [ xyz ]    # 字符串
  51 then
  52   echo "Random string is true."
  53 else
  54   echo "Random string is false."
  55 fi            # 任意字符串为true.
  56 
  57 echo
  58 
  59 echo "Testing \"\$xyz\""
  60 if [ $xyz ]   # 变量$xyz为null值, 但...
  61               # 它只是一个未初始化的变量.
  62 then
  63   echo "Uninitialized variable is true."
  64 else
  65   echo "Uninitialized variable is false."
  66 fi            # 未初始化的变量为false.
  67 
  68 echo
  69 
  70 echo "Testing \"-n \$xyz\""
  71 if [ -n "$xyz" ]            # 进一步实验核实.
  72 then
  73   echo "Uninitialized variable is true."
  74 else
  75   echo "Uninitialized variable is false."
  76 fi            # 未始初化的变量为false.
  77 
  78 echo
  79 
  80 
  81 xyz=          # 已初始化, 但设置成null值.
  82 
  83 echo "Testing \"-n \$xyz\""
  84 if [ -n "$xyz" ]
  85 then
  86   echo "Null variable is true."
  87 else
  88   echo "Null variable is false."
  89 fi            # Null值变量为假.
  90 
  91 
  92 echo
  93 
  94 
  95 # 什么时候"false"为真?
  96 
  97 echo "Testing \"false\""
  98 if [ "false" ]              #  "false"是一个字符串.
  99 then
 100   echo "\"false\" is true." #+ 它被测试为真.
 101 else
 102   echo "\"false\" is false."
 103 fi            # "false"为真.
 104 
 105 echo
 106 
 107 echo "Testing \"\$false\""  # 再来，未初始化的变量.
 108 if [ "$false" ]
 109 then
 110   echo "\"\$false\" is true."
 111 else
 112   echo "\"\$false\" is false."
 113 fi            # "$false"变量为假.
 114               # 现在, 我们取得了预期的效果.
 115 
 116 #  如果我们测试未初始化的变量"$true"会发生什么?
 117 
 118 echo
 119 
 120 exit 0
练习. 上面例子 7-1的解释.

   1 if [ condition-true ]
   2 then
   3    command 1
   4    command 2
   5    ...
   6 else
   7    # 或选的(如果不需要就可去掉).
   8    # 如果条件测试失败，就在这里加入默认的执行命令.
   9    command 3
  10    command 4
  11    ...
  12 fi
	
当if和then在同一行的时候，一个分号（;）必须用在if语句的结尾。if和then都是关键字.关键字（或命令）开始一个语句，如果在同一行开始另一个新语句时，前面一个语句必须用分号（;）结束。

   1 if [ -x "$filename" ]; then
   
   elif是else if的缩写。作用是在一个if/then里嵌入一个内部的if/then结构。

   1 if [ condition1 ]
   2 then
   3    command1
   4    command2
   5    command3
   6 elif [ condition2 ]
   7 # 和else if相同
   8 then
   9    command4
  10    command5
  11 else
  12    default-command
  13 fi

if test condition-true结构是精确等同于if [ condition-true ].如果用[ condition-true ]结构，左方括[ , 是一个调用test命令的标识。右方括]在一个if/test中封闭左方括[，但它不是必须的，不过新一些的Bash版本会要求有。

	
Bash内建的test命令测试文件类型和比较字符串. 因此，在一个Bash脚本中test语句不必调用外部的/usr/bin/test的二进制文件，这个test程序是sh-utils包的一部分。同样的，[也不调用/usr/bin/[，/usr/bin/[是链接到/usr/bin/test一个符号链接。

 bash$ type test
 test is a shell builtin
 bash$ type '['
 [ is a shell builtin
 bash$ type '[['
 [[ is a shell keyword
 bash$ type ']]'
 ]] is a shell keyword
 bash$ type ']'
 bash: type: ]: not found
 
 例子 7-2. 等价的测试命令：test,/usr/bin/test,[]和/usr/bin/[

   1 #!/bin/bash
   2 
   3 echo
   4 
   5 if test -z "$1"
   6 then
   7   echo "No command-line arguments."
   8 else
   9   echo "First command-line argument is $1."
  10 fi
  11 
  12 echo
  13 
  14 if /usr/bin/test -z "$1"      # 和内建的"test"命令一样.
  15 then
  16   echo "No command-line arguments."
  17 else
  18   echo "First command-line argument is $1."
  19 fi
  20 
  21 echo
  22 
  23 if [ -z "$1" ]                # 和上面代码块的功能一样
  24 #   if [ -z "$1"                应该来说会运行, 但是...
  25 #+  Bash给出错误说少了一个封闭的右方括.
  26 then
  27   echo "No command-line arguments."
  28 else
  29   echo "First command-line argument is $1."
  30 fi
  31 
  32 echo
  33 
  34 
  35 if /usr/bin/[ -z "$1" ]       # 同样和上面的代码块一样.
  36 # if /usr/bin/[ -z "$1"       # 工作, 但还是给出一个错误信息.
  37 #                             # 注意:
  38 #                               这个已经在bash 3.x版本被修补好了。
  39 then
  40   echo "No command-line arguments."
  41 else
  42   echo "First command-line argument is $1."
  43 fi
  44 
  45 echo
  46 
  47 exit 0
[[]]结构比Bash版本的[]更通用。它是从ksh88中引进的test命令的扩展。

在[[和]]之间的所有的字符都不会被文件扩展或是标记分割，但是会有参数引用和命令替换。

   1 file=/etc/passwd
   2 
   3 if [[ -e $file ]]
   4 then
   5   echo "Password file exists."
   6 fi
	
用[[ ... ]]测试结构比用[ ... ]更能防止脚本里的许多逻辑错误。比如说，&&,||,<和>操作符能在一个[[]]测试里通过，但在[]结构会发生错误。

	
在一个if的后面，不必一定是test命令或是test结构（[]或是[[]]）。
   1 dir=/home/bozo
   2 
   3 if cd "$dir" 2>/dev/null; then   # "2>/dev/null"会隐藏错误的信息.
   4   echo "Now in $dir."
   5 else
   6   echo "Can't change to $dir."
   7 fi
"if COMMAND"结构会返回COMMAND命令的退出状态码。

同样的，在一个测试方括号里面的条件测试也可以用列表结构(list construct)而不必用if。
   1 var1=20
   2 var2=22
   3 [ "$var1" -ne "$var2" ] && echo "$var1 is not equal to $var2"
   4 
   5 home=/home/bozo
   6 [ -d "$home" ] || echo "$home directory does not exist."
   (( ))结构扩展并计算一个算术表达式的值。如果表达式值为0，会返回1或假作为退出状态码。一个非零值的表达式返回一个0或真作为退出状态码。这个结构和先前test命令及[]结构的讨论刚好相反。

例子 7-3. 用(( ))进行算术测试

   1 #!/bin/bash
   2 # 算术测试.
   3 
   4 # (( ... ))结构会求值并测试该值。
   5 # 退出状态码与[ ... ]结构正好相反!
   6 
   7 (( 0 ))
   8 echo "Exit status of \"(( 0 ))\" is $?."         # 1
   9 
  10 (( 1 ))
  11 echo "Exit status of \"(( 1 ))\" is $?."         # 0
  12 
  13 (( 5 > 4 ))                                      # 真
  14 echo "Exit status of \"(( 5 > 4 ))\" is $?."     # 0
  15 
  16 (( 5 > 9 ))                                      # 假
  17 echo "Exit status of \"(( 5 > 9 ))\" is $?."     # 1
  18 
  19 (( 5 - 5 ))                                      # 0
  20 echo "Exit status of \"(( 5 - 5 ))\" is $?."     # 1
  21 
  22 (( 5 / 4 ))                                      # 除法有效.
  23 echo "Exit status of \"(( 5 / 4 ))\" is $?."     # 0
  24 
  25 (( 1 / 2 ))                                      # 除法计算结果< 1
  26 echo "Exit status of \"(( 1 / 2 ))\" is $?."     # 截取为0.
  27                                                  # 1
  28 
  29 (( 1 / 0 )) 2>/dev/null                          # 除以0的非法计算.
  30 #           ^^^^^^^^^^^
  31 echo "Exit status of \"(( 1 / 0 ))\" is $?."     # 1
  32 
  33 # 起了什么作用?
  34 # 如果不要"2>/dev/null"这句会怎么样?
  35 # 试试去掉这句再运行这个脚本.
  36 
  37 exit 0
  
  例子 7-4. 测试断掉的连接

   1 #!/bin/bash
   2 # broken-link.sh
   3 # 由Lee bigelow所写<ligelowbee@yahoo.com>
   4 # 已经征得作者的同意.
   5 
   6 #一个用于发现死符号链接并且输出它们的链接文件的纯shell的脚本。
   7 #所以它们能把输出提供给xargs并处理 :)
   8 #例如： broken-link.sh /somedir /someotherdir|xargs rm
   9 #
  10 #下面是更好的发现死符号链接的办法:
  11 #
  12 #find "somedir" -type l -print0|\
  13 #xargs -r0 file|\
  14 #grep "broken symbolic"|
  15 #sed -e 's/^\|: *broken symbolic.*$/"/g'
  16 #
  17 #但这不是纯bash脚本，下面的则是.
  18 #注意: 谨防在/proc文件系统和死循环链接中使用!
  19 ##############################################################
  20 
  21 
  22 #如果没有参数被传递给脚本作为搜索目录，则使用当前目录
  23 #
  24 #
  25 ####################
  26 [ $# -eq 0 ] && directorys=`pwd` || directorys=$@
  27 
  28 #Setup the function linkchk to check the directory it is passed 
  29 #for files that are links and don't exist, then print them quoted.
  30 #If one of the elements in the directory is a subdirectory then 
  31 #send that send that subdirectory to the linkcheck function.
  32 ##########
  33 linkchk () {
  34     for element in $1/*; do
  35     [ -h "$element" -a ! -e "$element" ] && echo \"$element\"
  36     [ -d "$element" ] && linkchk $element
  37     # Of course, '-h' tests for symbolic link, '-d' for directory.
  38     done
  39 }
  40 
  41 #Send each arg that was passed to the script to the linkchk function
  42 #if it is a valid directoy.  If not, then print the error message
  43 #and usage info.
  44 ################
  45 for directory in $directorys; do
  46     if [ -d $directory ]
  47 	then linkchk $directory
  48 	else 
  49 	    echo "$directory is not a directory"
  50 	    echo "Usage: $0 dir1 dir2 ..."
  51     fi
  52 done
  53 
  54 exit 0
  
  -eq

等于

if [ "$a" -eq "$b" ]

-ne
不等于

if [ "$a" -ne "$b" ]

-gt
大于

if [ "$a" -gt "$b" ]

-ge
大于等于

if [ "$a" -ge "$b" ]

-lt
小于

if [ "$a" -lt "$b" ]

-le
小于等于

if [ "$a" -le "$b" ]

<
小于(在双括号里使用)

(("$a" < "$b"))

<=
小于等于 (在双括号里使用)

(("$a" <= "$b"))

>
大于 (在双括号里使用)

(("$a" > "$b"))

>=
大于等于(在双括号里使用)

(("$a" >= "$b"))

字符串比较

=

等于

if [ "$a" = "$b" ]

==
等于

if [ "$a" == "$b" ]

它和=是同义词。

	
==比较操作符在一个双方括号测试和一个单方括号号里意思不同。
   1 [[ $a == z* ]]    # 如果变量$a以字符"z"开始(模式匹配)则为真.
   2 [[ $a == "z*" ]]  # 如果变量$a与z*(字面上的匹配)相等则为真.
   3 
   4 [ $a == z* ]      # 文件扩展和单元分割有效.
   5 [ "$a" == "z*" ]  # 如果变量$a与z*(字面上的匹配)相等则为真.
   6 
   7 # 多谢Stéphane Chazelas

!=
不相等

if [ "$a" != "$b" ]

操作符在[[ ... ]]结构里使用模式匹配.

<
小于，依照ASCII字符排列顺序

if [[ "$a" < "$b" ]]

if [ "$a" \< "$b" ]

注意"<"字符在[ ] 结构里需要转义

>
大于，依照ASCII字符排列顺序

if [[ "$a" > "$b" ]]

if [ "$a" \> "$b" ]

注意">"字符在[ ] 结构里需要转义.

参考例子 26-11 中这种比较的一个应用.

-z
字符串为"null"，即是指字符串长度为零。

-n
字符串不为"null"，即长度不为零.

	
在测试方括号里进行-n测试时一定要把字符串用引号起来。用没有引号引起的! -z或者在方括号里只有未引号引起的字符串 (参考例子 7-6)来进行测试一般都能工作，然而，这其实是不安全的测试。应该总是用引号把测试字符串引起来。[1]

例子 7-5. 算术和字符串比较

   1 #!/bin/bash
   2 
   3 a=4
   4 b=5
   5 
   6 #  这儿的"a"和"b"既能被看成是整数也能被看着是字符串。
   7 #  在字符串和数字之间不是严格界定的，
   8 #+ 因为Bash变量不是强类型的。
   9 
  10 #  Bash允许变量的整数操作和比较，
  11 #+ 但这些变量必须只包括数字字符.
  12 #  不管怎么样，你应该小心考虑.
  13 
  14 echo
  15 
  16 if [ "$a" -ne "$b" ]
  17 then
  18   echo "$a is not equal to $b"
  19   echo "(arithmetic comparison)"
  20 fi
  21 
  22 echo
  23 
  24 if [ "$a" != "$b" ]
  25 then
  26   echo "$a is not equal to $b."
  27   echo "(string comparison)"
  28   #     "4"  != "5"
  29   # ASCII 52 != ASCII 53
  30 fi
  31 
  32 # 在这个实际的例子中,"-ne"和"!="都能工作.
  33 
  34 echo
  35 
  36 exit 0
例子 7-6. 测试一个字符串是否是null值

   1 #!/bin/bash
   2 #  str-test.sh: 测试null字符串和没有用引号引起的字符串,
   3 #+ but not strings and sealing wax, not to mention cabbages and kings . . .
   4 
   5 # 用if [ ... ]结构
   6 
   7 
   8 # 如果一个字符串变量没有被初始化，它里面的值未定义。
   9 # 这种情况称为"null"值(不同于零).
  10 
  11 if [ -n $string1 ]    # $string1没有被声明或初始化.
  12 then
  13   echo "String \"string1\" is not null."
  14 else  
  15   echo "String \"string1\" is null."
  16 fi  
  17 # 错误结果.
  18 # Shows $string1 as not null, although it was not initialized.
  19 
  20 
  21 echo
  22 
  23 
  24 # 让我们再试试.
  25 
  26 if [ -n "$string1" ]  # 这次, $string1变量被引号引起.
  27 then
  28   echo "String \"string1\" is not null."
  29 else  
  30   echo "String \"string1\" is null."
  31 fi                    # 在一个测试方括里用引号引起变量!
  32 
  33 
  34 echo
  35 
  36 
  37 if [ $string1 ]       # 这次,变量$string1什么也不加.
  38 then
  39   echo "String \"string1\" is not null."
  40 else  
  41   echo "String \"string1\" is null."
  42 fi  
  43 # This works fine.
  44 # The [ ] test operator alone detects whether the string is null.
  45 # However it is good practice to quote it ("$string1").
  46 #
  47 # As Stephane Chazelas points out,
  48 #    if [ $string1 ]    has one argument, "]"
  49 #    if [ "$string1" ]  has two arguments, the empty "$string1" and "]" 
  50 
  51 
  52 
  53 echo
  54 
  55 
  56 
  57 string1=initialized
  58 
  59 if [ $string1 ]       # Again, $string1 stands naked.
  60 then
  61   echo "String \"string1\" is not null."
  62 else  
  63   echo "String \"string1\" is null."
  64 fi  
  65 # Again, gives correct result.
  66 # Still, it is better to quote it ("$string1"), because . . .
  67 
  68 
  69 string1="a = b"
  70 
  71 if [ $string1 ]       # Again, $string1 stands naked.
  72 then
  73   echo "String \"string1\" is not null."
  74 else  
  75   echo "String \"string1\" is null."
  76 fi  
  77 # Not quoting "$string1" now gives wrong result!
  78 
  79 exit 0
  80 # Thank you, also, Florian Wisser, for the "heads-up".
例子 7-7. zmore

   1 #!/bin/bash
   2 # zmore
   3 
   4 #用'more'查看被压缩过的文件
   5 
   6 NOARGS=65
   7 NOTFOUND=66
   8 NOTGZIP=67
   9 
  10 if [ $# -eq 0 ] # 等同于:  if [ -z "$1" ]
  11 # $1可以存在,但为空:  zmore "" arg2 arg3
  12 then
  13   echo "Usage: `basename $0` filename" >&2
  14   # 错误信息打印到标准错误.
  15   exit $NOARGS
  16   # 返回65作为脚本的退出状态(错误码).
  17 fi  
  18 
  19 filename=$1
  20 
  21 if [ ! -f "$filename" ]   # Quoting $filename allows for possible spaces.
  22 then
  23   echo "File $filename not found!" >&2
  24   # 错误信息打印到标准错误.
  25   exit $NOTFOUND
  26 fi  
  27 
  28 if [ ${filename##*.} != "gz" ]
  29 # 在方括号里使用变量替换.
  30 then
  31   echo "File $1 is not a gzipped file!"
  32   exit $NOTGZIP
  33 fi  
  34 
  35 zcat $1 | more
  36 
  37 # 用过滤程序'more.'
  38 # 如果你想，也可以用'less'代替。
  39 
  40 
  41 exit $?   # 脚本返回管道的退出状态
  42 # 实际上"exit $?"是多余的,因为在任何情况下，
  43 # 脚本会返回最后一个执行命令的退出码。
混合比较

-a
逻辑与

如果exp1和exp2都为真，则exp1 -a exp2返回真.

-o
逻辑或

只要exp1和exp2任何一个为真，则exp1 -o exp2 返回真.

它们和Bash中用于双方括号结构的比较操作符&&和||很相似。
   1 [[ condition1 && condition2 ]]
-o和-a操作符和test命令或单方括号一起使用。
   1 if [ "$exp1" -a "$exp2" ]


使用if/then结构的测试可以嵌套。最终的结果和使用上一节的&&混合比较操作符一样。

一个xinitrc系统文件能用来启动一个X服务器。这个文件包含了相当多的if/then测试，就像下面这个文件的一个摘录展示的一样。

   1 if [ -f $HOME/.Xclients ]; then
   2   exec $HOME/.Xclients
   3 elif [ -f /etc/X11/xinit/Xclients ]; then
   4   exec /etc/X11/xinit/Xclients
   5 else
   6      # 失败后的安全设置。　虽然我们决不该执行到这儿
   7      # (我们也在X客户提供可靠保证) 它不能被破坏.
   8      xclock -geometry 100x100-5+5 &
   9      xterm -geometry 80x50-50+150 &
  10      if [ -f /usr/bin/netscape -a -f /usr/share/doc/HTML/index.html ]; then
  11              netscape /usr/share/doc/HTML/index.html &
  12      fi
  13 fi
  
  **
求幂
   1 # Bash在版本2.02引入了"**"求幂操作符.
   2 
   3 let "z=5**3"
   4 echo "z = $z"   # z = 125
    1 #!/bin/bash
   2 # gcd.sh: 最大公约数
   3 #         用Euclid运算法则
   4 
   5 #  两个整数的"最大公约数"
   6 #+ 是能被这两个整数整除的大最整数.
   7 
   8 #  Euclid运算法则采用逐次除法.
   9 #  每一次都重新赋值,
  10 #+ 被除数 <---  除数
  11 #+ 除数  <---  余数
  12 #+ 直到 余数 = 0.
  13 #+ 最后被传递的值中：最大公约数 = 被除数.
  14 #
  15 #  关于Euclid运算法则的讨论有一个出色的讨论,
  16 #  访问Jim Loy的网站, http://www.jimloy.com/number/euclids.htm.
  17 
  18 
  19 # ------------------------------------------------------
  20 # 参数检查
  21 ARGS=2
  22 E_BADARGS=65
  23 
  24 if [ $# -ne "$ARGS" ]
  25 then
  26   echo "Usage: `basename $0` first-number second-number"
  27   exit $E_BADARGS
  28 fi
  29 # ------------------------------------------------------
  30 
  31 
  32 gcd ()
  33 {
  34 
  35   dividend=$1                    #  随意赋值.
  36   divisor=$2                     #+ 这里在两个参数赋大的还是小的都没有关系.
  37                                  #  为什么?
  38 
  39   remainder=1                    #  如果在循环中使用未初始化的变量,
  40                                  #+ 在循环中第一个传递值会使它返回一个错误信息
  41                                  #
  42 
  43   until [ "$remainder" -eq 0 ]
  44   do
  45     let "remainder = $dividend % $divisor"
  46     dividend=$divisor            # 现在用最小的两个数字来重复.
  47     divisor=$remainder
  48   done                           # Euclid运算法则
  49 
  50 }                                # 最后的$dividend变量值就是最大公约数.
  51 
  52 
  53 gcd $1 $2
  54 
  55 echo; echo "GCD of $1 and $2 = $dividend"; echo
  56 
  57 
  58 # 练习:
  59 # --------
  60 #  检测命令行参数以确保它们是整数,
  61 #+ 如果不是整数则给出一个适当的错误信息并退出脚本.
  62 
  63 exit 0
  
  例子 8-2. 使用计算操作符

   1 #!/bin/bash
   2 # 用10种不同的方法计数到11.
   3 
   4 n=1; echo -n "$n "
   5 
   6 let "n = $n + 1"   # let "n = n + 1"也可以.
   7 echo -n "$n "
   8 
   9 
  10 : $((n = $n + 1))
  11 #  ":"是需要的，
  12 #+ 否则Bash会尝试把"$((n = $n + 1))"作为命令运行.
  13 echo -n "$n "
  14 
  15 (( n = n + 1 ))
  16 #  上面是更简单的可行的办法.
  17 #  多谢David Lombard指出这一点.
  18 echo -n "$n "
  19 
  20 n=$(($n + 1))
  21 echo -n "$n "
  22 
  23 : $[ n = $n + 1 ]
  24 #  ":"是需要的，
  25 #+ 否则Bash会尝试把"$[ n = $n + 1 ]"作为命令运行.
  26 #  即使"n"被当作字符串来初始化也能工作.
  27 echo -n "$n "
  28 
  29 n=$[ $n + 1 ]
  30 #  即使"n"被当作字符串来初始化也能工作.
  31 #* 应避免这种使用这种结构,因为它是被废弃并不可移植的.
  32 #  多谢Stephane Chazelas.
  33 echo -n "$n "
  34 
  35 # 现在是C风格的增加操作.
  36 # 多谢Frank Wang指出这一点.
  37 
  38 let "n++"          # let "++n"也可以.
  39 echo -n "$n "
  40 
  41 (( n++ ))          # (( ++n )也可以.
  42 echo -n "$n "
  43 
  44 : $(( n++ ))       # : $(( ++n ))也可以.
  45 echo -n "$n "
  46 
  47 : $[ n++ ]         # : $[ ++n ]]也可以.
  48 echo -n "$n "
  49 
  50 echo
  51 
  52 exit 0
	
Bash中的整数变量实际上是有符号的长整数(32位)，它的范围在-2147483648至2147483647之间。如果有在此范围限制之外的操作将会得到一个错误的结果。
   1 a=2147483646
   2 echo "a = $a"      # a = 2147483646
   3 let "a+=1"         # 把变量"a"的值自增一.
   4 echo "a = $a"      # a = 2147483647
   5 let "a+=1"         # 再自增"a"一次,超过这个限制.
   6 echo "a = $a"      # a = -2147483648
   7                    #      错误 (溢出)
到2.05b版本为止，Bash支持64位的整数。

	
Bash不能处理浮点计算。它会把含有小数点的数当成字符串。
   1 a=1.5
   2 
   3 let "b = $a + 1.3"  # 错误
   4 # t2.sh: let: b = 1.5 + 1.3: syntax error in expression (error token is ".5 + 1.3") 意为表达式错误(错误的符号".5 + 1.3")
   5 
   6 echo "b = $b"       # b=1
在脚本中用bc需要浮点计算或数学库函数的支持。

例子 8-3. 使用&&和||进行混合条件测试

   1 #!/bin/bash
   2 
   3 a=24
   4 b=47
   5 
   6 if [ "$a" -eq 24 ] && [ "$b" -eq 47 ]
   7 then
   8   echo "Test #1 succeeds."
   9 else
  10   echo "Test #1 fails."
  11 fi
  12 
  13 # 错误:   if [ "$a" -eq 24 && "$b" -eq 47 ]
  14 #+         这会尝试执行' [ "$a" -eq 24 '
  15 #+         然后会因没找到匹配的']'而失败.
  16 #
  17 #  注意:  if [[ $a -eq 24 && $b -eq 24 ]]也可以.
  18 #  双方括号的if-test比
  19 #+ 单方括号的结构更灵活.       
  20 #    (第17行和第6行的"&&"有不同的意思.)
  21 #    多谢Stephane Chazelas指出这一点.
  22 
  23 
  24 if [ "$a" -eq 98 ] || [ "$b" -eq 47 ]
  25 then
  26   echo "Test #2 succeeds."
  27 else
  28   echo "Test #2 fails."
  29 fi
  30 
  31 
  32 #  -a和-o选项提供
  33 #+ 混合条件测试另一个选择.
  34 #  多谢Patrick Callahan指出这一点.
  35 
  36 
  37 if [ "$a" -eq 24 -a "$b" -eq 47 ]
  38 then
  39   echo "Test #3 succeeds."
  40 else
  41   echo "Test #3 fails."
  42 fi
  43 
  44 
  45 if [ "$a" -eq 98 -o "$b" -eq 47 ]
  46 then
  47   echo "Test #4 succeeds."
  48 else
  49   echo "Test #4 fails."
  50 fi
  51 
  52 
  53 a=rhino
  54 b=crocodile
  55 if [ "$a" = rhino ] && [ "$b" = crocodile ]
  56 then
  57   echo "Test #5 succeeds."
  58 else
  59   echo "Test #5 fails."
  60 fi
  61 
  62 exit 0
在算术计算的环境中，&&和||操作符也可以使用。

 bash$ echo $(( 1 && 2 )) $((3 && 0)) $((4 || 0)) $((0 || 0))
 1 0 1 0
 
 逗号操作符连接两个或更多的算术操作。所有的操作都被求值(可能会有副作用)，但只返回最后一个操作的结构.

   1 let "t1 = ((5 + 3, 7 - 1, 15 - 4))"
   2 echo "t1 = $t1"               # t1 = 11
   3 
   4 let "t2 = ((a = 9, 15 / 3))"  # 初始化"a"并求"t2"的值.
   5 echo "t2 = $t2    a = $a"     # t2 = 5    a = 9

逗号操作符主要用在for 循环里. 

除非一个数字有特别的前缀或符号，否则shell脚本把它当成十进制的数。一个前缀为0的数字是八进制数。一个前缀为0x的数字是十六进制数。一个数用内嵌的#来求值则看成BASE#NUMBER(有范围和符号限制)(译者注：BASE#NUMBER即：基数#数值，参考下面的例子)。

例子 8-4. 数字常量的表示法

   1 #!/bin/bash
   2 # numbers.sh: 不同基数的数字表示法.
   3 
   4 # 十进制数: 它是默认的
   5 let "dec = 32"
   6 echo "decimal number = $dec"             # 32
   7 # 这儿没有什么特别的.
   8 
   9 
  10 # 八进制数: 以'0'(零)为前缀
  11 let "oct = 032"
  12 echo "octal number = $oct"               # 26
  13 # 结果表示为十进制.
  14 # --------- ------ -- -------
  15 
  16 # 十六进制: 以'0x'或'0X'为前缀
  17 let "hex = 0x32"
  18 echo "hexadecimal number = $hex"         # 50
  19 # 以十进制的形式表示.
  20 
  21 # 其他的进制的表示形式: BASE#NUMBER
  22 # BASE值在2和64之间.
  23 # NUMBER必须使用在BASE范围内的符号,看下面的示例.
  24 
  25 
  26 let "bin = 2#111100111001101"
  27 echo "binary number = $bin"              # 31181
  28 
  29 let "b32 = 32#77"
  30 echo "base-32 number = $b32"             # 231
  31 
  32 let "b64 = 64#@_"
  33 echo "base-64 number = $b64"             # 4031
  34 # 这个符号只能工作在ASCII码值为2-64的范围限制.
  35 # 10个数字+26个小写字母+26个大写字母+ @ + _
  36 
  37 
  38 echo
  39 
  40 echo $((36#zz)) $((2#10101010)) $((16#AF16)) $((53#1aA))
  41                                          # 1295 170 44822 3375
  42 
  43 
  44 #  重要提示:
  45 #  --------------
  46 #  使用一个超出给定进制的数字将会引起一个错误信息。
  47 #+ gives an error message.
  48 
  49 let "bad_oct = 081"
  50 # ((部分的) 错误信息输出:
  51 #  bad_oct = 081: value too great for base (error token is "081")
  52 #              八进制数字只能使用数字0-7.
  53 
  54 exit 0       # 多谢Rich Bartell和Stephane Chazelas的指正。
  
  $IFS处理空白字符和其他的字符不相同。

例子 9-1. $IFS和空白符

   1 #!/bin/bash
   2 # $IFS处理空白字符和其他字符不相同。
   3 
   4 output_args_one_per_line()
   5 {
   6   for arg
   7   do echo "[$arg]"
   8   done
   9 }
  10 
  11 echo; echo "IFS=\" \""
  12 echo "-------"
  13 
  14 IFS=" "
  15 var=" a  b c   "
  16 output_args_one_per_line $var  # output_args_one_per_line函数相当于`echo " a  b c   "`
  17 #
  18 # [a]
  19 # [b]
  20 # [c]
  21 
  22 
  23 echo; echo "IFS=:"
  24 echo "-----"
  25 
  26 IFS=:
  27 var=":a::b:c:::"               # 像上面一样, 但用":"代替了" ".
  28 output_args_one_per_line $var
  29 #
  30 # []
  31 # [a]
  32 # []
  33 # [b]
  34 # [c]
  35 # []
  36 # []
  37 # []
  38 
  39 # 在awk中字段分隔符"FS"也有相同的特性.
  40 
  41 # 多谢Stephane Chazelas.
  42 
  43 echo
  44 
  45 exit 0
  
  PATH=${PATH}:/opt/bin 能把/opt/bin目录加到当前现有的目录列表中去。在一个脚本中，它可以用这种方法临时地加一个目录到目录列表中去。当一个脚本退出时，此变量会恢复回原先的$PATH值(一个子进程[比如一个脚本]，不能改变父进程的环境变量[比如启动脚本的shell])。

	
保存在$PATH目录列表中的当前"工作目录"(./)通常因为会引发安全漏洞而被忽略。

 1 #!/bin/bash
   2 
   3 E_WRONG_DIRECTORY=73
   4 
   5 clear # 清屏.
   6 
   7 TargetDirectory=/home/bozo/projects/GreatAmericanNovel
   8 
   9 cd $TargetDirectory
  10 echo "Deleting stale files in $TargetDirectory."
  11 
  12 if [ "$PWD" != "$TargetDirectory" ]
  13 then    # 防止意外工作在错误的目录中.
  14   echo "Wrong directory!"
  15   echo "In $PWD, rather than $TargetDirectory!"
  16   echo "Bailing out!"
  17   exit $E_WRONG_DIRECTORY
  18 fi  
  19 
  20 rm -rf *
  21 rm .[A-Za-z0-9]*    # 删除点文件.
  22 # rm -f .[^.]* ..?*   删除以多个点开始为文件名的文件.
  23 # (shopt -s dotglob; rm -f *)   也可以.
  24 # 多谢S.C.指出来.
  25 
  26 # 文件名除了"/"字符外可以包含ASCII值在0 - 255范围的所有字符
  27 # 删除以奇怪的字符开头的文件作为练习由读者实现.
  28 
  29 # 如果需要，这儿有多种其他的操作.
  30 
  31 echo
  32 echo "Done."
  33 echo "Old files deleted in $TargetDirectory."
  34 echo
  35 
  36 
  37 exit 0
  
  没有变量提供给read命令时的默认变量．这也适用于select命令的目录，但只是提供被选择的变量项目编号而不是变量本身的值．

   1 #!/bin/bash
   2 # reply.sh
   3 
   4 # REPLY 是一个read命令的默认变量.
   5 
   6 echo
   7 echo -n "What is your favorite vegetable? "
   8 read
   9 
  10 echo "Your favorite vegetable is $REPLY."
  11 #  如果没有变量提供且仅在这种情况，REPLY保存"read"命令上次读到的值
  12 #
  13 
  14 echo
  15 echo -n "What is your favorite fruit? "
  16 read fruit
  17 echo "Your favorite fruit is $fruit."
  18 echo "but..."
  19 echo "Value of \$REPLY is still $REPLY."
  20 #  $REPLY仍然被设置了它先前的值，
  21 #+ 因为变量$fruit保存了新的"read"读到的值.
  22 
  23 echo
  24 
  25 exit 0

$SECONDS
脚本已运行的秒数．

   1 #!/bin/bash
   2 
   3 TIME_LIMIT=10
   4 INTERVAL=1
   5 
   6 echo
   7 echo "Hit Control-C to exit before $TIME_LIMIT seconds."
   8 echo
   9 
  10 while [ "$SECONDS" -le "$TIME_LIMIT" ]
  11 do
  12   if [ "$SECONDS" -eq 1 ]
  13   then
  14     units=second
  15   else  
  16     units=seconds
  17   fi
  18 
  19   echo "This script has been running $SECONDS $units."
  20   #  在一个缓慢或负担过重的机器上,
  21   #+ 脚本可能偶尔会跳过一个计数.
  22   sleep $INTERVAL
  23 done
  24 
  25 echo -e "\a"  # Beep!(BB声)
  26 
  27 exit 0
  
  在Bash版本2.05b以上，可以在脚本中把$TMOUT和read命令结合使用．

   1 # 在Bash版本2.05b以上运行.
   2 
   3 TMOUT=3    # 提示输入时间为三秒.
   4 
   5 echo "What is your favorite song?"
   6 echo "Quickly now, you only have $TMOUT seconds to answer!"
   7 read song
   8 
   9 if [ -z "$song" ]
  10 then
  11   song="(no answer)"
  12   # 默认输出.
  13 fi
  14 
  15 echo "Your favorite song is $song."
  
  例子 9-2. 定时输入

   1 #!/bin/bash
   2 # timed-input.sh
   3 
   4 # TMOUT=3    在新一点的版本中，这个也可以.
   5 
   6 
   7 TIMELIMIT=3  # 在这个实例中设置成三秒，但可以设置成其它的值。
   8 
   9 PrintAnswer()
  10 {
  11   if [ "$answer" = TIMEOUT ]
  12   then
  13     echo $answer
  14   else       # 不要和上面那个例子弄混了. 
  15     echo "Your favorite veggie is $answer"
  16     kill $!  # 不再需要后台运行的TimerOn函数了，杀掉它
  17              # $!变量是上一个在后台运行的作业进程的PID
  18   fi
  19 
  20 }  
  21 
  22 
  23 
  24 TimerOn()
  25 {
  26   sleep $TIMELIMIT && kill -s 14 $$ &
  27   # 等3秒,然后给脚本发送sigalarm信号.
  28 }  
  29 
  30 Int14Vector()
  31 {
  32   answer="TIMEOUT"
  33   PrintAnswer
  34   exit 14
  35 }  
  36 
  37 trap Int14Vector 14   # 设置定时中断(14)能暗中给定时间限制
  38 
  39 echo "What is your favorite vegetable "
  40 TimerOn
  41 read answer
  42 PrintAnswer
  43 
  44 
  45 #  无可否认，这是一个定时输入的复杂的实现,
  46 #+ 然而"read"命令的"-t"选项可以简化这个任务。 
  47 #  参考后面的"t-out.sh"脚本
  48 
  49 #  如果你想要真正优雅的东西...
  50 #+ 可以考虑用C或C++写你的应用程序,
  51 #+ 使用合适的函数库,例如'alarm'或是'setitimer'.
  52 
  53 exit 0
  
  例子 9-3. 再来一个定时输入

   1 #!/bin/bash
   2 # timeout.sh
   3 
   4 #  由Stephane Chazelas所写,
   5 #+ 由本书作者作了些修改.
   6 
   7 INTERVAL=5                # 超时间隔
   8 
   9 timedout_read() {
  10   timeout=$1
  11   varname=$2
  12   old_tty_settings=`stty -g`
  13   stty -icanon min 0 time ${timeout}0
  14   eval read $varname      # 或只是读$varname变量
  15   stty "$old_tty_settings"
  16   # 请参考"stty"的man手册.
  17 }
  18 
  19 echo; echo -n "What's your name? Quick! "
  20 timedout_read $INTERVAL your_name
  21 
  22 #  这个可能不一定在每种终端都能运行.
  23 #  最大的超时值依赖于终端.
  24 #+ (通常是25.5秒).
  25 
  26 echo
  27 
  28 if [ ! -z "$your_name" ]  # 如果在超时之前名字被键入...
  29 then
  30   echo "Your name is $your_name."
  31 else
  32   echo "Timed out."
  33 fi
  34 
  35 echo
  36 
  37 # 这个脚本和"timed-input.sh"脚本的行为稍微有点不同.
  38 # 每一次击键,计时器都会重新设置（即重新开始）.
  39 
  40 exit 0
可能最容易的方法就是使用read命令的-t选项了。

例子 9-4. 定时read

   1 #!/bin/bash
   2 # t-out.sh
   3 # 从"syngin seven"的建议中得到灵感(多谢).
   4 
   5 
   6 TIMELIMIT=4         # 4秒
   7 
   8 read -t $TIMELIMIT variable <&1
   9 #                           ^^^
  10 #  在这儿, Bash 1.x and 2.x需要"<&1",
  11 #  但Bash 3.x则不需要.
  12 
  13 echo
  14 
  15 if [ -z "$variable" ]  # 值为null?
  16 then
  17   echo "Timed out, variable still unset."
  18 else  
  19   echo "variable = $variable"
  20 fi  
  21 
  22 exit 0
  
  $UID
用户ID号

这是当前用户的用户标识号，它在/etc/passwd文件中记录。

这是当前用户的真实ID，即使只是临时通过su命令转换成另外一个用户也会显示成转换成的ID号。$UID是个只读变量，不能在命令行或是脚本中更改它，并且它和内建命令id是有些相似的。

例子 9-5. 我是root吗？

   1 #!/bin/bash
   2 # am-i-root.sh:   我是root吗？
   3 
   4 ROOT_UID=0   # Root的$UID为0.
   5 
   6 if [ "$UID" -eq "$ROOT_UID" ]  # 真正的"root"才能经得住考验
   7 then
   8   echo "You are root."
   9 else
  10   echo "You are just an ordinary user (but mom loves you just the same)."
  11 fi
  12 
  13 exit 0
  14 
  15 
  16 # ============================================================= #
  17 # 下面的代码不会执行,因为脚本在上面已经退出了.
  18 
  19 # 另外一种判断是否是root用户的方法:
  20 
  21 ROOTUSER_NAME=root
  22 
  23 username=`id -nu`              # 或者...   username=`whoami`
  24 if [ "$username" = "$ROOTUSER_NAME" ]
  25 then
  26   echo "Rooty, toot, toot. You are root."
  27 else
  28   echo "You are just a regular fella."
  29 fi
  
  例子 9-6. arglist: 用$*和$@列出参数来

   1 #!/bin/bash
   2 # arglist.sh
   3 # 用几个参数来运行这个脚本,比如说"one two three".
   4 
   5 E_BADARGS=65
   6 
   7 if [ ! -n "$1" ]
   8 then
   9   echo "Usage: `basename $0` argument1 argument2 etc."
  10   exit $E_BADARGS
  11 fi  
  12 
  13 echo
  14 
  15 index=1          # 初始计数.
  16 
  17 echo "Listing args with \"\$*\":"
  18 for arg in "$*"  # 如果"$*"没有被引号引起来，会完全不能工作.
  19 do
  20   echo "Arg #$index = $arg"
  21   let "index+=1"
  22 done             # $* sees all arguments as single word. 
  23 echo "Entire arg list seen as single word."
  24 
  25 echo
  26 
  27 index=1          # Reset count.
  28                  # What happens if you forget to do this?
  29 
  30 echo "Listing args with \"\$@\":"
  31 for arg in "$@"
  32 do
  33   echo "Arg #$index = $arg"
  34   let "index+=1"
  35 done             # $@ sees arguments as separate words. 
  36 echo "Arg list seen as separate words."
  37 
  38 echo
  39 
  40 index=1          # Reset count.
  41 
  42 echo "Listing args with \$* (unquoted):"
  43 for arg in $*
  44 do
  45   echo "Arg #$index = $arg"
  46   let "index+=1"
  47 done             # Unquoted $* sees arguments as separate words. 
  48 echo "Arg list seen as separate words."
  49 
  50 exit 0
在一个shift命令的后面，变量$@会保存除掉先前参数列表的位置参数$1后剩下的命令行参数。
   1 #!/bin/bash
   2 # 以./scriptname 1 2 3 4 5执行
   3 
   4 echo "$@"    # 1 2 3 4 5
   5 shift
   6 echo "$@"    # 2 3 4 5
   7 shift
   8 echo "$@"    # 3 4 5
   9 
  10 # 每次"shift"后会丢掉$1.
  11 # 然后"$@"保存剩下的参数。
  
  例子 9-8. 当$IFS为空时的$*和$@

   1 #!/bin/bash
   2 
   3 #  如果$IFS被设置，但值是空的,
   4 #+ 则"$*"和"$@"不会像希望的那样显示位置参数。
   5 
   6 mecho ()       # 显示位置参数.
   7 {
   8 echo "$1,$2,$3";
   9 }
  10 
  11 
  12 IFS=""         # 设置了,但值是空的.
  13 set a b c      # 位置参数.
  14 
  15 mecho "$*"     # abc,,
  16 mecho $*       # a,b,c
  17 
  18 mecho $@       # a,b,c
  19 mecho "$@"     # a,b,c
  20 
  21 #  当$IFS为空时，
  22 #+ $*和$@的行为依赖于Bash或是sh正在运行.
  23 #  因此在一个脚本里使用这种“特性”是失策的。
  24 
  25 
  26 # 多谢Stephane Chazelas.
  27 
  28 exit 0
  
  $_
保存前一个命令最后一个参数的变量值。

例子 9-9. 下划线变量

   1 #!/bin/bash
   2 
   3 echo $_              # /bin/bash
   4                      # 只需调用/bin/bash来运行这个脚本.
   5 
   6 du >/dev/null        # 从命令行里没有输出.
   7 echo $_              # du
   8 
   9 ls -al >/dev/null    # 从命令行里没有输出.
  10 echo $_              # -al  (它是最后的参数)
  11 
  12 :
  13 echo $_              # :
  
  例子 9-18. 更改文件扩展名（后缀）:

   1 #!/bin/bash
   2 # rfe.sh: 更改文件扩展名.
   3 #
   4 #         rfe old_extension new_extension
   5 #
   6 # 例如:
   7 # T为了把当前目录下所有的*.gif文件改成*.jpg,如下执行：
   8 #          rfe gif jpg
   9 
  10 
  11 E_BADARGS=65
  12 
  13 case $# in
  14   0|1)             # 在这里，竖线(|)意味着"或"。
  15   echo "Usage: `basename $0` old_file_suffix new_file_suffix"
  16   exit $E_BADARGS  # 如果是0或1，就退出脚本
  17   ;;
  18 esac
  19 
  20 
  21 for filename in *.$1
  22 # 把文件名以第一个参数为后缀的文件全部列举出来
  23 do
  24   mv $filename ${filename%$1}$2
  25   #  剥去文件名中匹配第一个参数的部分,
  26   #+ 然后加上第二个参数.
  27 done
  28 
  29 exit 0
  
  例子 9-22. 间接引用

   1 #!/bin/bash
   2 # ind-ref.sh: 间接变量引用.
   3 # 访问一个变量内容所指的变量的值.
   4 
   5 a=letter_of_alphabet   # 变量"a"保存着另外一个变量的名字.
   6 letter_of_alphabet=z
   7 
   8 echo
   9 
  10 # 直接引用.
  11 echo "a = $a"          # a = letter_of_alphabet
  12 
  13 # 间接引用.
  14 eval a=\$$a
  15 echo "Now a = $a"      # 现在 a = z
  16 
  17 echo
  18 
  19 
  20 # 现在，让我们试试更改第二次引用的顺序Now, let's try changing the second-order reference.
  21 
  22 t=table_cell_3
  23 table_cell_3=24
  24 echo "\"table_cell_3\" = $table_cell_3"            # "table_cell_3" = 24
  25 echo -n "dereferenced \"t\" = "; eval echo \$$t    # 显示：dereferenced "t" = 24
  26 # 在这个简单的情况下，下面的也可以工作吗？(为什么？).
  27 #         eval t=\$$t; echo "\"t\" = $t"
  28 
  29 echo
  30 
  31 t=table_cell_3
  32 NEW_VAL=387
  33 table_cell_3=$NEW_VAL
  34 echo "Changing value of \"table_cell_3\" to $NEW_VAL."
  35 echo "\"table_cell_3\" now $table_cell_3"
  36 echo -n "dereferenced \"t\" now "; eval echo \$$t
  37 # "eval"带着两个参数："echo"和"\$$t"(相当于 $table_cell_3)
  38 
  39 echo
  40 
  41 # (多谢Stephane Chazelas解释了上面的语句的现象)
  42 
  43 
  44 # 另外一个办法是使用${!t}符号，这个在"Bash, 版本 2"章节中讨论.
  45 # 参考脚本 ex78.sh.
  46 
  47 exit 0
变量间接引用的实际用处是什么? 它提供了Bash具有C中一点指针的功能，例如，在表格查找中的用处，另外它也有其他一些有趣的应用. . . .

Nils Radtke展示了如何建立动态变量名和求它们的值。当source配置文件时这个技巧很有用。
   1 #!/bin/bash
   2 
   3 
   4 # ---------------------------------------------
   5 # 这个文件可被另外单独的文件用source命令执行.
   6 isdnMyProviderRemoteNet=172.16.0.100
   7 isdnYourProviderRemoteNet=10.0.0.10
   8 isdnOnlineService="MyProvider"
   9 # ---------------------------------------------
  10       
  11 
  12 remoteNet=$(eval "echo \$$(echo isdn${isdnOnlineService}RemoteNet)")
  13 remoteNet=$(eval "echo \$$(echo isdnMyProviderRemoteNet)")
  14 remoteNet=$(eval "echo \$isdnMyProviderRemoteNet")
  15 remoteNet=$(eval "echo $isdnMyProviderRemoteNet")
  16 
  17 echo "$remoteNet"    # 172.16.0.100
  18 
  19 # ================================================================
  20 
  21 #  可以做的更好.
  22 
  23 #  注意下面的片断给出了变量getSparc,
  24 #+ 但没有变量getIa64:
  25 
  26 chkMirrorArchs () { 
  27   arch="$1";
  28   if [ "$(eval "echo \${$(echo get$(echo -ne $arch |
  29        sed 's/^\(.\).*/\1/g' | tr 'a-z' 'A-Z'; echo $arch |
  30        sed 's/^.\(.*\)/\1/g')):-false}")" = true ]
  31   then
  32      return 0;
  33   else
  34      return 1;
  35   fi;
  36 }
  37 
  38 getSparc="true"
  39 unset getIa64
  40 chkMirrorArchs sparc
  41 echo $?        # 0
  42                # 真
  43 
  44 chkMirrorArchs Ia64
  45 echo $?        # 1
  46                # 假
  47 
  48 # 注意:
  49 # -----
  50 # Even the to-be-substituted variable name part is built explicitly.
  51 # The parameters to the chkMirrorArchs calls are all lower case.
  52 # The variable name is composed of two parts: "get" and "Sparc" . . .
  
  9.6. $RANDOM: 产生随机整数

$RANDOM是Bash的一个返回伪随机 [1]整数(范围为0 - 32767)的内部函数(而不是一个常量或变量)，它不应该用于产生加密的密钥.

例子 9-24. 产生随机整数

   1 #!/bin/bash
   2 
   3 # 每次调用$RANDOM都会返回不同的随机整数.
   4 # 范围为: 0 - 32767 (带符号的16位整数).
   5 
   6 MAXCOUNT=10
   7 count=1
   8 
   9 echo
  10 echo "$MAXCOUNT random numbers:"
  11 echo "-----------------"
  12 while [ "$count" -le $MAXCOUNT ]      # 产生10($MAXCOUNT)个随机整数.
  13 do
  14   number=$RANDOM
  15   echo $number
  16   let "count += 1"  # 增加计数.
  17 done
  18 echo "-----------------"
  19 
  20 # 如果你需要某个范围的随机整数，可以使用取模操作符.(译者注：事实上，这不是一个非常好的办法。理由请见man 3 rand)
  21 # 取模操作会返回除法的余数.
  22 
  23 RANGE=500
  24 
  25 echo
  26 
  27 number=$RANDOM
  28 let "number %= $RANGE"
  29 #           ^^
  30 echo "Random number less than $RANGE  ---  $number"
  31 
  32 echo
  33 
  34 
  35 
  36 #  如果你需要一个大于某个下限的随机整数,
  37 #+ 应该增加测试以便抛弃所有小于此下限值的数值.
  38 
  39 FLOOR=200
  40 
  41 number=0   #初始化
  42 while [ "$number" -le $FLOOR ]
  43 do
  44   number=$RANDOM
  45 done
  46 echo "Random number greater than $FLOOR ---  $number"
  47 echo
  48 
  49    # 让我们检测另外一个完成上面循环作用的简单办法，即
  50    #       let "number = $RANDOM + $FLOOR"
  51    # 这能避免了while循环，并且运行得更快。
  52    # 但，使用这个技术可能会产生问题，思考一下是什么问题？
  53 
  54 
  55 
  56 # 联合上面两个技巧重新产生在两个限制值之间的随机整数.
  57 number=0   #初始化
  58 while [ "$number" -le $FLOOR ]
  59 do
  60   number=$RANDOM
  61   let "number %= $RANGE"  # Scales $number down within $RANGE.
  62 done
  63 echo "Random number between $FLOOR and $RANGE ---  $number"
  64 echo
  65 
  66 
  67 
  68 # 产生二元值，即"真"或"假".
  69 BINARY=2
  70 T=1
  71 number=$RANDOM
  72 
  73 let "number %= $BINARY"
  74 #  注意    let "number >>= 14"    会产生更平均的随机分布   #(译者注：正如在man手册里提到的，更高位的随机分布更平均，
  75 #+ (除了最后的二元值右移出所有的值).                       #取模操作使用低位来产生随机会相对不平均)
  76 if [ "$number" -eq $T ]
  77 then
  78   echo "TRUE"
  79 else
  80   echo "FALSE"
  81 fi  
  82 
  83 echo
  84 
  85 
  86 # 模拟掷骰子.
  87 SPOTS=6   # 模除 6 会产生 0 - 5 之间的值.
  88           # 结果增1会产生 1 - 6 之间的值.
  89           # 多谢Paulo Marcel Coelho Aragao的简化.
  90 die1=0
  91 die2=0
  92 # 这会比仅设置SPOTS=7且不增1好?为什么会好？为什么会不好?
  93 
  94 # 单独地掷每个骰子，然后计算出正确的机率.
  95 
  96     let "die1 = $RANDOM % $SPOTS +1" # 掷第一个.
  97     let "die2 = $RANDOM % $SPOTS +1" # 掷第二个.
  98     #  上面的算术式中，哪个操作符优先计算 --
  99     #+ 取模 (%) 还是 加法 (+)?
 100 
 101 
 102 let "throw = $die1 + $die2"
 103 echo "Throw of the dice = $throw"
 104 echo
 105 
 106 
 107 exit 0
 
 例子 9-25. 模拟从一副纸牌里随机抽一张纸牌

   1 #!/bin/bash
   2 # pick-card.sh
   3 
   4 # 这是从一个数组中随机选择元素的例子.
   5 
   6 
   7 # 抽出一张任意牌.
   8 
   9 Suites="Clubs
  10 Diamonds
  11 Hearts
  12 Spades"
  13 
  14 Denominations="2
  15 3
  16 4
  17 5
  18 6
  19 7
  20 8
  21 9
  22 10
  23 Jack
  24 Queen
  25 King
  26 Ace"
  27 
  28 # 注意变量值由多行组成.
  29 
  30 
  31 suite=($Suites)                # 读入一个数组.
  32 denomination=($Denominations)
  33 
  34 num_suites=${#suite[*]}        # 计算有几个数组元素.
  35 num_denominations=${#denomination[*]}
  36 
  37 echo -n "${denomination[$((RANDOM%num_denominations))]} of "
  38 echo ${suite[$((RANDOM%num_suites))]}
  39 
  40 
  41 # $bozo sh pick-cards.sh
  42 # Jack of Clubs
  43 
  44 
  45 # 多谢"jipe,"指出$RANDOM的这个用法.
  46 exit 0
Jipe 指出了一套技巧来产生一个范围里的随机数。
   1 #  产生 6 和 30之间的随机数.
   2    rnumber=$((RANDOM%25+6))	
   3 
   4 #  产生在 6 - 30 之间的随机数,
   5 #+ 但随机数还同时要满足被3整除.
   6    rnumber=$(((RANDOM%30/3+1)*3))
   7 
   8 #  注意这将始终不能工作.
   9 #  如果$RANDOM返回0，它就会失败.
  10 
  11 #  Frank Wang建议用下面的办法:
  12    rnumber=$(( RANDOM%27/3*3+6 ))
Bill Gradwohl 提出一个改良的公式，这个公式只用于正数.
   1 rnumber=$(((RANDOM%(max-min+divisibleBy))/divisibleBy*divisibleBy+min))
上面Bill展示了一个通用的函数，它可以返回两个指定值之间的随机数。

例子 9-26. 指定值之间的随机数

   1 #!/bin/bash
   2 # random-between.sh
   3 # 产生两个指定值之间的随机数. 
   4 # 由Bill Gradwohl编写,并由本书作者作了些许修改.
   5 # 已得到程序作者的许可.
   6 
   7 
   8 randomBetween() {
   9    #  产生在$min和$max之前的正或负的随机数
  10    #+ 并且能被$divisibleBy整数除.
  11    #
  12    #  给出一个合理的随机分配的返回值.
  13    #
  14    #  Bill Gradwohl - Oct 1, 2003
  15 
  16    syntax() {
  17    # 在函数中内嵌函数
  18       echo
  19       echo    "Syntax: randomBetween [min] [max] [multiple]"
  20       echo
  21       echo    "Expects up to 3 passed parameters, but all are completely optional."
  22       echo    "min is the minimum value"
  23       echo    "max is the maximum value"
  24       echo    "multiple specifies that the answer must be a multiple of this value."
  25       echo    "    i.e. answer must be evenly divisible by this number."
  26       echo    
  27       echo    "If any value is missing, defaults area supplied as: 0 32767 1"
  28       echo    "Successful completion returns 0, unsuccessful completion returns"
  29       echo    "function syntax and 1."
  30       echo    "The answer is returned in the global variable randomBetweenAnswer"
  31       echo    "Negative values for any passed parameter are handled correctly."
  32    }
  33 
  34    local min=${1:-0}
  35    local max=${2:-32767}
  36    local divisibleBy=${3:-1}
  37    # 默认值分配,用来处理没有参数传递进来的时候.
  38 
  39    local x
  40    local spread
  41 
  42    # 确认divisibleBy是正值.
  43    [ ${divisibleBy} -lt 0 ] && divisibleBy=$((0-divisibleBy))
  44 
  45    # 完整性检查.
  46    if [ $# -gt 3 -o ${divisibleBy} -eq 0 -o  ${min} -eq ${max} ]; then 
  47       syntax
  48       return 1
  49    fi
  50 
  51    # 察看是否min和max颠倒了.
  52    if [ ${min} -gt ${max} ]; then
  53       # Swap them.
  54       x=${min}
  55       min=${max}
  56       max=${x}
  57    fi
  58 
  59    #  如果min自己并不能够被$divisibleBy整除,
  60    #+ 那么就调整min的值,使其能够被$divisibleBy整除,前提是不能放大范围.
  61    if [ $((min/divisibleBy*divisibleBy)) -ne ${min} ]; then 
  62       if [ ${min} -lt 0 ]; then
  63          min=$((min/divisibleBy*divisibleBy))
  64       else
  65          min=$((((min/divisibleBy)+1)*divisibleBy))
  66       fi
  67    fi
  68 
  69    #  如果min自己并不能够被$divisibleBy整除,
  70    #+ 那么就调整max的值,使其能够被$divisibleBy整除,前提是不能放大范围.
  71    if [ $((max/divisibleBy*divisibleBy)) -ne ${max} ]; then 
  72       if [ ${max} -lt 0 ]; then
  73          max=$((((max/divisibleBy)-1)*divisibleBy))
  74       else
  75          max=$((max/divisibleBy*divisibleBy))
  76       fi
  77    fi
  78 
  79    #  ---------------------------------------------------------------------
  80    #  现在,来做真正的工作.
  81 
  82    #  注意,为了得到对于端点来说合适的分配,
  83    #+ 随机值的范围不得不落在
  84    #+ 0 和 abs(max-min)+divisibleBy之间, 而不是 abs(max-min)+1.
  85 
  86    #  对于端点来说,
  87    #+ 这个少量的增加将会产生合适的分配.
  88 
  89    #  修改这个公式,使用abs(max-min)+1来代替abs(max-min)+divisibleBy的话,
  90    #+ 也能够产生正确的答案, 但是在这种情况下生成的随机值对于正好为端点倍数
  91    #+ 的这种情况来说将是不完美的,因为在正好为端点倍数的情况的随机率比较低,
  92    #+ 因为你才加1而已,这比正常的公式所产生的机率要小得多(正常为加divisibleBy)
  93    #  ---------------------------------------------------------------------
  94 
  95    spread=$((max-min))
  96    [ ${spread} -lt 0 ] && spread=$((0-spread))
  97    let spread+=divisibleBy
  98    randomBetweenAnswer=$(((RANDOM%spread)/divisibleBy*divisibleBy+min))   
  99 
 100    return 0
 101 
 102    #  然而,Paulo Marcel Coelho Aragao指出
 103    #+ 当$max和$min不能被$divisibleBy整除时,
 104    #+ 这个公式将会失败.
 105    #
 106    #  他建议使用如下的公式:
 107    #    rnumber = $(((RANDOM%(max-min+1)+min)/divisibleBy*divisibleBy))
 108 
 109 }
 110 
 111 # 让我们测试一下这个函数.
 112 min=-14
 113 max=20
 114 divisibleBy=3
 115 
 116 
 117 #  产生一个数组answers,answers的下标用来表示在范围内可能出现的值,
 118 #+ 而内容记录的是对于这个值出现的次数,如果我们循环足够多次,一定会得到一次出现机会.
 119 
 120 declare -a answer
 121 minimum=${min}
 122 maximum=${max}
 123    if [ $((minimum/divisibleBy*divisibleBy)) -ne ${minimum} ]; then 
 124       if [ ${minimum} -lt 0 ]; then
 125          minimum=$((minimum/divisibleBy*divisibleBy))
 126       else
 127          minimum=$((((minimum/divisibleBy)+1)*divisibleBy))
 128       fi
 129    fi
 130 
 131 
 132    #  如果maximum自己并不能够被$divisibleBy整除,
 133    #+ 那么就调整maximum的值,使其能够被$divisibleBy整除,前提是不能放大范围.
 134 
 135    if [ $((maximum/divisibleBy*divisibleBy)) -ne ${maximum} ]; then 
 136       if [ ${maximum} -lt 0 ]; then
 137          maximum=$((((maximum/divisibleBy)-1)*divisibleBy))
 138       else
 139          maximum=$((maximum/divisibleBy*divisibleBy))
 140       fi
 141    fi
 142 
 143 
 144 #  我们需要产生一个下标全为正的数组,
 145 #+ 所以我们需要一个displacement来保正都为正的结果.
 146 
 147 
 148 displacement=$((0-minimum))
 149 for ((i=${minimum}; i<=${maximum}; i+=divisibleBy)); do
 150    answer[i+displacement]=0
 151 done
 152 
 153 
 154 # 现在我们循环足够多的次数来得到我们想要的答案.
 155 loopIt=1000   #  脚本作者建议 100000,
 156               #+ 但是这实在是需要太长的时间了.
 157 
 158 for ((i=0; i<${loopIt}; ++i)); do
 159 
 160    #  注意,我们在这里调用randomBetween函数时,故意将min和max颠倒顺序
 161    #+ 我们是为了测试在这种情况下,此函数是否还能得到正确的结果.
 162 
 163    randomBetween ${max} ${min} ${divisibleBy}
 164 
 165    # 如果答案不是我们所预期的,那么就报告一个错误.
 166    [ ${randomBetweenAnswer} -lt ${min} -o ${randomBetweenAnswer} -gt ${max} ] && echo MIN or MAX error - ${randomBetweenAnswer}!
 167    [ $((randomBetweenAnswer%${divisibleBy})) -ne 0 ] && echo DIVISIBLE BY error - ${randomBetweenAnswer}!
 168 
 169    # 将统计值存到answer之中.
 170    answer[randomBetweenAnswer+displacement]=$((answer[randomBetweenAnswer+displacement]+1))
 171 done
 172 
 173 
 174 
 175 # 让我们察看一下结果
 176 
 177 for ((i=${minimum}; i<=${maximum}; i+=divisibleBy)); do
 178    [ ${answer[i+displacement]} -eq 0 ] && echo "We never got an answer of $i." || echo "${i} occurred ${answer[i+displacement]} times."
 179 done
 180 
 181 
 182 exit 0
$RANDOM到底有多随机?最好的办法就是写个脚本来测试一下.跟踪随机数的分配情况.
让我们用随机数摇一个骰子 . . .

例子 9-27. 用RANDOM模拟掷单个骰子

   1 #!/bin/bash
   2 # RANDOM到底有多random?
   3 
   4 RANDOM=$$       # 使用脚本的进程ID来作为随机数的产生种子.
   5 
   6 PIPS=6          # 一个骰子有6面.
   7 MAXTHROWS=600   # 如果你没别的事干,那么可以增加这个数值.
   8 throw=0         # 抛骰子的次数.
   9 
  10 ones=0          # 必须把所有count都初始化为0,
  11 twos=0          #+因为未初始化的变量为null,不是0.
  12 threes=0
  13 fours=0
  14 fives=0
  15 sixes=0
  16 
  17 print_result ()
  18 {
  19 echo
  20 echo "ones =   $ones"
  21 echo "twos =   $twos"
  22 echo "threes = $threes"
  23 echo "fours =  $fours"
  24 echo "fives =  $fives"
  25 echo "sixes =  $sixes"
  26 echo
  27 }
  28 
  29 update_count()
  30 {
  31 case "$1" in
  32   0) let "ones += 1";;   # 因为骰子没有0,所以给1.
  33   1) let "twos += 1";;   # 对tows做同样的事.
  34   2) let "threes += 1";;
  35   3) let "fours += 1";;
  36   4) let "fives += 1";;
  37   5) let "sixes += 1";;
  38 esac
  39 }
  40 
  41 echo
  42 
  43 
  44 while [ "$throw" -lt "$MAXTHROWS" ]
  45 do
  46   let "die1 = RANDOM % $PIPS"
  47   update_count $die1
  48   let "throw += 1"
  49 done  
  50 
  51 print_result
  52 
  53 exit 0
  54 
  55 #  如果RANDOM是真正的随机,那么摇出来结果应该平均的.
  56 #  $MAXTHROWS设为600,那么每面都应该为100,上下的出入不应该超过20.
  57 #
  58 #  记住RANDOM毕竟只是一个伪随机数,
  59 #+ 并且不是十分完美的.
  60 
  61 #  随机数的产生是一个深奥并复杂的问题.
  62 #  足够长的随机序列,不但会展现杂乱无章的一面,
  63 #+ 而且会展现机会均等的一面.
  64 
  65 # 练习 (容易):
  66 # ---------------
  67 # 重写这个例子,做成抛1000次硬币的形式.
  68 # 分为正反两面.
像我们在上边的例子中看到的,最好在每次随机数产生时都使用新的种子.应为如果使用同样的种子的话,那么随机数将产生相同的序列. [2] (C中random()函数也会有这样的行为.)

例子 9-28. 重新分配随机数种子

   1 #!/bin/bash
   2 # seeding-random.sh: 设置RANDOM变量作为种子.
   3 
   4 MAXCOUNT=25       # 决定产生多少个随机数.
   5 
   6 random_numbers ()
   7 {
   8 count=0
   9 while [ "$count" -lt "$MAXCOUNT" ]
  10 do
  11   number=$RANDOM
  12   echo -n "$number "
  13   let "count += 1"
  14 done  
  15 }
  16 
  17 echo; echo
  18 
  19 RANDOM=1          # 为随机数的产生设置RANDOM种子.
  20 random_numbers
  21 
  22 echo; echo
  23 
  24 RANDOM=1          # 设置同样的种子...
  25 random_numbers    # ...将会和上边产生的随机数列相同.
  26                   #
  27                   # 复制一个相同的随机数序列在什么时候有用呢?
  28 
  29 echo; echo
  30 
  31 RANDOM=2          # 再试一下,但这次使用不同的种子...
  32 random_numbers    # 将给出一个不同的随机数序列.
  33 
  34 echo; echo
  35 
  36 # RANDOM=$$  使用脚本的进程id 作为随机数的种子.
  37 # 从'time'或'date'命令中取得RANDOM作为种子也是很常用的办法.
  38 
  39 # 一个有想象力的方法...
  40 SEED=$(head -1 /dev/urandom | od -N 1 | awk '{ print $2 }')
  41 #  首先从/dev/urandom(系统伪随机设备文件)中取出1行,
  42 #+ from /dev/urandom (system pseudo-random device-file),
  43 #+ 然后着这个可打印行转换为(8进制)数,通过使用"od"命令,
  44 #+ 最后使用"awk"来获得一个数.
  45 RANDOM=$SEED
  46 random_numbers
  47 
  48 echo; echo
  49 
  50 exit 0

	
/dev/urandom设备文件提供了一种比单独使用$RANDOM更好的,能产生更"随机"的随机数的方法.dd if=/dev/urandom of=targetfile bs=1 count=XX能够产生一个很分散的为随机数.然而,将这个数赋值到一个脚本文件的变量中,还需要可操作性,比如使用"od"命令(就像上边的例子,见Example 12-13),或者使用dd命令(见Example 12-55),或者管道到"md5sum"命令中(见Example 33-14).


当然还有其它的产生伪随机数的方法.Awk就可以提供一个方便的方法.

例子 9-29. 使用awk产生伪随机数

   1 #!/bin/bash
   2 # random2.sh: 产生一个范围0 - 1的为随机数.
   3 # 使用awk的rand()函数.
   4 
   5 AWKSCRIPT=' { srand(); print rand() } '
   6 #            Command(s) / 传到awk中的参数
   7 # 注意,srand()函数用来产生awk的随机数种子.
   8 
   9 
  10 echo -n "Random number between 0 and 1 = "
  11 
  12 echo | awk "$AWKSCRIPT"
  13 # 如果你省去'echo'那么将发生什么?
  14 
  15 exit 0
  16 
  17 
  18 # 练习:
  19 # ---------
  20 
  21 # 1) 使用循环结构,打印出10个不同的随机数.
  22 #      (提示: 在循环的每次执行过程中,你必须使用"srand()"函数来生成不同的
  23 #+     种子.如果你没做这件事那么将发生什么?
  24 
  25 # 2) 使用一个整数乘法作为一个放缩因子,在10到100的范围之间,
  26 #+   来产生随机数.
  27 
  28 # 3) 同上边的练习 #2,但这次产生随机整数.
"date"命令也可以用来产生伪随机整数序列.

注

[1]	
真正的随机事件(在它存在的范围内),只发生在特定的几个未知的自然界现象中,比如放射性衰变.计算机只能产生模拟的随机事件,并且计算机产生的"随机"数因此只能称为伪随机数.

[2]	
计算机产生的伪随机数序列用的种子可以被看成是一种标识标签.比如,使用种子23所产生的伪随机数序列就被称作序列#23.

一个伪随机序列的特点就是在这个序列开始重复之前的所有元素的个数的和,也就是这个序列的长度.一个好的伪随机产生算法将可以产生一个非常长的不重复的序列.

类似于let命令,((...))结构允许算术计算和求值. 它最简单的形式a=$(( 5 + 3 )) 会把变量"a"的值设置成"5 + 3"或8. 但是，在Bash中双括号结构也是遵循C风格的变量操作的一种机制.

例子 9-30. C风格的变量操作

   1 #!/bin/bash
   2 # 用((...))结构来使用C风格操作符来处理变量.
   3 
   4 
   5 echo
   6 
   7 (( a = 23 ))  # 以C风格来设置一个值，在"="两边可以有空格.
   8 echo "a (initial value) = $a"
   9 
  10 (( a++ ))     # C风格的计算后自增.
  11 echo "a (after a++) = $a"
  12 
  13 (( a-- ))     # C风格的计算后自减.
  14 echo "a (after a--) = $a"
  15 
  16 
  17 (( ++a ))     # C风格的计算前自增.
  18 echo "a (after ++a) = $a"
  19 
  20 (( --a ))     # C风格的计算前自减.
  21 echo "a (after --a) = $a"
  22 
  23 echo
  24 
  25 ########################################################
  26 #  注意，就像在C中一样，计算前自增自减和计算后自增自减有一点不同的的副作用
  27 #
  28 
  29 n=1; let --n && echo "True" || echo "False"  # False
  30 n=1; let n-- && echo "True" || echo "False"  # True
  31 
  32 #  多谢Jeroen Domburg.
  33 ########################################################
  34 
  35 echo
  36 
  37 (( t = a<45?7:11 ))   # C风格的三元计算.
  38 echo "If a < 45, then t = 7, else t = 11."
  39 echo "t = $t "        # Yes!
  40 
  41 echo
  42 
  43 
  44 # -----------------
  45 # 复活节彩蛋大礼!
  46 # -----------------
  47 #  Chet Ramey显然在此偷偷地隐瞒了Bash中双括号的C风格结构
  48 #+ (实际上是从ksh中继承来的，两者非常的接近).
  49 #  在Bash的文档里, Ramey称((...))为shell算术计算,
  50 #+ 但它所能做的远远超出这个.
  51 #  不好意思, Chet,现在秘密已经被揭开了.
  52 
  53 # 参考"for"和"while"循环中使用((...))结构的章节.
  54 
  55 # 这个只能在Bash版本 2.04以上才能工作.
  56 
  57 exit 0
  
  for arg in [list]
do 
   command(s)... 
done

	
在循环的每次执行中,arg将顺序的存取list中列出的变量..

   1 for arg in "$var1" "$var2" "$var3" ... "$varN"  
   2 # 在第1次循环中, arg = $var1	    
   3 # 在第2次循环中, arg = $var2	    
   4 # 在第3次循环中, arg = $var3	    
   5 # ...
   6 # 在第N次循环中, arg = $varN
   7 
   8 # 在[list]中的参数加上双引号是为了防止单词被不合理地分割.

list中的参数允许包含通配符.

如果do和for想在同一行出现,那么在它们之间需要添加一个";".

for arg in [list] ; do 

例子 10-1. 循环的一个简单例子

   1 #!/bin/bash
   2 # 列出所有的行星名称.
   3 
   4 for planet in Mercury Venus Earth Mars Jupiter Saturn Uranus Neptune Pluto
   5 do
   6   echo $planet  # 每个行星被单独打印在一行上.
   7 done
   8 
   9 echo
  10 
  11 for planet in "Mercury Venus Earth Mars Jupiter Saturn Uranus Neptune Pluto"
  12 # 所有的行星名称打印在同一行上.
  13 # 整个'list'只有一个变量，用""封成一个变量.
  14 do
  15   echo $planet
  16 done
  17 
  18 exit 0
  
  例子 10-2. 每个[list]元素带两个参数的for循环

   1 #!/bin/bash
   2 # 再访行星.
   3 
   4 # 分配行星的名字和它距太阳的距离.
   5 
   6 for planet in "Mercury 36" "Venus 67" "Earth 93"  "Mars 142" "Jupiter 483"
   7 do
   8   set -- $planet  # Parses variable "planet" and sets positional parameters.
   9   # "--" 将防止$planet为空,或者是以一个破折号开头.
  10 
  11   # 可能需要保存原始的位置参数,因为它们被覆盖了.
  12   # 一种方法就是使用数组,
  13   #        original_params=("$@")
  14 
  15   echo "$1		$2,000,000 miles from the sun"
  16   #-------two  tabs---把后边的0和$2连接起来
  17 done
  18 
  19 # (Thanks, S.C., for additional clarification.)
  20 
  21 exit 0
可以在for循环中的[list]位置放入一个变量.

例子 10-3. 文件信息: 对包含在变量中的文件列表进行操作

   1 #!/bin/bash
   2 # fileinfo.sh
   3 
   4 FILES="/usr/sbin/accept
   5 /usr/sbin/pwck
   6 /usr/sbin/chroot
   7 /usr/bin/fakefile
   8 /sbin/badblocks
   9 /sbin/ypbind"     # 你关心的文件列表.
  10                   # 扔进去一个假文件, /usr/bin/fakefile.
  11 
  12 echo
  13 
  14 for file in $FILES
  15 do
  16 
  17   if [ ! -e "$file" ]       # 检查文件是否存在.
  18   then
  19     echo "$file does not exist."; echo
  20     continue                # 继续下一个.
  21    fi
  22 
  23   ls -l $file | awk '{ print $9 "         file size: " $5 }'  # 打印2个域.
  24   whatis `basename $file`   # 文件信息.
  25   # 注意whatis数据库需要提前建立好.
  26   # 要想达到这个目的, 以root身份运行/usr/bin/makewhatis.
  27   echo
  28 done  
  29 
  30 exit 0
如果在for循环的[list]中有通配符(*和?),那将会产生文件名扩展,也就是文件名扩展（globbing）.

例子 10-4. 在for循环中操作文件

   1 #!/bin/bash
   2 # list-glob.sh:  在for循环中使用文件名扩展产生 [list]
   3 
   4 echo
   5 
   6 for file in *
   7 #           ^  在表达式中识别文件扩展符时,
   8 #+             Bash 将执行文件名扩展.
   9 do
  10   ls -l "$file"  # Lists all files in $PWD (current directory).
  11   #  回想一下,通配符"*"能够匹配所有文件,
  12   #+ 然而,在"文件扩展符"中,是不能匹配"."文件的.
  13 
  14   #  如果没匹配到任何文件,那它将扩展成自己
  15   #  为了不让这种情况发生,那就设置nullglob选项
  16   #+   (shopt -s nullglob).
  17   #  Thanks, S.C.
  18 done
  19 
  20 echo; echo
  21 
  22 for file in [jx]*
  23 do
  24   rm -f $file    # 只删除当前目录下以"j"或"x"开头的文件.
  25   echo "Removed file \"$file\"".
  26 done
  27 
  28 echo
  29 
  30 exit 0
  
  例子 10-5. 在for循环中省略in [list]

   1 #!/bin/bash
   2 
   3 #  使用两种方法来调用这个脚本,一种是带参数的情况,另一种不带参数.
   4 #+ 观察此脚本的行为各是什么样的?
   5 
   6 for a
   7 do
   8  echo -n "$a "
   9 done
  10 
  11 #  没有[list],所以循环将操作'$@'
  12 #+ (包括空白的命令参数列表).
  13 
  14 echo
  15 
  16 exit 0
也可以使用命令替换（command substitution）来产生for循环的[list].具体见例子 12-49, 例子 10-10 和例子 12-43.

例子10-6. 使用命令替换来产生for循环的[list]

   1 #!/bin/bash
   2 #  for-loopcmd.sh: 带[list]的for循环
   3 #+ [list]是由命令替换产生的.
   4 
   5 NUMBERS="9 7 3 8 37.53"
   6 
   7 for number in `echo $NUMBERS`  # for number in 9 7 3 8 37.53
   8 do
   9   echo -n "$number "
  10 done
  11 
  12 echo 
  13 exit 0
下边是一个用命令替换来产生[list]的更复杂的例子.

例子 10-7. 对于二进制文件的grep替换

   1 #!/bin/bash
   2 # bin-grep.sh: 在一个二进制文件中定位匹配字串.
   3 
   4 # 对于二进制文件的一个grep替换
   5 # 与"grep -a"的效果相似
   6 
   7 E_BADARGS=65
   8 E_NOFILE=66
   9 
  10 if [ $# -ne 2 ]
  11 then
  12   echo "Usage: `basename $0` search_string filename"
  13   exit $E_BADARGS
  14 fi
  15 
  16 if [ ! -f "$2" ]
  17 then
  18   echo "File \"$2\" does not exist."
  19   exit $E_NOFILE
  20 fi  
  21 
  22 
  23 IFS="\n"         # 由Paulo Marcel Coelho Aragao提出的建议.
  24 for word in $( strings "$2" | grep "$1" )
  25 # "strings" 命令列出二进制文件中的所有字符串.
  26 # 输出到管道交给"grep",然后由grep命令来过滤字符串.
  27 do
  28   echo $word
  29 done
  30 
  31 # S.C. 指出, 行23 - 29 可以被下边的这行来代替,
  32 #    strings "$2" | grep "$1" | tr -s "$IFS" '[\n*]'
  33 
  34 
  35 # 试试用"./bin-grep.sh mem /bin/ls"来运行这个脚本.
  36 
  37 exit 0
大部分相同.

例子 10-8. 列出系统上的所有用户

   1 #!/bin/bash
   2 # userlist.sh
   3 
   4 PASSWORD_FILE=/etc/passwd
   5 n=1           # User number
   6 
   7 for name in $(awk 'BEGIN{FS=":"}{print $1}' < "$PASSWORD_FILE" )
   8 # 域分隔   = :           ^^^^^^
   9 # 打印出第一个域                 ^^^^^^^^
  10 # 从password文件中取得输入                    ^^^^^^^^^^^^^^^^^
  11 do
  12   echo "USER #$n = $name"
  13   let "n += 1"
  14 done  
  15 
  16 
  17 # USER #1 = root
  18 # USER #2 = bin
  19 # USER #3 = daemon
  20 # ...
  21 # USER #30 = bozo
  22 
  23 exit 0
  24 
  25 #  练习:
  26 #  --------
  27 #  一个普通用户(或者是一个普通用户运行的脚本)
  28 #+ 怎么能读取/etc/password呢?
  29 #  这是否是一个安全漏洞? 为什么是?为什么不是?
关于用命令替换来产生[list]的最后的例子.

例子 10-9. 在目录的所有文件中查找源字串

   1 #!/bin/bash
   2 # findstring.sh:
   3 # 在一个指定目录的所有文件中查找一个特定的字符串.
   4 
   5 directory=/usr/bin/
   6 fstring="Free Software Foundation"  # 查看那个文件中包含FSF.
   7 
   8 for file in $( find $directory -type f -name '*' | sort )
   9 do
  10   strings -f $file | grep "$fstring" | sed -e "s%$directory%%"
  11   #  在"sed"表达式中,
  12   #+ 我们必须替换掉正常的替换分隔符"/",
  13   #+ 因为"/"碰巧是我们需要过滤的字串之一.
  14   #  如果不用"%"代替"/"作为分隔符,那么这个操作将失败,并给出一个错误消息.(试试)
  15 done  
  16 
  17 exit 0
  18 
  19 #  练习 (容易):
  20 #  ---------------
  21 #  将内部用的$directory和$fstring变量,用从
  22 #+ 命令行参数代替.
for循环的输出也可以通过管道传递到一个或多个命令中.

例子 10-10. 列出目录中所有的符号连接(symbolic links)

   1 #!/bin/bash
   2 # symlinks.sh: 列出目录中所有的符号连接文件.
   3 
   4 
   5 directory=${1-`pwd`}
   6 #  如果没有其他的特殊指定,
   7 #+ 默认为当前工作目录.
   8 #  下边的代码块,和上边这句等价.
   9 # ----------------------------------------------------------
  10 # ARGS=1                 # 需要一个命令行参数.
  11 #
  12 # if [ $# -ne "$ARGS" ]  # 如果不是一个参数的话...
  13 # then
  14 #   directory=`pwd`      # 当前工作目录
  15 # else
  16 #   directory=$1
  17 # fi
  18 # ----------------------------------------------------------
  19 
  20 echo "symbolic links in directory \"$directory\""
  21 
  22 for file in "$( find $directory -type l )"   # -type l 就是符号连接文件
  23 do
  24   echo "$file"
  25 done | sort                                  # 否则列出的文件将是未排序的
  26 #  严格上说,此处并不一定非要一个循环不可,
  27 #+ 因为"find"命令的结果将被扩展成一个单词.
  28 #  然而,这种方式很容易理解和说明.
  29 
  30 #  Dominik 'Aeneas' Schnitzer 指出,
  31 #+ 如果没将 $( find $directory -type l )用""引用起来的话
  32 #+ 那么将会把一个带有空白部分的文件名拆成以空白分隔的两部分(文件名中允许有空白).
  33 #  即使这只将取出每个参数的第一个域.
  34 
  35 exit 0
  36 
  37 
  38 # Jean Helou 建议使用下边的方法:
  39 
  40 echo "symbolic links in directory \"$directory\""
  41 # 当前IFS的备份.要小心使用这个值.
  42 OLDIFS=$IFS
  43 IFS=:
  44 
  45 for file in $(find $directory -type l -printf "%p$IFS")
  46 do     #                              ^^^^^^^^^^^^^^^^
  47        echo "$file"
  48        done|sort
循环的输出可以重定向到文件中,我们对上边的例子做了一点修改.

例子 10-11. 将目录中的符号连接文件名保存到一个文件中

   1 #!/bin/bash
   2 # symlinks.sh: 列出目录中所有的符号连接文件.
   3 
   4 OUTFILE=symlinks.list                         # 保存的文件
   5 
   6 directory=${1-`pwd`}
   7 #  如果没有其他的特殊指定,
   8 #+ 默认为当前工作目录.
   9 
  10 
  11 echo "symbolic links in directory \"$directory\"" > "$OUTFILE"
  12 echo "---------------------------" >> "$OUTFILE"
  13 
  14 for file in "$( find $directory -type l )"    # -type l 为寻找类型为符号链接的文件
  15 do
  16   echo "$file"
  17 done | sort >> "$OUTFILE"                     # 循环的输出
  18 #           ^^^^^^^^^^^^^                       重定向到一个文件中.
  19 
  20 exit 0
有一种非常像C语言的for循环的语法形式.这需要使用(()).

例子 10-12. 一个C风格的for循环

   1 #!/bin/bash
   2 # 两种循环到10的方法.
   3 
   4 echo
   5 
   6 # 标准语法.
   7 for a in 1 2 3 4 5 6 7 8 9 10
   8 do
   9   echo -n "$a "
  10 done  
  11 
  12 echo; echo
  13 
  14 # +==========================================+
  15 
  16 # 现在, 让我们用C风格的语法做同样的事.
  17 
  18 LIMIT=10
  19 
  20 for ((a=1; a <= LIMIT ; a++))  # 双圆括号, 并且"LIMIT"变量前边没有 "$".
  21 do
  22   echo -n "$a "
  23 done                           # 这是一个借用'ksh93'的结构.
  24 
  25 echo; echo
  26 
  27 # +=========================================================================+
  28 
  29 # 让我们使用C的逗号操作符,来同时增加两个变量的值.
  30 
  31 for ((a=1, b=1; a <= LIMIT ; a++, b++))  # 逗号将同时进行2条操作.
  32 do
  33   echo -n "$a-$b "
  34 done
  35 
  36 echo; echo
  37 
  38 exit 0
参考例子 26-15, 例子 26-16, 和 例子 A-6.

---

现在来一个现实生活中使用的for循环.

例子 10-13. 在batch mode中使用efax

   1 #!/bin/bash
   2 # Faxing ('fax' 必须已经被安装过了).
   3 
   4 EXPECTED_ARGS=2
   5 E_BADARGS=65
   6 
   7 if [ $# -ne $EXPECTED_ARGS ]
   8 # 检查命令行参数的个数是否正确.
   9 then
  10    echo "Usage: `basename $0` phone# text-file"
  11    exit $E_BADARGS
  12 fi
  13 
  14 
  15 if [ ! -f "$2" ]
  16 then
  17   echo "File $2 is not a text file"
  18   exit $E_BADARGS
  19 fi
  20   
  21 
  22 fax make $2              # 从文本文件中创建传真格式的文件.
  23 
  24 for file in $(ls $2.0*)  # 连接转换过的文件.
  25                          # 在变量列表中使用通配符.
  26 do
  27   fil="$fil $file"
  28 done  
  29 
  30 efax -d /dev/ttyS3 -o1 -t "T$1" $fil   # 干活的地方.
  31 
  32 
  33 # S.C. 指出, 通过下边的命令可以省去for循环.
  34 #    efax -d /dev/ttyS3 -o1 -t "T$1" $2.0*
  35 # 但这并不十分有讲解意义[嘿嘿].
  36 
  37 exit 0
while
这种结构在循环的开头判断条件是否满足,如果条件一直满足,那就一直循环下去(0为退出码[exit status]).与for 循环的区别是,这种结构适合用在循环次数未知的情况下.

while [condition]
do 
  command... 
done

和for循环一样,如果想把do和条件放到同一行上还是需要一个";".

while [condition] ; do

注意一下某种特定的while循环,比如getopts结构,好像和这里所介绍的模版有点脱节.

例子 10-14. 简单的while循环

   1 #!/bin/bash
   2 
   3 var0=0
   4 LIMIT=10
   5 
   6 while [ "$var0" -lt "$LIMIT" ]
   7 do
   8   echo -n "$var0 "        # -n 将会阻止产生新行.
   9   #             ^           空格,数字之间的分隔.
  10 
  11   var0=`expr $var0 + 1`   # var0=$(($var0+1))  也可以.
  12                           # var0=$((var0 + 1)) 也可以.
  13                           # let "var0 += 1"    也可以.
  14 done                      # 使用其他的方法也行.
  15 
  16 echo
  17 
  18 exit 0
例子 10-15. 另一个while循环

   1 #!/bin/bash
   2 
   3 echo
   4                                # 等价于:
   5 while [ "$var1" != "end" ]     # while test "$var1" != "end"
   6 do
   7   echo "Input variable #1 (end to exit) "
   8   read var1                    # 为什么不使用'read $var1'?
   9   echo "variable #1 = $var1"   # 因为包含"#"字符,所以需要"" . . .
  10   # 如果输入为'end',那么就在这里打印.
  11   # 不在这里判断结束,在循环顶判断.
  12   echo
  13 done  
  14 
  15 exit 0
一个while循环可以有多个判断条件,但是只有最后一个才能决定是否退出循环.然而这需要一种有点不同的循环语法.

例子 10-16. 多条件的while循环

   1 #!/bin/bash
   2 
   3 var1=unset
   4 previous=$var1
   5 
   6 while echo "previous-variable = $previous"
   7       echo
   8       previous=$var1
   9       [ "$var1" != end ] # 记录之前的$var1.
  10       # 这个"while"循环中有4个条件, 但是只有最后一个能控制循环.
  11       # 退出状态由第4个条件决定.
  12 do
  13 echo "Input variable #1 (end to exit) "
  14   read var1
  15   echo "variable #1 = $var1"
  16 done  
  17 
  18 # 尝试理解这个脚本的运行过程.
  19 # 这里还是有点小技巧的.
  20 
  21 exit 0
与for循环一样,while循环也可通过(())来使用C风格语法.(见例子 9-30).

例子 10-17. C风格的while循环

   1 #!/bin/bash
   2 # wh-loopc.sh: 循环10次的while循环.
   3 
   4 LIMIT=10
   5 a=1
   6 
   7 while [ "$a" -le $LIMIT ]
   8 do
   9   echo -n "$a "
  10   let "a+=1"
  11 done           # 到目前为止都没什么令人惊奇的地方.
  12 
  13 echo; echo
  14 
  15 # +=================================================================+
  16 
  17 # 现在, 重复C风格的语法.
  18 
  19 ((a = 1))      # a=1
  20 # 双圆括号允许赋值两边的空格,就像C语言一样.
  21 
  22 while (( a <= LIMIT ))   # 双圆括号, 变量前边没有"$".
  23 do
  24   echo -n "$a "
  25   ((a += 1))   # let "a+=1"
  26   # Yes, 看到了吧.
  27   # 双圆括号允许像C风格的语法一样增加变量的值.
  28 done
  29 
  30 echo
  31 
  32 # 现在,C程序员可以在Bash中找到回家的感觉了吧.
  33 
  34 exit 0
	
while循环的stdin可以用<来重定向到文件.

whild循环的stdin支持管道.

until
这个结构在循环的顶部判断条件,并且如果条件一直为false那就一直循环下去.(与while相反).

until [condition-is-true]
do 
  command... 
done

注意: until循环的判断在循环的顶部,这与某些编程语言是不同的.

与for循环一样,如果想把do和条件放在一行里,就使用";".

until [condition-is-true] ; do

例子 10-18. until循环

   1 #!/bin/bash
   2 
   3 END_CONDITION=end
   4 
   5 until [ "$var1" = "$END_CONDITION" ]
   6 # 在循环的顶部判断条件.
   7 do
   8   echo "Input variable #1 "
   9   echo "($END_CONDITION to exit)"
  10   read var1
  11   echo "variable #1 = $var1"
  12   echo
  13 done  
  14 
  15 exit 0
  
  嵌套循环就是在一个循环中还有一个循环,内部循环在外部循环体中.在外部循环的每次执行过程中都会触发内部循环,直到内部循环执行结束.外部循环执行了多少次,内部循环就完成多少次.当然,不论是外部循环或内部循环的break语句都会打断处理过程.

例子 10-19. 嵌套循环

   1 #!/bin/bash
   2 # nested-loop.sh: 嵌套的"for" 循环.
   3 
   4 outer=1             # 设置外部循环计数.
   5 
   6 # 开始外部循环.
   7 for a in 1 2 3 4 5
   8 do
   9   echo "Pass $outer in outer loop."
  10   echo "---------------------"
  11   inner=1           # 重设内部循环的计数.
  12 
  13   # ===============================================
  14   # 开始内部循环.
  15   for b in 1 2 3 4 5
  16   do
  17     echo "Pass $inner in inner loop."
  18     let "inner+=1"  # 增加内部循环计数.
  19   done
  20   # 内部循环结束.
  21   # ===============================================
  22 
  23   let "outer+=1"    # 增加外部循环的计数.
  24   echo              # 每次外部循环之间的间隔.
  25 done               
  26 # 外部循环结束.
  27 
  28 exit 0
  
  例子 10-20. break和continue命令在循环中的效果

   1 #!/bin/bash
   2 
   3 LIMIT=19  # 上限
   4 
   5 echo
   6 echo "Printing Numbers 1 through 20 (but not 3 and 11)."
   7 
   8 a=0
   9 
  10 while [ $a -le "$LIMIT" ]
  11 do
  12  a=$(($a+1))
  13 
  14  if [ "$a" -eq 3 ] || [ "$a" -eq 11 ]  # Excludes 3 and 11.
  15  then
  16    continue      # 跳过本次循环剩下的语句.
  17  fi
  18 
  19  echo -n "$a "   # 在$a等于3和11的时候,这句将不会执行.
  20 done 
  21 
  22 # 练习:
  23 # 为什么循环会打印到20?
  24 
  25 echo; echo
  26 
  27 echo Printing Numbers 1 through 20, but something happens after 2.
  28 
  29 ##################################################################
  30 
  31 # 同样的循环, 但是用'break'来代替'continue'.
  32 
  33 a=0
  34 
  35 while [ "$a" -le "$LIMIT" ]
  36 do
  37  a=$(($a+1))
  38 
  39  if [ "$a" -gt 2 ]
  40  then
  41    break  # Skip entire rest of loop.
  42  fi
  43 
  44  echo -n "$a "
  45 done
  46 
  47 echo; echo; echo
  48 
  49 exit 0
break命令可以带一个参数.一个不带参数的break循环只能退出最内层的循环,而break N可以退出N层循环.

例子 10-21. 多层循环的退出

   1 #!/bin/bash
   2 # break-levels.sh: 退出循环.
   3 
   4 # "break N" 退出N层循环.
   5 
   6 for outerloop in 1 2 3 4 5
   7 do
   8   echo -n "Group $outerloop:   "
   9 
  10   # --------------------------------------------------------
  11   for innerloop in 1 2 3 4 5
  12   do
  13     echo -n "$innerloop "
  14 
  15     if [ "$innerloop" -eq 3 ]
  16     then
  17       break  # 试试 break 2 来看看发生什么.
  18              # (里面一层循环和外面一层循环都被退出了..)
  19     fi
  20   done
  21   # --------------------------------------------------------
  22 
  23   echo
  24 done  
  25 
  26 echo
  27 
  28 exit 0
continue命令也可以像break带一个参数.一个不带参数的continue命令只去掉本次循环的剩余代码.而continue N将会把N层循环剩余的代码都去掉,但是循环的次数不变.

例子 10-22. 多层循环的continue

   1 #!/bin/bash
   2 # "continue N" 命令, 将让N层的循环全部被continue.
   3 
   4 for outer in I II III IV V           # 外部循环
   5 do
   6   echo; echo -n "Group $outer: "
   7 
   8   # --------------------------------------------------------------------
   9   for inner in 1 2 3 4 5 6 7 8 9 10  # 内部循环
  10   do
  11 
  12     if [ "$inner" -eq 7 ]
  13     then
  14       continue 2  # continue 2层, 也就是到outer循环上.
  15                   # 将"continue 2"替换为一个单独的"continue"
  16                   # 来看一下一个正常循环的行为.
  17     fi  
  18 
  19     echo -n "$inner "  # 7 8 9 10 将不会被echo
  20   done  
  21   # --------------------------------------------------------------------
  22 #译者注:如果在此处添加echo的话,当然也不会输出.
  23 done
  24 
  25 echo; echo
  26 
  27 # 练习:
  28 # 准备一个有意义的"continue N"的使用,放在脚本中.
  29 
  30 exit 0
例子 10-23. 在实际的任务中使用"continue N"

   1 # Albert Reiner 给出了一个关于使用"continue N"的例子:
   2 # ---------------------------------------------------------
   3 
   4 #  假定我有很多任务需要运行,
   5 #+ 这些任务要处理一些数据，这些数据保存在一个目录下的文件里，文件是以预先给定的模式命名的
   6 #+ 有几个机器会存取这个目录
   7 #+ 我想把工作都分配给这几个不同的机器.
   8 #+ 然后我一般会在每个机器里运行类似下面的代码:
   9 
  10 while true
  11 do
  12   for n in .iso.*
  13   do
  14     [ "$n" = ".iso.opts" ] && continue
  15     beta=${n#.iso.}
  16     [ -r .Iso.$beta ] && continue
  17     [ -r .lock.$beta ] && sleep 10 && continue
  18     lockfile -r0 .lock.$beta || continue
  19     echo -n "$beta: " `date`
  20     run-isotherm $beta
  21     date
  22     ls -alF .Iso.$beta
  23     [ -r .Iso.$beta ] && rm -f .lock.$beta
  24     continue 2
  25   done
  26   break
  27 done
  28 
  29 #  在我的应用里的细节（尤其是sleep N）更一般的模式是：
  30 #
  31 
  32 while true
  33 do
  34   for job in {pattern}
  35   do
  36     {job already done or running} && continue
  37     {mark job as running, do job, mark job as done}
  38     continue 2
  39   done
  40   break        # 而所谓的 `sleep 600' 只是想避免程序太快结束达不到演示的效果.
  41 done
  42 
  43 #  脚本只有当所有任务都完成之后才会停止运行
  44 #+ (包括那些运行时新添加的任务).
  45 #+ 
  46 #+ 通过使用合适的lockfiles可以使几个机器协作运作而不会产生重复的处理
  47 #+ [在我的情况里，重复的处理会使处理时间延长多一倍时间，因此我很想避免这个问题].
  48 #+ 同样，如果每次都从头开始搜索，可以由文件名得到处理顺序
  49 #+ 当然,还有一种办法也可以不使用`continue 2',
  50 #+ 但这样就不得不检查相同的任务是不是已经完成过了
  51 #+  (而我们应该立马来找到下一个要运行的任务)
  52 #+ (在演示的情况里，检查新任务前我们终止或睡眠了一段长时间).
  53 #
	
continue N结构如果被用在一个有意义的上下文中的话,往往都很难理解,并且技巧性很高.所以最好的方法就是尽量避免它.

例子 10-24. 使用case

   1 #!/bin/bash
   2 # 测试字符串范围
   3 
   4 echo; echo "Hit a key, then hit return."
   5 read Keypress
   6 
   7 case "$Keypress" in
   8   [[:lower:]]   ) echo "Lowercase letter";;
   9   [[:upper:]]   ) echo "Uppercase letter";;
  10   [0-9]         ) echo "Digit";;
  11   *             ) echo "Punctuation, whitespace, or other";;
  12 esac      #  允许字符串的范围出现在[]中,
  13           #+ 或者POSIX风格的[[中.
  14 
  15 #  在这个例子的第一个版本中,
  16 #+ 测试大写和小写字符串使用的是
  17 #+ [a-z] 和 [A-Z].
  18 #  这种用法将不会在某些特定的场合或Linux发行版中正常工作.
  19 #  POSIX 风格更具可移植性.
  20 #  感谢Frank Wang 指出这点.
  21 
  22 #  练习:
  23 #  --------
  24 #  就像这个脚本所表现的,它只允许单次的按键,然后就结束了.
  25 #  修改这个脚本,让它能够接受重复输入,
  26 #+ 报告每个按键,并且只有在"X"被键入时才结束.
  27 #  暗示: 将这些代码都用"while"循环圈起来.
  28 
  29 exit 0
例子 10-25. 使用case来创建菜单

   1 #!/bin/bash
   2 
   3 # 未经处理的地址资料
   4 
   5 clear # 清屏.
   6 
   7 echo "          Contact List"
   8 echo "          ------- ----"
   9 echo "Choose one of the following persons:" 
  10 echo
  11 echo "[E]vans, Roland"
  12 echo "[J]ones, Mildred"
  13 echo "[S]mith, Julie"
  14 echo "[Z]ane, Morris"
  15 echo
  16 
  17 read person
  18 
  19 case "$person" in
  20 # 注意,变量是被引用的.
  21 
  22   "E" | "e" )
  23   # 接受大写或小写输入.
  24   echo
  25   echo "Roland Evans"
  26   echo "4321 Floppy Dr."
  27   echo "Hardscrabble, CO 80753"
  28   echo "(303) 734-9874"
  29   echo "(303) 734-9892 fax"
  30   echo "revans@zzy.net"
  31   echo "Business partner & old friend"
  32   ;;
  33 # 注意,在每个选项后边都需要以;;结尾.
  34 
  35   "J" | "j" )
  36   echo
  37   echo "Mildred Jones"
  38   echo "249 E. 7th St., Apt. 19"
  39   echo "New York, NY 10009"
  40   echo "(212) 533-2814"
  41   echo "(212) 533-9972 fax"
  42   echo "milliej@loisaida.com"
  43   echo "Ex-girlfriend"
  44   echo "Birthday: Feb. 11"
  45   ;;
  46 
  47 # 后边的Smith和Zane的信息在这里就省略了.
  48 
  49           * )
  50    # 默认选项.
  51    # 空输入(敲RETURN).
  52    echo
  53    echo "Not yet in database."
  54   ;;
  55 
  56 esac
  57 
  58 echo
  59 
  60 #  练习:
  61 #  --------
  62 #  修改这个脚本,让它能够接受多输入,
  63 #+ 并且能够显示多个地址.
  64 
  65 exit 0
一个case的特殊用法,用来测试命令行参数.
   1 #! /bin/bash
   2 
   3 case "$1" in
   4 "") echo "Usage: ${0##*/} <filename>"; exit $E_PARAM;;  # 没有命令行参数,
   5                                                         # 或者第一个参数为空.
   6 # 注意:${0##*/} 是${var##pattern} 这种模式的替换. 得到的结果是$0.
   7 
   8 -*) FILENAME=./$1;;   #  如果传递进来的文件名参数($1)以一个破折号开头,
   9                       #+ 那么用./$1来代替
  10                       #+ 这样后边的命令将不会把它作为一个选项来解释.
  11 
  12 * ) FILENAME=$1;;     # 否则, $1.
  13 esac

这是一个更容易懂的命令行参数处理的一个例子：
   1 #! /bin/bash
   2 
   3 
   4 while [ $# -gt 0 ]; do    # 直到你用完所有的参数...
   5   case "$1" in
   6     -d|--debug)
   7               # 是"-d" 或 "--debug" 参数吗?
   8               DEBUG=1
   9               ;;
  10     -c|--conf)
  11               CONFFILE="$2"
  12               shift
  13               if [ ! -f $CONFFILE ]; then
  14                 echo "Error: Supplied file doesn't exist!"
  15                 exit $E_CONFFILE     # 文件没发现错误.
  16               fi
  17               ;;
  18   esac
  19   shift       # 检查剩下的参数.
  20 done
  21 
  22 #  来自Stefano Falsetto的 "Log2Rot" 脚本,
  23 #+ 他的"rottlog" 包的一部分.
  24 #  已得到使用许可

例子 10-26. 使用命令替换来产生case变量

   1 #!/bin/bash
   2 # case-cmd.sh: 使用命令替换来产生"case"变量
   3 
   4 case $( arch ) in   # arch" 返回机器的类型.
   5                     # 等价于 'uname -m' ...
   6 i386 ) echo "80386-based machine";;
   7 i486 ) echo "80486-based machine";;
   8 i586 ) echo "Pentium-based machine";;
   9 i686 ) echo "Pentium2+-based machine";;
  10 *    ) echo "Other type of machine";;
  11 esac
  12 
  13 exit 0
case结构也可以过滤通配扩展（globbing）模式的字符串.

例子 10-27. 简单字符串匹配

   1 #!/bin/bash
   2 # match-string.sh: 简单字符串匹配
   3 
   4 match_string ()
   5 {
   6   MATCH=0
   7   NOMATCH=90
   8   PARAMS=2     # 函数需要2个参数.
   9   BAD_PARAMS=91
  10 
  11   [ $# -eq $PARAMS ] || return $BAD_PARAMS
  12 
  13   case "$1" in
  14   "$2") return $MATCH;;
  15   *   ) return $NOMATCH;;
  16   esac
  17 
  18 }  
  19 
  20 
  21 a=one
  22 b=two
  23 c=three
  24 d=two
  25 
  26 
  27 match_string $a     # 参数个数错误.
  28 echo $?             # 91
  29 
  30 match_string $a $b  # 不匹配
  31 echo $?             # 90
  32 
  33 match_string $b $d  # 匹配
  34 echo $?             # 0
  35 
  36 
  37 exit 0		    
例子 10-28. 检查是否是字母输入

   1 #!/bin/bash
   2 # isalpha.sh: 使用"case"结构来过滤字符串.
   3 
   4 SUCCESS=0
   5 FAILURE=-1
   6 
   7 isalpha ()  # 检查输入的*第一个字符*是不是字母表上的字符.
   8 {
   9 if [ -z "$1" ]                # 没有参数传进来?
  10 then
  11   return $FAILURE
  12 fi
  13 
  14 case "$1" in
  15 [a-zA-Z]*) return $SUCCESS;;  # 以一个字母开头?
  16 *        ) return $FAILURE;;
  17 esac
  18 }             # 同C语言的"isalpha()"函数相比较.
  19 
  20 
  21 isalpha2 ()   # 测试是否*整个字符串*为字母表字符.
  22 {
  23   [ $# -eq 1 ] || return $FAILURE
  24 
  25   case $1 in
  26   *[!a-zA-Z]*|"") return $FAILURE;;
  27                *) return $SUCCESS;;
  28   esac
  29 }
  30 
  31 isdigit ()    # 测试是否*整个字符串*都是数字.
  32 {             # 换句话说就是测试是否是整数变量.
  33   [ $# -eq 1 ] || return $FAILURE
  34 
  35   case $1 in
  36   *[!0-9]*|"") return $FAILURE;;
  37             *) return $SUCCESS;;
  38   esac
  39 }
  40 
  41 
  42 
  43 check_var ()  # 测试 isalpha ().
  44 {
  45 if isalpha "$@"
  46 then
  47   echo "\"$*\" begins with an alpha character."
  48   if isalpha2 "$@"
  49   then        # 不需要测试第一个字符是否是non-alpha.
  50     echo "\"$*\" contains only alpha characters."
  51   else
  52     echo "\"$*\" contains at least one non-alpha character."
  53   fi  
  54 else
  55   echo "\"$*\" begins with a non-alpha character."
  56               # 如果没有参数传递进来,也是"non-alpha".
  57 fi
  58 
  59 echo
  60 
  61 }
  62 
  63 digit_check ()  # 测试 isdigit ().
  64 {
  65 if isdigit "$@"
  66 then
  67   echo "\"$*\" contains only digits [0 - 9]."
  68 else
  69   echo "\"$*\" has at least one non-digit character."
  70 fi
  71 
  72 echo
  73 
  74 }
  75 
  76 a=23skidoo
  77 b=H3llo
  78 c=-What?
  79 d=What?
  80 e=`echo $b`   #命令替换.
  81 f=AbcDef
  82 g=27234
  83 h=27a34
  84 i=27.34
  85 
  86 check_var $a
  87 check_var $b
  88 check_var $c
  89 check_var $d
  90 check_var $e
  91 check_var $f
  92 check_var     # 没有参数传进来,将发生什么?
  93 #
  94 digit_check $g
  95 digit_check $h
  96 digit_check $i
  97 
  98 
  99 exit 0        # S.C改进过这个脚本.
 100 
 101 # 练习:
 102 # --------
 103 #  编写一个 'isfloat ()'函数来测试浮点数.
 104 #  暗示: 这个函数基本上与'isdigit ()'一样,
 105 #+ 但是要添加一部分小数点的处理.
select
select结构是建立菜单的另一种工具,这种结构是从ksh中引入的.

select variable [in list]
do 
?command... 
?break 
done

提示用户输入选择的内容(比如放在变量列表中).注意:select命令使用PS3提示符[默认为(#? )],但是可以修改PS3.

例子 10-29. 用select来创建菜单

   1 #!/bin/bash
   2 
   3 PS3='Choose your favorite vegetable: ' # 设置提示符字串.
   4 
   5 echo
   6 
   7 select vegetable in "beans" "carrots" "potatoes" "onions" "rutabagas"
   8 do
   9   echo
  10   echo "Your favorite veggie is $vegetable."
  11   echo "Yuck!"
  12   echo
  13   break  # 如果这里没有'break'会发生什么?
  14 done
  15 
  16 exit 0
如果忽略了in list列表,那么select命令将使用传递到脚本的命令行参数($@),或者是函数参数(当select是在函数中时）.

与忽略in list时的for语句相比较:

for variable [in list]

例子 10-30. 用函数中select结构来创建菜单

   1 #!/bin/bash
   2 
   3 PS3='Choose your favorite vegetable: '
   4 
   5 echo
   6 
   7 choice_of()
   8 {
   9 select vegetable
  10 # [in list] 被忽略, 所以'select'用传递给函数的参数.
  11 do
  12   echo
  13   echo "Your favorite veggie is $vegetable."
  14   echo "Yuck!"
  15   echo
  16   break
  17 done
  18 }
  19 
  20 choice_of beans rice carrots radishes tomatoes spinach
  21 #         $1    $2   $3      $4       $5       $6
  22 #         传递给choice_of() 函数的参数
  23 
  24 exit 0
  
  标准的 UNIX 命令使得 shell 脚本更加灵活.通过简单的编程结构把shell指令和系统命令结合起来,这才是脚本能力的所在.
  
  Example 12-1. 使用ls命令来创建一个烧录CDR的内容列表

   1 #!/bin/bash
   2 # ex40.sh (burn-cd.sh)
   3 # 自动刻录CDR的脚本.
   4 
   5 
   6 SPEED=2          # 如果你的硬件支持的话,你可以选用更高的速度.
   7 IMAGEFILE=cdimage.iso
   8 CONTENTSFILE=contents
   9 DEVICE=cdrom
  10 # DEVICE="0,0"     为了使用老版本的CDR
  11 DEFAULTDIR=/opt  # 这是包含需要被刻录内容的目录.
  12                  # 必须保证目录存在.
  13                  # 小练习: 测试一下目录是否存在.
  14 
  15 # Uses Joerg Schilling's "cdrecord" package:
  15 # 使用 Joerg Schilling 的 "cdrecord"包:
  16 # http://www.fokus.fhg.de/usr/schilling/cdrecord.html
  17 
  18 #  如果一般用户调用这个脚本的话,可能需要root身份
  19 #+ chmod u+s /usr/bin/cdrecord
  20 #  当然, 这会产生安全漏洞, 虽然这是一个比较小的安全漏洞.
  21 
  22 if [ -z "$1" ]
  23 then
  24   IMAGE_DIRECTORY=$DEFAULTDIR
  25   # 如果命令行没指定的话, 那么这个就是默认目录.
  26 else
  27     IMAGE_DIRECTORY=$1
  28 fi
  29 
  30 # 创建一个内容列表文件.
  31 ls -lRF $IMAGE_DIRECTORY > $IMAGE_DIRECTORY/$CONTENTSFILE
  32 #  "l" 选项将给出一个"长"文件列表.
  33 #  "R" 选项将使这个列表递归.
  34 #  "F" 选项将标记出文件类型 (比如: 目录是以 /结尾, 而可执行文件以 *结尾).
  35 echo "Creating table of contents."
  36 
  37 # 在烧录到CDR之前创建一个镜像文件.
  38 mkisofs -r -o $IMAGEFILE $IMAGE_DIRECTORY
  39 echo "Creating ISO9660 file system image ($IMAGEFILE)."
  40 
  41 # 烧录CDR.
  42 echo "Burning the disk."
  43 echo "Please be patient, this will take a while."
  44 cdrecord -v -isosize speed=$SPEED dev=$DEVICE $IMAGEFILE
  45 
  46 exit $?
  
  tac 命令, 就是 cat的反转, 将从文件的结尾列出文件.
  
  rev
把每一行中的内容反转, 并且输出到 stdout上. 这个命令与 tac命令的效果是不同的, 因为它并不反转行序, 而是把每行的内容反转.

 bash$ cat file1.txt
 This is line 1.
 This is line 2.
 
 
 bash$ tac file1.txt
 This is line 2.
 This is line 1.
 
 
 bash$ rev file1.txt
 .1 enil si sihT
 .2 enil si sihT
 	      
 	      特别有用的选项就是 -a 归档 选项 (为了copy一个完整的目录树),	-u 是更新选项, 和 -r 与 -R 递归选项.

   1 cp -u source_dir/* dest_dir
   2 #  "Synchronize" dest_dir to source_dir把源目录"同步"到目标目录上,
   3 #+  也就是拷贝所有更新的文件和之前不存在的文件.
   
   当使用非交互脚本时,可以使用 mv 的-f (强制) 选项来避免用户的输入.

当一个目录被移动到一个已存在的目录时,那么它将成为目标目录的子目录.

 bash$ mv source_directory target_directory
 
 bash$ ls -lF target_directory
 total 1
 drwxrwxr-x    2 bozo  bozo      1024 May 28 19:20 source_directory/
 
 除(清除)一个或多个文件. -f 选项将强制删除文件,即使这个文件是只读的.并且可以用来避免用户输入(在非交互脚本中使用).

	
rm 将无法删除以破折号开头的文件.

 bash$ rm -badname
 rm: invalid option -- b
 Try `rm --help' for more information.
解决这个问题的一个方法就是在要删除的文件的前边加上"./".
 bash$ rm ./-badname
另一种解决的方法是 在文件名前边加上 " -- ".
 bash$ rm -- -badname
	
当使用递归参数 -r时, rm 命令将会删除整个目录树. 如果不慎使用 rm -rf *那整个目录树就真的完了.

mkdir
生成目录, 创建一个空目录. 比如, mkdir -p project/programs/December 将会创建出这个指定的目录, 即使project目录和programs目录都不存在. -p 选项将会自动产生必要的父目录, 这样也就同时创建了多个目录.

Example 12-2. Hello or Good-bye

   1 #!/bin/bash
   2 # hello.sh: 显示"hello" 还是 "goodbye"
   3 #+          依赖于脚本是如何被调用的.
   4 
   5 # 在当前目录下($PWD)为这个脚本创建一个链接:
   6 #    ln -s hello.sh goodbye
   7 # 现在, 通过如下两种方法来调用这个脚本:
   8 # ./hello.sh
   9 # ./goodbye
  10 
  11 
  12 HELLO_CALL=65
  13 GOODBYE_CALL=66
  14 
  15 if [ $0 = "./goodbye" ]
  16 then
  17   echo "Good-bye!"
  18   # 当然, 在这里你也可以添加一些其他的 goodbye类型的命令.Some other goodbye-type commands, as appropriate.
  19   exit $GOODBYE_CALL
  20 fi
  21 
  22 echo "Hello!"
  23 # 当然, 在这里你也可以添加一些其他的 hello类型的命令.
  24 exit $HELLO_CALL
  
  如果 COMMAND 中包含 {}, 那么 find 命令将会用所有匹配文件的路径名来替换 "{}" .

   1 find ~/ -name 'core*' -exec rm {} \;
   2 # 从用户的 home 目录中删除所有的 core dump文件.
   1 find /home/bozo/projects -mtime 1
   2 #  列出最后一天被修改的
   3 #+ 在/home/bozo/projects目录树下的所有文件.
   4 #
   5 #  mtime = last modification time of the target file
   6 #  ctime = last status change time (via 'chmod' or otherwise)
   7 #  atime = last access time
   8 
   9 DIR=/home/bozo/junk_files
  10 find "$DIR" -type f -atime +5 -exec rm {} \;
  11 #                                      ^^
  12 #  大括号就是"find"命令用来替换目录的地方.
  13 #
  14 #  删除至少5天内没被存取过的
  15 #+ "/home/bozo/junk_files" 中的所有文件.
  16 #
  17 #  "-type filetype", where
  18 #  f = regular file
  19 #  d = directory, etc.
  20 #  ('find' 命令的 man页有完整的选项列表.)
   1 find /etc -exec grep '[0-9][0-9]*[.][0-9][0-9]*[.][0-9][0-9]*[.][0-9][0-9]*' {} \;
   2 
   3 # 在/etc 目录中的文件找到所所有包含 IP 地址(xxx.xxx.xxx.xxx) 的文件.
   4 # 可能会查找到一些多余的匹配. 我们如何去掉它们呢?
   5 
   6 # 或许可以使用如下方法:
   7 
   8 find /etc -type f -exec cat '{}' \; | tr -c '.[:digit:]' '\n' \
   9 | grep '^[^.][^.]*\.[^.][^.]*\.[^.][^.]*\.[^.][^.]*$'
  10 #
  11 #  [:digit:] 是一种字符类.is one of the character classes
  12 #+ 关于字符类的介绍见 POSIX 1003.2 标准化文档. 
  13 
  14 # Thanks, Stéphane Chazelas. 

	
find 命令的 -exec 选项不应该与shell中的内建命令 exec 相混淆.

Example 12-3. 删除当前目录下文件名中包含一些特殊字符(包括空白)的文件..

   1 #!/bin/bash
   2 # badname.sh
   3 # 删除当前目录下文件名中包含一些特殊字符的文件.
   4 
   5 for filename in *
   6 do
   7   badname=`echo "$filename" | sed -n /[\+\{\;\"\\\=\?~\(\)\<\>\&\*\|\$]/p`
   8 # badname=`echo "$filename" | sed -n '/[+{;"\=?~()<>&*|$]/p'`  这句也行.
   9 # 删除文件名包含这些字符的文件:     + { ; " \ = ? ~ ( ) < > & * | $
  10 #
  11   rm $badname 2>/dev/null
  12 #             ^^^^^^^^^^^ 错误消息将被抛弃.
  13 done
  14 
  15 # 现在, 处理文件名中以任何方式包含空白的文件.
  16 find . -name "* *" -exec rm -f {} \;
  17 # "find"命令匹配到的目录名将替换到{}的位置.
  18 # '\' 是为了保证 ';'被正确的转义, 并且放到命令的结尾.
  19 
  20 exit 0
  21 
  22 #---------------------------------------------------------------------
  23 # 这行下边的命令将不会运行, 因为 "exit" 命令.
  24 
  25 # 这句是上边脚本的一个可选方法:
  26 find . -name '*[+{;"\\=?~()<>&*|$ ]*' -exec rm -f '{}' \;
  27 # (Thanks, S.C.)
Example 12-4. 通过文件的 inode 号来删除文件

   1 #!/bin/bash
   2 # idelete.sh: 通过文件的inode号来删除文件.
   3 
   4 #  当文件名以一个非法字符开头的时候, 这就非常有用了,
   5 #+ 比如 ? 或 -.
   6 
   7 ARGCOUNT=1                      # 文件名参数必须被传递到脚本中.
   8 E_WRONGARGS=70
   9 E_FILE_NOT_EXIST=71
  10 E_CHANGED_MIND=72
  11 
  12 if [ $# -ne "$ARGCOUNT" ]
  13 then
  14   echo "Usage: `basename $0` filename"
  15   exit $E_WRONGARGS
  16 fi  
  17 
  18 if [ ! -e "$1" ]
  19 then
  20   echo "File \""$1"\" does not exist."
  21   exit $E_FILE_NOT_EXIST
  22 fi  
  23 
  24 inum=`ls -i | grep "$1" | awk '{print $1}'`
  25 # inum = inode (索引节点) 号.
  26 # --------------------------------------------------------
  27 # 每个文件都有一个inode号, 这个号用来记录文件物理地址信息.
  28 # --------------------------------------------------------
  29 
  30 echo; echo -n "Are you absolutely sure you want to delete \"$1\" (y/n)? "
  31 # 'rm' 命令的 '-v' 选项也会问这句话.
  32 read answer
  33 case "$answer" in
  34 [nN]) echo "Changed your mind, huh?"
  35       exit $E_CHANGED_MIND
  36       ;;
  37 *)    echo "Deleting file \"$1\".";;
  38 esac
  39 
  40 find . -inum $inum -exec rm {} \;
  41 #                           ^^
  42 #        大括号就是"find"命令
  43 #+       用来替换文本输出的地方.
  44 echo "File "\"$1"\" deleted!"
  45 
  46 exit 0


Example 12-6. 把当前目录下的文件拷贝到另一个文件中

   1 #!/bin/bash
   2 # copydir.sh
   3 
   4 #  拷贝 (verbose) 当前目录($PWD)下的所有文件到
   5 #+ 命令行中指定的另一个目录下.
   6 
   7 E_NOARGS=65
   8 
   9 if [ -z "$1" ]   # 如果没有参数传递进来那就退出.
  10 then
  11   echo "Usage: `basename $0` directory-to-copy-to"
  12   exit $E_NOARGS
  13 fi  
  14 
  15 ls . | xargs -i -t cp ./{} $1
  16 #            ^^ ^^      ^^
  17 #  -t 是 "verbose" (输出命令行到stderr) 选项.
  18 #  -i 是"替换字符串"选项.
  19 #  {} 是输出文本的替换点.
  20 #  这与在"find"命令中使用{}的情况很相像.
  21 #
  22 #  列出当前目录下的所有文件(ls .),
  23 #+ 将 "ls" 的输出作为参数传递到 "xargs"(-i -t 选项) 中,
  24 #+ 然后拷贝(cp)这些参数({})到一个新目录中($1).
  25 #
  26 #  最终的结果和下边的命令等价,
  27 #+   cp * $1
  28 #+ 除非有文件名中嵌入了"空白"字符.
  29 
  30 exit 0
  
  Example 12-7. 通过名字Kill进程

   1 #!/bin/bash
   2 # kill-byname.sh: 通过名字kill进程.
   3 # 与脚本kill-process.sh相比较.
   4 
   5 #  例如,
   6 #+ 试一下 "./kill-byname.sh xterm" --
   7 #+ 并且查看你系统上的所有xterm都将消失.
   8 
   9 #  警告:
  10 #  -----
  11 #  这是一个非常危险的脚本.
  12 #  运行它的时候一定要小心. (尤其是以root身份运行时)
  13 #+ 因为运行这个脚本可能会引起数据丢失或产生其他一些不好的效果.
  14 
  15 E_BADARGS=66
  16 
  17 if test -z "$1"  # 没有参数传递进来?
  18 then
  19   echo "Usage: `basename $0` Process(es)_to_kill"
  20   exit $E_BADARGS
  21 fi
  22 
  23 
  24 PROCESS_NAME="$1"
  25 ps ax | grep "$PROCESS_NAME" | awk '{print $1}' | xargs -i kill {} 2&>/dev/null
  26 #                                                       ^^      ^^
  27 
  28 # -----------------------------------------------------------
  29 # 注意:
  30 # -i 参数是xargs命令的"替换字符串"选项.
  31 # 大括号对的地方就是替换点.
  32 # 2&>/dev/null 将会丢弃不需要的错误消息.
  33 # -----------------------------------------------------------
  34 
  35 exit $?
Example 12-8. 使用xargs分析单词出现的频率

   1 #!/bin/bash
   2 # wf2.sh: Crude word frequency analysis on a text file.
   3 
   4 # 使用 'xargs' 将文本行分解为单词.
   5 # 于后边的 "wf.sh" 脚本相比较.
   6 
   7 
   8 # 检查命令行上输入的文件.
   9 ARGS=1
  10 E_BADARGS=65
  11 E_NOFILE=66
  12 
  13 if [ $# -ne "$ARGS" ]
  14 # 纠正传递到脚本中的参数个数?
  15 then
  16   echo "Usage: `basename $0` filename"
  17   exit $E_BADARGS
  18 fi
  19 
  20 if [ ! -f "$1" ]       # 检查文件是否存在.
  21 then
  22   echo "File \"$1\" does not exist."
  23   exit $E_NOFILE
  24 fi
  25 
  26 
  27 
  28 #################################################################
  29 cat "$1" | xargs -n1 | \
  30 #  列出文件, 每行一个单词.
  31 tr A-Z a-z | \
  32 #  将字符转换为小写.
  33 sed -e 's/\.//g'  -e 's/\,//g' -e 's/ /\
  34 /g' | \
  35 #  过滤掉句号和逗号,
  36 #+ 并且将单词间的空格修改为换行,
  37 sort | uniq -c | sort -nr
  38 #  最后统计出现次数,把数字显示在第一列,然后显示单词,并按数字排序.
  39 #################################################################
  40 
  41 #  这个例子的作用与"wf.sh"的作用是一样的,
  42 #+ 但是这个例子比较臃肿, 并且运行起来更慢一些(为什么?).
  43 
  44 exit 0
  
  Example 12-9. 使用 expr

   1 #!/bin/bash
   2 
   3 # 展示一些 'expr'的使用
   4 # =====================
   5 
   6 echo
   7 
   8 # 算术 操作
   9 # ---- ----
  10 
  11 echo "Arithmetic Operators"
  12 echo
  13 a=`expr 5 + 3`
  14 echo "5 + 3 = $a"
  15 
  16 a=`expr $a + 1`
  17 echo
  18 echo "a + 1 = $a"
  19 echo "(incrementing a variable)"
  20 
  21 a=`expr 5 % 3`
  22 # 取模操作
  23 echo
  24 echo "5 mod 3 = $a"
  25 
  26 echo
  27 echo
  28 
  29 # 逻辑 操作
  30 # ---- ----
  31 
  32 #  true返回 1 ,false 返回 0 ,
  33 #+ 而Bash的使用惯例则相反.
  34 
  35 echo "Logical Operators"
  36 echo
  37 
  38 x=24
  39 y=25
  40 b=`expr $x = $y`         # 测试相等.
  41 echo "b = $b"            # 0  ( $x -ne $y )
  42 echo
  43 
  44 a=3
  45 b=`expr $a \> 10`
  46 echo 'b=`expr $a \> 10`, therefore...'
  47 echo "If a > 10, b = 0 (false)"
  48 echo "b = $b"            # 0  ( 3 ! -gt 10 )
  49 echo
  50 
  51 b=`expr $a \< 10`
  52 echo "If a < 10, b = 1 (true)"
  53 echo "b = $b"            # 1  ( 3 -lt 10 )
  54 echo
  55 # Note escaping of operators.
  56 
  57 b=`expr $a \<= 3`
  58 echo "If a <= 3, b = 1 (true)"
  59 echo "b = $b"            # 1  ( 3 -le 3 )
  60 # 也有 "\>=" 操作 (大于等于).
  61 
  62 
  63 echo
  64 echo
  65 
  66 
  67 
  68 # 字符串 操作
  69 # ------ ----
  70 
  71 echo "String Operators"
  72 echo
  73 
  74 a=1234zipper43231
  75 echo "The string being operated upon is \"$a\"."
  76 
  77 # 长度: 字符串长度
  78 b=`expr length $a`
  79 echo "Length of \"$a\" is $b."
  80 
  81 # 索引: 从字符串的开头查找匹配的子串,
  82 #       并取得第一个匹配子串的位置.
  83 b=`expr index $a 23`
  84 echo "Numerical position of first \"2\" in \"$a\" is \"$b\"."
  85 
  86 # substr: 从指定位置提取指定长度的字串.
  87 b=`expr substr $a 2 6`
  88 echo "Substring of \"$a\", starting at position 2,\
  89 and 6 chars long is \"$b\"."
  90 
  91 
  92 #  'match' 操作的默认行为就是
  93 #+ 从字符串的开始进行搜索,并匹配第一个匹配的字符串.
  94 #
  95 #        使用正则表达式
  96 b=`expr match "$a" '[0-9]*'`               #  数字的个数.
  97 echo Number of digits at the beginning of \"$a\" is $b.
  98 b=`expr match "$a" '\([0-9]*\)'`           #  注意需要转义括号
  99 #                   ==      ==              + 这样才能触发子串的匹配.
 100 echo "The digits at the beginning of \"$a\" are \"$b\"."
 101 
 102 echo
 103 
 104 exit 0
 
 Example 12-10. 使用 date 命令

   1 #!/bin/bash
   2 # 练习 'date' 命令
   3 
   4 echo "The number of days since the year's beginning is `date +%j`."
   5 # 需要在调用格式的前边加上一个 '+' 号.
   6 # %j 给出今天是本年度的第几天.
   7 
   8 echo "The number of seconds elapsed since 01/01/1970 is `date +%s`."
   9 #  %s 将产生从 "UNIX 元年" 到现在为止的秒数,yields number of seconds since "UNIX epoch" began,
  10 #+ 但是这东西有用么?
  11 
  12 prefix=temp
  13 suffix=$(date +%s)  # 'date'命令的 "+%s" 选项是 GNU-特性.
  14 filename=$prefix.$suffix
  15 echo $filename
  16 #  这是一种非常好的产生 "唯一" 的临时文件的办法,
  17 #+ 甚至比使用 $$ 都强.
  18 
  19 # 如果想了解 'date' 命令的更多选项, 请查阅这个命令的 man 页.
  20 
  21 exit 0
-u 选项将给出 UTC 时间(Universal Coordinated Time).

 bash$ date
 Fri Mar 29 21:07:39 MST 2002
 
 
 
 bash$ date -u
 Sat Mar 30 04:07:42 UTC 2002
 	      

date 命令有许多的输出选项. 比如 %N 将以10亿分之一为单位表示当前时间. 这个选项的一个有趣的用法就是用来产生一个6位的随机数.
   1 date +%N | sed -e 's/000$//' -e 's/^0//'
   2            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   3 # 去掉开头和结尾的0.
当然,还有许多其它的选项 (请查看 man date).
   1 date +%j
   2 # 显示今天是本年度的第几天(从1月1日开始计算).
   3 
   4 date +%k%M
   5 # 显示当前小时数和分钟数.
   6 
   7 
   8 
   9 #  'TZ' 参数允许改变当前的默认时区.
  10 date                 # Mon Mar 28 21:42:16 MST 2005
  11 TZ=EST date          # Mon Mar 28 23:42:16 EST 2005
  12 # Thanks, Frank Kannemann and Pete Sjoberg, for the tip.
  13 
  14 
  15 SixDaysAgo=$(date --date='6 days ago')
  16 OneMonthAgo=$(date --date='1 month ago')  # 4周前(不是一个月).
  17 OneYearAgo=$(date --date='1 year ago')

参见 Example 3-4.

zdump
查看特定时区的当前时间.

 bash$ zdump EST
 EST  Tue Sep 18 22:09:22 2001 EST
 	      
time
输出统计出来的命令执行的时间.

time ls -l / 给出的输出大概是如下格式:
 0.00user 0.01system 0:00.05elapsed 16%CPU (0avgtext+0avgdata 0maxresident)k
 0inputs+0outputs (149major+27minor)pagefaults 0swaps
参见前边章节所讲的一个类似的命令 times .

	
在Bash的 2.0版本 中, time 成为了shell的一个保留字, 并且在一个带有管道的命令行中,这个命令的行为有些小的变化.

at 命令是一个作业控制命令, 用来在指定时间执行给定的命令集合.它有点像 cron 命令, 然而, at 命令主要还是用来执行那种一次性执行的命令集合.

at 2pm January 15 将会提示让你输入需要在这个时间你要执行的命令序列. 这些命令应该是可以和shell脚本兼容的,因为, 实际上, 在一个可执行的脚本中, 用户每次只能敲一行. 输入以 Ctl-D 结束.

你可以使用-f选项或者使用 (<)重定向操作符, 来让 at 命令从一个文件中读取命令集合. 这个文件其实就一个可执行的的脚本, 虽然它是一个不可交互的脚本. 在文件中包含一个 run-parts 命令, 对于执行一套不同的脚本来说是非常聪明的做法.

 bash$ at 2:30 am Friday < at-jobs.list
 job 2 at 2000-10-27 02:30
 	      
 	      
 	      一个从文件中提取特定域的工具. 这个命令与 awk 中使用的 print $N命令很相似, 但是更受限. 在脚本中使用cut命令会比使用 awk 命令来得容易一些. 最重要的选项就是 -d (字段定界符) 和 -f (域分隔符) 选项.

使用 cut 来获得所有mount上的文件系统的列表:
   1 cut -d ' ' -f1,2 /etc/mtab

使用 cut 命令列出 OS 和 kernel的版本:
   1 uname -a | cut -d" " -f1,3,11,12

使用 cut 命令从 e-mail 中提取消息头:
 bash$ grep '^Subject:' read-messages | cut -c10-80
 Re: Linux suitable for mission-critical apps?
 MAKE MILLIONS WORKING AT HOME!!!
 Spam complaint
 Re: Spam complaint
使用 cut 命令来分析一个文件:
   1 # 列出所有在/etc/passwd中的用户.
   2 
   3 FILENAME=/etc/passwd
   4 
   5 for user in $(cut -d: -f1 $FILENAME)
   6 do
   7   echo $user
   8 done
   9 
  10 # Thanks, Oleg Philon for suggesting this.

cut -d ' ' -f2,3 filename 等价于 awk -F'[ ]' '{ print $2, $3 }' filename

	
你甚至可以指定换行符作为字段定界符. 这个小伎俩实际上就是在命令行上插入一个换行(RETURN).(译者: linux使用lf作为换行符的).

 bash$ cut -d'
 ' -f3,7,19 testfile
 This is line 3 of testfile.
 This is line 7 of testfile.
 This is line 19 of testfile.
 
 Example 12-12. 那个文件是脚本?

   1 #!/bin/bash
   2 # script-detector.sh: 在一个目录中检查所有的脚本文件.
   3 
   4 TESTCHARS=2    # 测试前两个字节.
   5 SHABANG='#!'   # 脚本都是以 "sha-bang." 开头的.
   6 
   7 for file in *  # 遍历当前目录下的所有文件.
   8 do
   9   if [[ `head -c$TESTCHARS "$file"` = "$SHABANG" ]]
  10   #      head -c2                      #!
  11   #  '-c' 选项将从文件头输出指定个数的字符,
  12   #+ 而不是默认的行数.
  13   then
  14     echo "File \"$file\" is a script."
  15   else
  16     echo "File \"$file\" is *not* a script."
  17   fi
  18 done
  19   
  20 exit 0
  21 
  22 #  练习:
  23 #  -----
  24 #  1) 将这个脚本修改为可以指定目录
  25 #+    来扫描目录下的脚本.
  26 #+    (而不是只搜索当前目录).
  27 #
  28 #  2) 就目前看来, 这个脚本将不能正确识别出
  29 #+    Perl, awk, 和其他一些脚本语言的脚本文件.
  30 #     修正这个问题.
Example 12-13. 产生10进制随机数

   1 #!/bin/bash
   2 # rnd.sh: 输出一个10进制随机数
   3 
   4 # Script by Stephane Chazelas.
   5 
   6 head -c4 /dev/urandom | od -N4 -tu4 | sed -ne '1s/.* //p'
   7 
   8 
   9 # =================================================================== #
  10 
  11 # 分析
  12 # ----
  13 
  14 # head:
  15 # -c4 选项将取得前4个字节.
  16 
  17 # od:
  18 # -N4 选项将限制输出为4个字节.
  19 # -tu4 选项将使用无符号10进制格式来输出.
  20 
  21 # sed: 
  22 # -n 选项, 使用 "s" 命令与 "p" 标志组合的方式,
  23 # 将会只输出匹配的行.
  24 
  25 
  26 
  27 # 本脚本作者解释 'sed' 命令的行为如下.
  28 
  29 # head -c4 /dev/urandom | od -N4 -tu4 | sed -ne '1s/.* //p'
  30 # ----------------------------------> |
  31 
  32 # 假设一直处理到 "sed"命令时的输出--> |
  33 # 为 0000000 1198195154\n
  34 
  35 #  sed 命令开始读取字串: 0000000 1198195154\n.
  36 #  这里它发现一个换行符,
  37 #+ 所以 sed 准备处理第一行 (0000000 1198195154).
  38 #  sed命令开始匹配它的 <range> 和 <action>. 第一个匹配的并且只有这一个匹配的:
  39 
  40 #   range     action
  41 #   1         s/.* //p
  42 
  43 #  因为行号在range中, 所以 sed 开始执行 action:
  44 #+ 替换掉以空格结束的最长的字符串, 在这行中这个字符串是
  45 #  ("0000000 ") ,用空字符串(//)将这个匹配到的字串替换掉, 如果成功, 那就打印出结果
  46 #  ("p" 在这里是 "s" 命令的标志, 这与单独的 "p" 命令是不同的).
  47 
  48 #  sed 命令现在开始继续读取输入. (注意在继续之前, 
  49 #+ continuing, 如果没使用 -n 选项的话, sed 命令将再次
  50 #+ 将这行打印一遍).
  51 
  52 # 现在, sed 命令读取剩余的字符串, 并且找到文件的结尾.
  53 # sed 命令开始处理第2行(这行也被标记为 '$'
  54 # 因为这已经是最后一行).
  55 # 所以这行没被匹配到 <range> 中, 这样sed命令就结束了.
  56 
  57 #  这个 sed 命令的简短的解释是:
  58 #  "在第一行中删除第一个空格左边全部的字符,
  59 #+ 然后打印出来."
  60 
  61 # 一个更好的来达到这个目的的方法是:
  62 #           sed -e 's/.* //;q'
  63 
  64 # 这里, <range> 和 <action> 分别是 (也可以写成
  65 #           sed -e 's/.* //' -e q):
  66 
  67 #   range                    action
  68 #   nothing (matches line)   s/.* //
  69 #   nothing (matches line)   q (quit)
  70 
  71 #  这里, sed 命令只会读取第一行的输入.
  72 #  将会执行2个命令, 并且会在退出之前打印出(已经替换过的)这行(因为 "q" action),
  73 #+ 因为没使用 "-n" 选项.
  74 
  75 # =================================================================== #
  76 
  77 # 也可以使用如下一个更简单的语句来代替:
  78 #           head -c4 /dev/urandom| od -An -tu4
  79 
  80 exit 0
  
  为了列出一个文本文件中的指定行数, 可以将 head 命令的输出通过 管道 传递到 tail -1 中 . 比如 head -8 database.txt | tail -1 将会列出 database.txt 文件的第8行.

下边是将一个文本文件中指定范围的所有行都保存到一个变量中:
   1 var=$(head -$m $filename | tail -$n)
   2 
   3 # filename = 文件名
   4 # m = 从文件开头到想取得的指定范围的行数的最后一行
   5 # n = 取得指定范围的行数 (从块结尾开始截断)
   
   wc
wc 可以统计文件或 I/O 流中的单词数量.
 bash $ wc /usr/share/doc/sed-4.1.2/README
 13  70  447 README
 [13 lines  70 words  447 characters]

wc -w 统计单词数量.

wc -l 统计行数量.

wc -c 统计字节数量.

wc -m 统计字符数量.

wc -L 给出文件中最长行的长度.

使用 wc 命令来统计当前工作目录下有多少个 .txt 文件.
   1 $ ls *.txt | wc -l
   2 # 因为列出的文件名都是以换行符区分的,所以使用 -l 来统计.
   3 
   4 # 另一种达到这个目的的方法:
   5 #      find . -maxdepth 1 -name \*.txt -print0 | grep -cz .
   6 #      (shopt -s nullglob; set -- *.txt; echo $#)
   7 
   8 # Thanks, S.C.
使用 wc 命令来统计所有以 d - h 开头的文件的大小.
 bash$ wc [d-h]* | grep total | awk '{print $3}'
 71832
 	      
使用 wc 命令来查看指定文件中包含 "Linux" 的行一共有多少.
 bash$ grep Linux abs-book.sgml | wc -l
 50
 	      
参见 Example 12-35 和 Example 16-8.

某些命令的某些选项其实已经包含了 wc 命令的部分功能.
   1 ... | grep foo | wc -l
   2 # 这个命令使用得非常频繁, 但事实上它有更简便的写法.
   3 
   4 ... | grep -c foo
   5 # 只要使用 grep 命令的 "-c" (或 "--count")选项就能达到同样的目的.
   6 
   7 # Thanks, S.C.
   
   Example 12-18. 转换大写: 把一个文件的内容全部转换为大写.

   1 #!/bin/bash
   2 # 把一个文件的内容全部转换为大写.
   3 
   4 E_BADARGS=65
   5 
   6 if [ -z "$1" ]  # 检查命令行参数.
   7 then
   8   echo "Usage: `basename $0` filename"
   9   exit $E_BADARGS
  10 fi  
  11 
  12 tr a-z A-Z <"$1"
  13 
  14 # 与上边的作用相同, 但是使用了 POSIX 字符集标记方法:
  15 #        tr '[:lower:]' '[:upper:]' <"$1"
  16 # Thanks, S.C.
  17 
  18 exit 0
  19 
  20 #  练习:
  21 #  重写这个脚本, 通过选项可以控制脚本或者
  22 #+ 转换为大写或者转换为小写.
Example 12-19. 转换小写: 将当前目录下的所有文全部转换为小写.

   1 #!/bin/bash
   2 #
   3 #  将当前目录下的所有文全部转换为小写.
   4 #
   5 #  灵感来自于 John Dubois 的脚本,
   6 #+ 转换为 Bash 脚本,
   7 #+ 然后被本书作者精简了一下.
   8 
   9 
  10 for filename in *                # 遍历当前目录下的所有文件.
  11 do
  12    fname=`basename $filename`
  13    n=`echo $fname | tr A-Z a-z`  # 将名字修改为小写.
  14    if [ "$fname" != "$n" ]       # 只对那些文件名不是小写的文件进行重命名.
  15    then
  16      mv $fname $n
  17    fi  
  18 done   
  19 
  20 exit $?
  21 
  22 
  23 # 下边的代码将不会被执行, 因为上边的 "exit".
  24 #-------------------------------------------#
  25 # 删除上边的内容,来运行下边的内容.
  26 
  27 # 对于那些文件名中包含空白和新行的文件, 上边的脚本就不能工作了.
  28 # Stephane Chazelas 因此建议使用下边的方法:
  29 
  30 
  31 for filename in *    # 不必非得使用 basename 命令,
  32                      # 因为 "*" 不会返回任何包含 "/" 的文件.
  33 do n=`echo "$filename/" | tr '[:upper:]' '[:lower:]'`
  34 #                             POSIX 字符集标记法.
  35 #                    添加的斜线是为了在文件名结尾换行不会被
  36 #                    命令替换删掉.
  37    # 变量替换:
  38    n=${n%/}          # 从文件名中将上边添加在结尾的斜线删除掉.
  39    [[ $filename == $n ]] || mv "$filename" "$n"
  40                      # 检查文件名是否已经是小写.
  41 done
  42 
  43 exit $?
Example 12-20. Du: DOS 到 UNIX 文本文件的转换.

   1 #!/bin/bash
   2 # Du.sh: DOS 到 UNIX 文本文件的转换.
   3 
   4 E_WRONGARGS=65
   5 
   6 if [ -z "$1" ]
   7 then
   8   echo "Usage: `basename $0` filename-to-convert"
   9   exit $E_WRONGARGS
  10 fi
  11 
  12 NEWFILENAME=$1.unx
  13 
  14 CR='\015'  # 回车Carriage return.
  15            # 015 是 8 进制的 ASCII 码的回车.
  16            # DOS 中文本文件的行结束符是 CR-LF.
  17            # UNIX 中文本文件的行结束符只是 LF.
  18 
  19 tr -d $CR < $1 > $NEWFILENAME
  20 # 删除回车并且写到新文件中.
  21 
  22 echo "Original DOS text file is \"$1\"."
  23 echo "Converted UNIX text file is \"$NEWFILENAME\"."
  24 
  25 exit 0
  26 
  27 # 练习:
  28 # -----
  29 # 修改上边的脚本完成从UNIX 到 DOS 的转换.
Example 12-21. rot13: rot13, 弱智加密.

   1 #!/bin/bash
   2 # rot13.sh: 典型的 rot13 算法,
   3 #           使用这种方法加密可能可以愚弄一下3岁小孩.
   4 
   5 # 用法: ./rot13.sh filename
   6 # 或    ./rot13.sh <filename
   7 # 或    ./rot13.sh and supply keyboard input (stdin)
   8 
   9 cat "$@" | tr 'a-zA-Z' 'n-za-mN-ZA-M'   # "a" 变为 "n", "b" 变为 "o", 等等.
  10 #  'cat "$@"' 结构
  11 #+ 允许从stdin或者从文件中获得输入.
  12 
  13 exit 0
Example 12-22. Generating "Crypto-Quote" Puzzles

   1 #!/bin/bash
   2 # crypto-quote.sh: 加密
   3 
   4 #  使用单码替换(单一字母替换法)来进行加密.
   5 #  The result is similar to the "Crypto Quote" puzzles
   6 #+ seen in the Op Ed pages of the Sunday paper. <rojy bug>(不太了解这句的内容, 应该是有特定的含义)
   7 
   8 
   9 key=ETAOINSHRDLUBCFGJMQPVWZYXK
  10 # "key" 不过是一个乱序的字母表.
  11 # 修改 "key" 就会修改加密的结果.
  12 
  13 # The 'cat "$@"' construction gets input either from stdin or from files.
  14 # 如果使用stdin, 那么要想结束输入就使用 Control-D.
  15 # 否则就要在命令行上指定文件名.
  16 
  17 cat "$@" | tr "a-z" "A-Z" | tr "A-Z" "$key"
  18 #        |   转化为大写   |     加密
  19 # 小写, 大写, 或混合大小写, 都可以正常工作.
  20 # 但是传递进来的非字母字符将不会起任何变化.
  21 
  22 
  23 # 用下边的语句试试这个脚本:
  24 # "Nothing so needs reforming as other people's habits."
  25 # --Mark Twain
  26 #
  27 # 输出为:
  28 # "CFPHRCS QF CIIOQ MINFMBRCS EQ FPHIM GIFGUI'Q HETRPQ."
  29 # --BEML PZERC
  30 
  31 # 解密:
  32 # cat "$@" | tr "$key" "A-Z"
  33 
  34 
  35 #  这个简单的密码可以轻易的被一个12岁的小孩
  36 #+ 用铅笔和纸破解.
  37 
  38 exit 0
  39 
  40 #  练习:
  41 #  -----
  42 #  修改这个脚本, 让它可以用命令行参数
  43 #+ 来决定加密或解密.
 
tr 的不同版本

tr 工具在历史上有2个重要版本. BSD 版本不需要使用中括号 (tr a-z A-Z), 但是 SysV 版本则需要中括号 (tr '[a-z]' '[A-Z]'). GNU 版本的 tr 命令与 BSD 版本比较相像, 所以使用中括号来引用字符范围是强制性的(译者: 感觉这句说反了, 读者可自行参照原文).

nl 命令的输出与 cat -n 非常相似, 然而, 默认情况下 nl 不会列出空行.

Example 12-25. nl: 一个自己计算行号的脚本.

   1 #!/bin/bash
   2 # line-number.sh
   3 
   4 # 这个脚本将会 echo 自身两次, 并显示行号.
   5 
   6 # 'nl' 命令显示的时候你将会看到, 本行是第4行, 因为它不计空行.
   7 # 'cat -n' 命令显示的时候你将会看到, 本行是第6行.
   8 
   9 nl `basename $0`
  10 
  11 echo; echo  # 下边, 让我们试试 'cat -n'
  12 
  13 cat -n `basename $0`
  14 # 区别就是 'cat -n' 对空行也进行计数.
  15 # 注意 'nl -ba' 也会这么做.
  16 
  17 exit 0
  
  whatis filexxx 将会在 whatis 数据库中查询 "filexxx". 当你想确认系统命令和重要的配置文件的时候, 这个命令就非常重要了. 可以把这个命令认为是一个简单的 man 命令.

$bash whatis whatis
 whatis               (1)  - search the whatis database for complete words
Example 12-30. Exploring /usr/X11R6/bin

   1 #!/bin/bash
   2 
   3 # 在 /usr/X11R6/bin 中的所有神秘的2进制文件都是什么东西?
   4 
   5 DIRECTORY="/usr/X11R6/bin"
   6 # 也试试 "/bin", "/usr/bin", "/usr/local/bin", 等等.
   7 
   8 for file in $DIRECTORY/*
   9 do
  10   whatis `basename $file`   # 将会 echo 出这个2进制文件的信息.
  11 done
  12 
  13 exit 0
  14 
  15 # 你可能希望将这个脚本的输出重定向, 像这样:
  16 # ./what.sh >>whatis.db
  17 # 或者一页一页的在 stdout 上查看,
  18 # ./what.sh | less
  
  readlink
显示符号连接所指向的文件.

 bash$ readlink /usr/bin/awk
 ../../bin/gawk
 
 使用一个"唯一"的文件名来创建一个 临时文件 [4] . 如果不带参数的在命令行下调用这个命令时, 将会在 /tmp 目录下产生一个零长度的文件.

 bash$ mktemp
 /tmp/tmp.zzsvql3154
 	      
   1 PREFIX=filename
   2 tempfile=`mktemp $PREFIX.XXXXXX`
   3 #                        ^^^^^^ 在这个临时的文件名中
   4 #+                              至少需要6个占位符.
   5 #  如果没有指定临时文件的文件名,
   6 #+ 那么默认就是 "tmp.XXXXXXXXXX".
   7 
   8 echo "tempfile name = $tempfile"
   9 # tempfile name = filename.QA2ZpY
  10 #                 或者一些其他的相似的名字...
  11 
  12 #  使用 600 为文件权限
  13 #+ 来在当前工作目录下创建一个这样的文件.
  14 #  这样就不需要 "umask 177" 了.
  15 #  但不管怎么说, 这也是一个好的编程风格.
  
  make
build 和 compile 二进制包的工具. 当源文件被增加或修改时就会触发一些操作, 这个工具用来控制这些操作.


make 命令将会检查 Makefile, makefile 是文件的依赖和操作列表.

install
特殊目的的文件拷贝命令, 与 cp 命令相似, 但是具有设置拷贝文件的权限和属性的能力. 这个命令看起来是为了安装软件包所定制的, 而且就其本身而言, 这个命令经常出现在 Makefile 中(在 make install : 区中). 在安装脚本中也会看到这个命令的使用.



factor
将一个正数分解为多个素数.

 bash$ factor 27417
 27417: 3 13 19 37
 	      
bc
Bash 不能处理浮点运算, 并且缺乏特定的一些操作,这些操作都是一些重要的计算功能.幸运的是, bc 可以解决这个问题.

bc 不仅仅是个多功能灵活的精确的工具, 而且它还提供许多编程语言才具备的一些方便的功能.

bc 比较类似于 C 语言的语法.

因为它是一个完整的 UNIX 工具, 所以它可以用在管道中, bc 在脚本中也是很常用的.

这里有一个简单的使用 bc 命令的模版可以用来在计算脚本中的变量. 用在命令替换 中.

 	      variable=$(echo "OPTIONS; OPERATIONS" | bc)
 	      
Example 12-42. 按月偿还贷款

   1 #!/bin/bash
   2 # monthlypmt.sh: 计算按月偿还贷款的数量.
   3 
   4 
   5 #  这份代码是一份修改版本, 原始版本在 "mcalc" (贷款计算)包中,
   6 #+ 这个包的作者是 Jeff Schmidt 和 Mendel Cooper (本书作者).
   7 #   http://www.ibiblio.org/pub/Linux/apps/financial/mcalc-1.6.tar.gz  [15k]
   8 
   9 echo
  10 echo "Given the principal, interest rate, and term of a mortgage,"
  11 echo "calculate the monthly payment."
  12 
  13 bottom=1.0
  14 
  15 echo
  16 echo -n "Enter principal (no commas) "
  17 read principal
  18 echo -n "Enter interest rate (percent) "  # 如果是 12%, 那就键入 "12", 别输入 ".12".
  19 read interest_r
  20 echo -n "Enter term (months) "
  21 read term
  22 
  23 
  24  interest_r=$(echo "scale=9; $interest_r/100.0" | bc) # 转换成小数.
  25                  # "scale" 指定了有效数字的个数.
  26   
  27 
  28  interest_rate=$(echo "scale=9; $interest_r/12 + 1.0" | bc)
  29  
  30 
  31  top=$(echo "scale=9; $principal*$interest_rate^$term" | bc)
  32 
  33  echo; echo "Please be patient. This may take a while."
  34 
  35  let "months = $term - 1"
  36 # ==================================================================== 
  37  for ((x=$months; x > 0; x--))
  38  do
  39    bot=$(echo "scale=9; $interest_rate^$x" | bc)
  40    bottom=$(echo "scale=9; $bottom+$bot" | bc)
  41 #  bottom = $(($bottom + $bot"))
  42  done
  43 # ==================================================================== 
  44 
  45 # -------------------------------------------------------------------- 
  46 #  Rick Boivie 给出了一个对上边循环的修改,
  47 #+ 这个修改更加有效率, 将会节省大概 2/3 的时间.
  48 
  49 # for ((x=1; x <= $months; x++))
  50 # do
  51 #   bottom=$(echo "scale=9; $bottom * $interest_rate + 1" | bc)
  52 # done
  53 
  54 
  55 #  然后他又想出了一个更加有效率的版本,
  56 #+ 将会节省 95% 的时间!
  57 
  58 # bottom=`{
  59 #     echo "scale=9; bottom=$bottom; interest_rate=$interest_rate"
  60 #     for ((x=1; x <= $months; x++))
  61 #     do
  62 #          echo 'bottom = bottom * interest_rate + 1'
  63 #     done
  64 #     echo 'bottom'
  65 #     } | bc`       # 在命令替换中嵌入一个 'for 循环'.
  66 # --------------------------------------------------------------------------
  67 #  On the other hand, Frank Wang suggests:
  68 #  bottom=$(echo "scale=9; ($interest_rate^$term-1)/($interest_rate-1)" | bc)
  69 
  70 #  因为 . . .
  71 #  在循环后边的算法
  72 #+ 事实上是一个等比数列的求和公式.
  73 #  求和公式是 e0(1-q^n)/(1-q),
  74 #+ e0 是第一个元素 并且 q=e(n+1)/e(n)
  75 #+ 和 n 是元素的数量.
  76 # --------------------------------------------------------------------------
  77 
  78 
  79  # let "payment = $top/$bottom"
  80  payment=$(echo "scale=2; $top/$bottom" | bc)
  81  # 使用2位有效数字来表示美元和美分.
  82  
  83  echo
  84  echo "monthly payment = \$$payment"  # 在总和的前边显示美元符号.
  85  echo
  86 
  87 
  88  exit 0
  89 
  90 
  91  # 练习:
  92  #   1) 处理输入允许本金总数中的逗号.
  93  #   2) 处理输入允许按照百分号和小数点的形式输入利率.
  94  #   3) 如果你真正想好好编写这个脚本,
  95  #      那么就扩展这个脚本让它能够打印出完整的分期付款表.
Example 12-43. 数制转换

   1 #!/bin/bash
   2 ##########################################################################
   3 # 脚本       :	base.sh - 用不同的数值来打印数字 (Bourne Shell)
   4 # 作者       :	Heiner Steven (heiner.steven@odn.de)
   5 # 日期       :	07-03-95
   6 # 类型       :	桌面
   7 # $Id: base.sh,v 1.2 2000/02/06 19:55:35 heiner Exp $
   8 # ==> 上边这行是 RCS ID 信息.
   9 ##########################################################################
  10 # 描述
  11 #
  12 # Changes
  13 # 21-03-95 stv	fixed error occuring with 0xb as input (0.2)
  14 ##########################################################################
  15 
  16 # ==> 在本书中使用这个脚本通过了作者的授权.
  17 # ==> 注释是本书作者添加的.
  18 
  19 NOARGS=65
  20 PN=`basename "$0"`			       # 程序名
  21 VER=`echo '$Revision: 1.2 $' | cut -d' ' -f2`  # ==> VER=1.2
  22 
  23 Usage () {
  24     echo "$PN - print number to different bases, $VER (stv '95)
  25 usage: $PN [number ...]
  26 
  27 If no number is given, the numbers are read from standard input.
  28 A number may be
  29     binary (base 2)		starting with 0b (i.e. 0b1100)
  30     octal (base 8)		starting with 0  (i.e. 014)
  31     hexadecimal (base 16)	starting with 0x (i.e. 0xc)
  32     decimal			otherwise (i.e. 12)" >&2
  33     exit $NOARGS 
  34 }   # ==> 打印出用法信息的函数.
  35 
  36 Msg () {
  37     for i   # ==> 省略 [list] .
  38     do echo "$PN: $i" >&2
  39     done
  40 }
  41 
  42 Fatal () { Msg "$@"; exit 66; }
  43 
  44 PrintBases () {
  45     # 决定数值的数制
  46     for i      # ==> 省略 [list]...
  47     do         # ==> 所以是对命令行参数进行操作.
  48 	case "$i" in
  49 	    0b*)		ibase=2;;	# 2进制
  50 	    0x*|[a-f]*|[A-F]*)	ibase=16;;	# 16进制
  51 	    0*)			ibase=8;;	# 8进制
  52 	    [1-9]*)		ibase=10;;	# 10进制
  53 	    *)
  54 		Msg "illegal number $i - ignored"
  55 		continue;;
  56 	esac
  57 
  58 	# 去掉前缀, 将16进制数字转换为大写(bc需要大写)
  59 	number=`echo "$i" | sed -e 's:^0[bBxX]::' | tr '[a-f]' '[A-F]'`
  60 	# ==>使用":" 作为sed分隔符, 而不使用"/".
  61 
  62 	# 将数字转换为10进制
  63 	dec=`echo "ibase=$ibase; $number" | bc`  # ==> 'bc' 是个计算工具.
  64 	case "$dec" in
  65 	    [0-9]*)	;;			 # 数字没问题
  66 	    *)		continue;;		 # 错误: 忽略
  67 	esac
  68 
  69 	# 在一行上打印所有的转换后的数字.
  70 	# ==> 'here document' 提供命令列表给'bc'.
  71 	echo `bc <<!
  72 	    obase=16; "hex="; $dec
  73 	    obase=10; "dec="; $dec
  74 	    obase=8;  "oct="; $dec
  75 	    obase=2;  "bin="; $dec
  76 !
  77     ` | sed -e 's: :	:g'
  78 
  79     done
  80 }
  81 
  82 while [ $# -gt 0 ]
  83 # ==>  这里必须使用一个 "while 循环",
  84 # ==>+ 因为所有的 case 都可能退出循环或者
  85 # ==>+ 结束脚本.
  86 # ==> (感谢, Paulo Marcel Coelho Aragao.)
  87 do
  88     case "$1" in
  89 	--)     shift; break;;
  90 	-h)     Usage;;                 # ==> 帮助信息.
  91 	-*)     Usage;;
  92          *)     break;;			# 第一个数字
  93     esac   # ==> 对于非法输入更严格检查是非常有用的.
  94     shift
  95 done
  96 
  97 if [ $# -gt 0 ]
  98 then
  99     PrintBases "$@"
 100 else					# 从标准输入中读取
 101     while read line
 102     do
 103 	PrintBases $line
 104     done
 105 fi
 106 
 107 
 108 exit 0
 
 Example 12-44. 使用 "here document" 来调用 bc

   1 #!/bin/bash
   2 # 使用命令替换来调用 'bc' 
   3 # 并与 'here document' 相结合.
   4 
   5 
   6 var1=`bc << EOF
   7 18.33 * 19.78
   8 EOF
   9 `
  10 echo $var1       # 362.56
  11 
  12 
  13 #  $( ... ) 这种标记法也可以.
  14 v1=23.53
  15 v2=17.881
  16 v3=83.501
  17 v4=171.63
  18 
  19 var2=$(bc << EOF
  20 scale = 4
  21 a = ( $v1 + $v2 )
  22 b = ( $v3 * $v4 )
  23 a * b + 15.35
  24 EOF
  25 )
  26 echo $var2       # 593487.8452
  27 
  28 
  29 var3=$(bc -l << EOF
  30 scale = 9
  31 s ( 1.7 )
  32 EOF
  33 )
  34 # 返回弧度为1.7的正弦.
  35 # "-l" 选项将会调用 'bc' 算数库.
  36 echo $var3       # .991664810
  37 
  38 
  39 # 现在, 在函数中试一下...
  40 hyp=             # 声明全局变量.
  41 hypotenuse ()    # 计算直角三角形的斜边.
  42 {
  43 hyp=$(bc -l << EOF
  44 scale = 9
  45 sqrt ( $1 * $1 + $2 * $2 )
  46 EOF
  47 )
  48 # 不幸的是, 不能从bash 函数中返回浮点值.
  49 }
  50 
  51 hypotenuse 3.68 7.31
  52 echo "hypotenuse = $hyp"    # 8.184039344
  53 
  54 
  55 exit 0
Example 12-45. 计算圆周率

   1 #!/bin/bash
   2 # cannon.sh: 通过开炮来取得近似的圆周率值.
   3 
   4 # 这事实上是一个"Monte Carlo"蒙特卡洛模拟的非常简单的实例:
   5 #+ 蒙特卡洛模拟是一种由现实事件抽象出来的数学模型,
   6 #+ 由于要使用随机抽样统计来估算数学函数, 所以使用伪随机数来模拟真正的随机.
   7 
   8 #  想象有一个完美的正方形土地, 边长为10000个单位.
   9 #  在这块土地的中间有一个完美的圆形湖,
  10 #+ 这个湖的直径是10000个单位.
  11 #  这块土地的绝大多数面积都是水, 当然只有4个角上有一些土地.
  12 #  (可以把这个湖想象成为使这个正方形的内接圆.)
  13 #
  14 #  我们将使用老式的大炮和铁炮弹
  15 #+ 向这块正方形的土地上开炮.
  16 #  所有的炮弹都会击中这块正方形土地的某个地方.
  17 #+ 或者是打到湖上, 或者是打到4个角的土地上.
  18 #  因为这个湖占据了这个区域大部分地方,
  19 #+ 所以大部分的炮弹都会"扑通"一声落到水里.
  20 #  而只有很少的炮弹会"砰"的一声落到4个
  21 #+ 角的土地上.
  22 #
  23 #  如果我们发出的炮弹足够随机的落到这块正方形区域中的话,
  24 #+ 那么落到水里的炮弹与打出炮弹的总数的比率,
  25 #+ 大概非常接近于 PI/4.
  26 #
  27 #  原因是所有的炮弹事实上都
  28 #+ 打在了这个土地的右上角,
  29 #+ 也就是, 笛卡尔坐标系的第一象限.
  30 #  (之前的解释只是一个简化.)
  31 #
  32 #  理论上来说, 如果打出的炮弹越多, 就越接近这个数字.
  33 #  然而, 对于shell 脚本来说一定会作些让步的,
  34 #+ 因为它肯定不能和那些内建就支持浮点运算的编译语言相比.
  35 #  当然就会降低精度.
  36 
  37 
  38 DIMENSION=10000  # 这块土地的边长.
  39                  # 这也是所产生的随机整数的上限.
  40 
  41 MAXSHOTS=1000    # 开炮次数.
  42                  # 10000 或更多次的话, 效果应该更好, 但有点太浪费时间了.
  43 PMULTIPLIER=4.0  # 接近于 PI 的比例因子.
  44 
  45 get_random ()
  46 {
  47 SEED=$(head -1 /dev/urandom | od -N 1 | awk '{ print $2 }')
  48 RANDOM=$SEED                                  #  来自于 "seeding-random.sh"
  49                                               #+ 的例子脚本.
  50 let "rnum = $RANDOM % $DIMENSION"             #  范围小于 10000.
  51 echo $rnum
  52 }
  53 
  54 distance=        # 声明全局变量.
  55 hypotenuse ()    # 从 "alt-bc.sh" 例子来的,
  56 {                # 计算直角三角形的斜边的函数.
  57 distance=$(bc -l << EOF
  58 scale = 0
  59 sqrt ( $1 * $1 + $2 * $2 )
  60 EOF
  61 )
  62 #  设置 "scale" 为 0 , 好让结果四舍五入为整数值,
  63 #+ 这是这个脚本中必须折中的一个地方.
  64 #  不幸的是, 这将降低模拟的精度.
  65 }
  66 
  67 
  68 # main() {
  69 
  70 # 初始化变量.
  71 shots=0
  72 splashes=0
  73 thuds=0
  74 Pi=0
  75 
  76 while [ "$shots" -lt  "$MAXSHOTS" ]           # 主循环.
  77 do
  78 
  79   xCoord=$(get_random)                        # 取得随机的 X 与 Y 坐标.
  80   yCoord=$(get_random)
  81   hypotenuse $xCoord $yCoord                  #  直角三角形斜边 =
  82                                               #+ distance.
  83   ((shots++))
  84 
  85   printf "#%4d   " $shots
  86   printf "Xc = %4d  " $xCoord
  87   printf "Yc = %4d  " $yCoord
  88   printf "Distance = %5d  " $distance         #  到湖中心的
  89                                               #+ 距离 --
  90                                               #  起始坐标点 --
  91                                               #+  (0,0).
  92 
  93   if [ "$distance" -le "$DIMENSION" ]
  94   then
  95     echo -n "SPLASH!  "
  96     ((splashes++))
  97   else
  98     echo -n "THUD!    "
  99     ((thuds++))
 100   fi
 101 
 102   Pi=$(echo "scale=9; $PMULTIPLIER*$splashes/$shots" | bc)
 103   # 将比例乘以 4.0.
 104   echo -n "PI ~ $Pi"
 105   echo
 106 
 107 done
 108 
 109 echo
 110 echo "After $shots shots, PI looks like approximately $Pi."
 111 # 如果不太准的话, 那么就提高一下运行的次数. . .
 112 # 可能是由于运行错误和随机数随机程度不高造成的.
 113 echo
 114 
 115 # }
 116 
 117 exit 0
 118 
 119 #  要想知道一个shell脚本到底适不适合作为
 120 #+ 一种需要对复杂和精度都有要求的计算应用的模拟的话.
 121 #
 122 #  一般至少需要两个判断条件.
 123 #  1) 作为一种概念的验证: 来显示它可以做到.
 124 #  2) 在使用真正的编译语言来实现一个算法之前,
 125 #+    使用脚本来测试和验证这个算法.
 
 Example 12-54. 记录按键

   1 #!/bin/bash
   2 # dd-keypress.sh: 记录按键, 不需要按回车.
   3 
   4 
   5 keypresses=4                      # 记录按键的个数.
   6 
   7 
   8 old_tty_setting=$(stty -g)        # 保存老的终端设置.
   9 
  10 echo "Press $keypresses keys."
  11 stty -icanon -echo                # 禁用标准模式.
  12                                   # 禁用本地 echo.
  13 keys=$(dd bs=1 count=$keypresses 2> /dev/null)
  14 # 如果不指定输入文件的话, 'dd' 使用标准输入.
  15 
  16 stty "$old_tty_setting"           # 恢复老的终端设置.
  17 
  18 echo "You pressed the \"$keys\" keys."
  19 
  20 # 感谢 Stephane Chazelas, 演示了这种方法.
  21 exit 0
  
  Example 12-52. 一个拷贝自身的脚本

   1 #!/bin/bash
   2 # self-copy.sh
   3 
   4 # 这个脚本将会拷贝自身.
   5 
   6 file_subscript=copy
   7 
   8 dd if=$0 of=$0.$file_subscript 2>/dev/null
   9 # 阻止dd产生的消息:            ^^^^^^^^^^^
  10 
  11 exit $?
  
  Example 12-55. 安全的删除一个文件

   1 #!/bin/bash
   2 # blot-out.sh: 删除一个文件所有的记录.
   3 
   4 #  这个脚本会使用随即字节交替的覆盖
   5 #+ 目标文件, 并且在最终删除这个文件之前清零.
   6 #  这么做之后, 即使你通过传统手段来检查磁盘扇区
   7 #+ 也不能把文件原始数据重新恢复.
   8 
   9 PASSES=7         #  破坏文件的次数.
  10                  #  提高这个数字会减慢脚本运行的速度，
  11                  #+ 尤其是对尺寸比较大的目标文件进行操作的时候.
  12 BLOCKSIZE=1      #  带有 /dev/urandom 的 I/O 需要单位块尺寸,
  13                  #+ 否则你可能会获得奇怪的结果.
  14 E_BADARGS=70     #  不同的错误退出码.
  15 E_NOT_FOUND=71
  16 E_CHANGED_MIND=72
  17 
  18 if [ -z "$1" ]   # 没指定文件名.
  19 then
  20   echo "Usage: `basename $0` filename"
  21   exit $E_BADARGS
  22 fi
  23 
  24 file=$1
  25 
  26 if [ ! -e "$file" ]
  27 then
  28   echo "File \"$file\" not found."
  29   exit $E_NOT_FOUND
  30 fi  
  31 
  32 echo; echo -n "Are you absolutely sure you want to blot out \"$file\" (y/n)? "
  33 read answer
  34 case "$answer" in
  35 [nN]) echo "Changed your mind, huh?"
  36       exit $E_CHANGED_MIND
  37       ;;
  38 *)    echo "Blotting out file \"$file\".";;
  39 esac
  40 
  41 
  42 flength=$(ls -l "$file" | awk '{print $5}')  # 5 是文件长度.
  43 pass_count=1
  44 
  45 chmod u+w "$file"   # Allow overwriting/deleting the file.
  46 
  47 echo
  48 
  49 while [ "$pass_count" -le "$PASSES" ]
  50 do
  51   echo "Pass #$pass_count"
  52   sync         # 刷新buffer.
  53   dd if=/dev/urandom of=$file bs=$BLOCKSIZE count=$flength
  54                # 使用随机字节进行填充.
  55   sync         # 再刷新buffer.
  56   dd if=/dev/zero of=$file bs=$BLOCKSIZE count=$flength
  57                # 用0填充.
  58   sync         # 再刷新buffer.
  59   let "pass_count += 1"
  60   echo
  61 done  
  62 
  63 
  64 rm -f $file    # 最后, 删除这个已经被破坏得不成样子的文件.
  65 sync           # 最后一次刷新buffer.
  66 
  67 echo "File \"$file\" blotted out and deleted."; echo
  68 
  69 
  70 exit 0
  71 
  72 #  这是一种真正安全的删除文件的办法,
  73 #+ 但是效率比较低, 运行比较慢.
  74 #  GNU 的文件工具包中的 "shred" 命令,
  75 #+ 也可以完成相同的工作, 不过更有效率.
  76 
  77 #  使用普通的方法是不可能重新恢复这个文件了.
  78 #  然而 . . .
  79 #+ 这个简单的例子是不能够抵抗
  80 #+ 那些经验丰富并且正规的分析.
  81 
  82 #  这个脚本可能不会很好的运行在日志文件系统上.(译者注: JFS)
  83 #  练习 (很难): 像它做的那样修正这个问题.
  84 
  85 
  86 
  87 #  Tom Vier的文件删除包可以更加彻底
  88 #+ 的删除文件, 比这个简单的例子厉害得多.
  89 #     http://www.ibiblio.org/pub/Linux/utils/file/wipe-2.0.0.tar.bz2
  90 
  91 #  如果想对安全删除文件这一论题进行深度的分析,
  92 #+ 可以参见Peter Gutmann的页面,
  93 #+     "Secure Deletion of Data From Magnetic and Solid-State Memory".
  94 #       http://www.cs.auckland.ac.nz/~pgut001/pubs/secure_del.html
  
  默认情况下始终有3个"文件"处于打开状态, stdin (键盘), stdout (屏幕), and stderr (错误消息输出到屏幕上). 这3个文件和其他打开的文件都可以被重定向. 对于重定向简单的解释就是捕捉一个文件, 命令, 程序, 脚本, 或者甚至是脚本中的代码块(参见 Example 3-1 和 Example 3-2)的输出, 然后将这些输出作为输入发送到另一个文件, 命令, 程序, 或脚本中.

每个打开的文件都会被分配一个文件描述符.[1]stdin, stdout, 和stderr的文件描述符分别是0, 1, 和 2. 对于正在打开的额外文件, 保留了描述符3到9. 在某些时候将这些格外的文件描述符分配给stdin, stdout, 或者是stderr作为临时的副本链接是非常有用的. [2] 在经过复杂的重定向和刷新之后需要把它们恢复成正常的样子 (参见 Example 16-1).


   1    COMMAND_OUTPUT >
   2       # 重定向stdout到一个文件.
   3       # 如果没有这个文件就创建, 否则就覆盖.
   4 
   5       ls -lR > dir-tree.list
   6       # 创建一个包含目录树列表的文件.
   7 
   8    : > filename
   9       # > 会把文件"filename"截断为0长度.
  10       # 如果文件不存在, 那么就创建一个0长度的文件(与'touch'的效果相同).
  11       # : 是一个占位符, 不产生任何输出.
  12 
  13    > filename    
  14       # > 会把文件"filename"截断为0长度.
  15       # 如果文件不存在, 那么就创建一个0长度的文件(与'touch'的效果相同).
  16       # (与上边的": >"效果相同, 但是在某些shell下可能不能工作.)
  17 
  18    COMMAND_OUTPUT >>
  19       # 重定向stdout到一个文件.
  20       # 如果文件不存在, 那么就创建它, 如果存在, 那么就追加到文件后边.
  21 
  22 
  23       # 单行重定向命令(只会影响它们所在的行):
  24       # --------------------------------------------------------------------
  25 
  26    1>filename
  27       # 重定向stdout到文件"filename".
  28    1>>filename
  29       # 重定向并追加stdout到文件"filename".
  30    2>filename
  31       # 重定向stderr到文件"filename".
  32    2>>filename
  33       # 重定向并追加stderr到文件"filename".
  34    &>filename
  35       # 将stdout和stderr都重定向到文件"filename".
  36 
  37       #==============================================================================
  38       # 重定向stdout, 一次一行.
  39       LOGFILE=script.log
  40 
  41       echo "This statement is sent to the log file, \"$LOGFILE\"." 1>$LOGFILE
  42       echo "This statement is appended to \"$LOGFILE\"." 1>>$LOGFILE
  43       echo "This statement is also appended to \"$LOGFILE\"." 1>>$LOGFILE
  44       echo "This statement is echoed to stdout, and will not appear in \"$LOGFILE\"."
  45       # 每行过后, 这些重定向命令会自动"reset".
  46 
  47 
  48 
  49       # 重定向stderr, 一次一行.
  50       ERRORFILE=script.errors
  51 
  52       bad_command1 2>$ERRORFILE       #  错误消息发到$ERRORFILE中.
  53       bad_command2 2>>$ERRORFILE      #  错误消息添加到$ERRORFILE中.
  54       bad_command3                    #  错误消息echo到stderr,
  55                                       #+ 并且不出现在$ERRORFILE中.
  56       # 每行过后, 这些重定向命令也会自动"reset".
  57       #==============================================================================
  58 
  59 
  60 
  61    2>&1
  62       # 重定向stderr到stdout.
  63       # 得到的错误消息与stdout一样, 发送到一个地方.
  64 
  65    i>&j
  66       # 重定向文件描述符i 到 j.
  67       # 指向i文件的所有输出都发送到j中去.
  68 
  69    >&j
  70       # 默认的, 重定向文件描述符1(stdout)到 j.
  71       # 所有传递到stdout的输出都送到j中去.
  72 
  73    0< FILENAME
  74     < FILENAME
  75       # 从文件中接受输入.
  76       # 与">"是成对命令, 并且通常都是结合使用.
  77       #
  78       # grep search-word <filename
  79 
  80 
  81    [j]<>filename
  82       # 为了读写"filename", 把文件"filename"打开, 并且分配文件描述符"j"给它.
  83       # 如果文件"filename"不存在, 那么就创建它.
  84       # 如果文件描述符"j"没指定, 那默认是fd 0, stdin.
  85       #
  86       # 这种应用通常是为了写到一个文件中指定的地方.
  87       echo 1234567890 > File    # 写字符串到"File".
  88       exec 3<> File             # 打开"File"并且给它分配fd 3.
  89       read -n 4 <&3             # 只读4个字符.
  90       echo -n . >&3             # 写一个小数点.
  91       exec 3>&-                 # 关闭fd 3.
  92       cat File                  # ==> 1234.67890
  93       # 随机存储.
  94 
  95 
  96 
  97    |
  98       # 管道.
  99       # 通用目的的处理和命令链工具.
 100       # 与">"很相似, 但是实际上更通用.
 101       # 对于想将命令, 脚本, 文件和程序串连起来的时候很有用.
 102       cat *.txt | sort | uniq > result-file
 103       # 对所有的.txt文件的输出进行排序, 并且删除重复行,
 104       # 最后将结果保存到"result-file"中.
 
 可以将多个输出流重定向到一个文件上.
   1 ls -yz >> command.log 2>&1
   2 #  将错误选项"yz"的结果放到文件"command.log"中.
   3 #  因为stderr被重定向到这个文件中,
   4 #+ 所有的错误消息也就都指向那里了.
   5 
   6 #  注意, 下边这个例子就不会给出相同的结果.
   7 ls -yz 2>&1 >> command.log
   8 #  输出一个错误消息, 但是并不写到文件中.
   9 
  10 #  如果将stdout和stderr都重定向,
  11 #+ 命令的顺序会有些不同.
  
  Example 16-1. 使用exec重定向标准输入

   1 #!/bin/bash
   2 # 使用'exec'重定向标准输入.
   3 
   4 
   5 exec 6<&0          # 将文件描述符#6与stdin链接起来.
   6                    # 保存了stdin.
   7 
   8 exec < data-file   # stdin被文件"data-file"所代替.
   9 
  10 read a1            # 读取文件"data-file"的第一行.
  11 read a2            # 读取文件"data-file"的第二行.
  12 
  13 echo
  14 echo "Following lines read from file."
  15 echo "-------------------------------"
  16 echo $a1
  17 echo $a2
  18 
  19 echo; echo; echo
  20 
  21 exec 0<&6 6<&-
  22 #  现在将stdin从fd #6中恢复, 因为刚才我们把stdin重定向到#6了,
  23 #+ 然后关闭fd #6 ( 6<&- ), 好让这个描述符继续被其他进程所使用.
  24 #
  25 # <&6 6<&-    这么做也可以.
  26 
  27 echo -n "Enter data  "
  28 read b1  # 现在"read"已经恢复正常了, 就是从stdin中读取.
  29 echo "Input read from stdin."
  30 echo "----------------------"
  31 echo "b1 = $b1"
  32 
  33 echo
  34 
  35 exit 0
  
  Example 16-2. 使用exec来重定向stdout

   1 #!/bin/bash
   2 # reassign-stdout.sh
   3 
   4 LOGFILE=logfile.txt
   5 
   6 exec 6>&1           # 将fd #6与stdout相连接.
   7                     # 保存stdout.
   8 
   9 exec > $LOGFILE     # stdout就被文件"logfile.txt"所代替了.
  10 
  11 # ----------------------------------------------------------- #
  12 # 在这块中所有命令的输出就都发向文件 $LOGFILE.
  13 
  14 echo -n "Logfile: "
  15 date
  16 echo "-------------------------------------"
  17 echo
  18 
  19 echo "Output of \"ls -al\" command"
  20 echo
  21 ls -al
  22 echo; echo
  23 echo "Output of \"df\" command"
  24 echo
  25 df
  26 
  27 # ----------------------------------------------------------- #
  28 
  29 exec 1>&6 6>&-      # 恢复stdout, 然后关闭文件描述符#6.
  30 
  31 echo
  32 echo "== stdout now restored to default == "
  33 echo
  34 ls -al
  35 echo
  36 
  37 exit 0
Example 16-3. 使用exec在同一脚本中重定向stdin和stdout

   1 #!/bin/bash
   2 # upperconv.sh
   3 # 将一个指定的输入文件转换为大写.
   4 
   5 E_FILE_ACCESS=70
   6 E_WRONG_ARGS=71
   7 
   8 if [ ! -r "$1" ]     # 判断指定的输入文件是否可读?
   9 then
  10   echo "Can't read from input file!"
  11   echo "Usage: $0 input-file output-file"
  12   exit $E_FILE_ACCESS
  13 fi                   #  即使输入文件($1)没被指定
  14                      #+ 也还是会以相同的错误退出(为什么?).
  15 
  16 if [ -z "$2" ]
  17 then
  18   echo "Need to specify output file."
  19   echo "Usage: $0 input-file output-file"
  20   exit $E_WRONG_ARGS
  21 fi
  22 
  23 
  24 exec 4<&0
  25 exec < $1            # 将会从输入文件中读取.
  26 
  27 exec 7>&1
  28 exec > $2            # 将写到输出文件中.
  29                      # 假设输出文件是可写的(添加检查?).
  30 
  31 # -----------------------------------------------
  32     cat - | tr a-z A-Z   # 转换为大写.
  33 #   ^^^^^                # 从stdin中读取.Reads from stdin.
  34 #           ^^^^^^^^^^   # 写到stdout上.
  35 # 然而, stdin和stdout都被重定向了.
  36 # -----------------------------------------------
  37 
  38 exec 1>&7 7>&-       # 恢复 stout.
  39 exec 0<&4 4<&-       # 恢复 stdin.
  40 
  41 # 恢复之后, 下边这行代码将会如期望的一样打印到stdout上.
  42 echo "File \"$1\" written to \"$2\" as uppercase conversion."
  43 
  44 exit 0
I/O重定向是一种避免可怕的子shell中不可存取变量问题的方法.

Example 16-4. 避免子shell

   1 #!/bin/bash
   2 # avoid-subshell.sh
   3 # Matthew Walker提出的建议.
   4 
   5 Lines=0
   6 
   7 echo
   8 
   9 cat myfile.txt | while read line;  #  (译者注: 管道会产生子shell)
  10                  do {
  11                    echo $line
  12                    (( Lines++ ));  #  增加这个变量的值
  13                                    #+ 但是外部循环却不能存取.
  14                                    #  子shell问题.
  15                  }
  16                  done
  17 
  18 echo "Number of lines read = $Lines"     # 0
  19                                          # 错误!
  20 
  21 echo "------------------------"
  22 
  23 
  24 exec 3<> myfile.txt
  25 while read line <&3
  26 do {
  27   echo "$line"
  28   (( Lines++ ));                   #  增加这个变量的值
  29                                    #+ 现在外部循环就可以存取了.
  30                                    #  没有子shell, 现在就没问题了.
  31 }
  32 done
  33 exec 3>&-
  34 
  35 echo "Number of lines read = $Lines"     # 8
  36 
  37 echo
  38 
  39 exit 0
  40 
  41 # 下边这些行是脚本的结果, 脚本是不会走到这里的.
  42 
  43 $ cat myfile.txt
  44 
  45 Line 1.
  46 Line 2.
  47 Line 3.
  48 Line 4.
  49 Line 5.
  50 Line 6.
  51 Line 7.
  52 Line 8.
 
注意事项:

[1]	
一个文件描述符说白了就是文件系统为了跟踪这个打开的文件而分配给它的一个数字. 也可以的将其理解为文件指针的一个简单版本. 与C中的文件句柄的概念相似.

[2]	
使用文件描述符5可能会引起问题. 当Bash使用exec创建一个子进程的时候, 子进程会继承fd5(参见Chet Ramey的归档e-mail, SUBJECT: RE: File descriptor 5 is held open). 最好还是不要去招惹这个特定的fd.

例子 16-5. while 循环的重定向

   1 #!/bin/bash
   2 # redir2.sh
   3 
   4 if [ -z "$1" ]
   5 then
   6   Filename=names.data       # 如果没有指定文件名，则指定这个默认值.
   7 else
   8   Filename=$1
   9 fi  
  10 #+ Filename=${1:-names.data}
  11 #  这句可代替上面的测试 (参数替换).
  12 
  13 count=0
  14 
  15 echo
  16 
  17 while [ "$name" != Smith ]  # 为什么变量 $name 要用引号?
  18 do
  19   read name                 # 从$Filename文件中读而非在标准输入中读.
  20   echo $name
  21   let "count += 1"
  22 done <"$Filename"           # 重定向标准输入到文件$Filename. 
  23 #    ^^^^^^^^^^^^
  24 
  25 echo; echo "$count names read"; echo
  26 
  27 exit 0
  28 
  29 #  注意在老一些的shell脚本编程语言里,
  30 #+ 重定向的循环是在子shell里运行的.
  31 #  因此, $count 值返回后会是 0, 此值是在循环开始前的值.
  32 #  Bash 和 ksh 只要可能就避免启用子shell,
  33 #+ 因此这个例子能正确运行.
  34 #  (多谢Heiner Steven指出这个问题.)
  35 
  36 # 然而 . . .
  37 # Bash有时仍会启用一个子shell来处理重定向的"while"循环.
  38 
  39 abc=hi
  40 echo -e "1\n2\n3" | while read l
  41      do abc="$l"
  42         echo $abc
  43      done
  44 echo $abc
  45 
  46 # (多谢Bruno de Oliveira Schneider给出上面的代码片段来演示此问题.)
  47 #
例子 16-6. 重定向while 循环的另一种形式

   1 #!/bin/bash
   2 
   3 # 这是前个脚本的另一个版本.
   4 
   5 #  Heiner Steven谈到
   6 #+ 在重定向循环时会以子Shell运行的环境里，
   7 #+ 循环内的值在循环结束后不会保持循环内的值.
   8 #
   9 
  10 
  11 if [ -z "$1" ]
  12 then
  13   Filename=names.data     # 如果没有指定文件名则使用默认值.
  14 else
  15   Filename=$1
  16 fi  
  17 
  18 
  19 exec 3<&0                 # 把标准输入关联到文件描述符.
  20 exec 0<"$Filename"        # 重定向标准输入.
  21 
  22 count=0
  23 echo
  24 
  25 
  26 while [ "$name" != Smith ]
  27 do
  28   read name               # 从标准输入($Filename)中读.
  29   echo $name
  30   let "count += 1"
  31 done                      #  从文件$Filename中循环的读
  32                           #+ 因为文件（译者注：指默认的文件，在这节最后面附上）有20行.
  33 
  34 #  这个脚本原先在"while"循环的结尾是用:
  35 #+      done <"$Filename" 
  36 #  练习:
  37 #  为什么这是不必要的?
  38 
  39 
  40 exec 0<&3                 # 恢复旧的标准输入.
  41 exec 3<&-                 # 关闭临时文件描述符3.
  42 
  43 echo; echo "$count names read"; echo
  44 
  45 exit 0
例子 16-7. 重定向 until 循环

   1 #!/bin/bash
   2 # 和前面的例子相同, 但使用的是"until"循环.
   3 
   4 if [ -z "$1" ]
   5 then
   6   Filename=names.data         # 如果没有指定文件名使用默认值.
   7 else
   8   Filename=$1
   9 fi  
  10 
  11 # while [ "$name" != Smith ]
  12 until [ "$name" = Smith ]     # 把 !=  改为 =.
  13 do
  14   read name                   # 从文件$Filename中读而非从标准输入中读.
  15   echo $name
  16 done <"$Filename"             # 重定向标准输入到文件$Filename. 
  17 #    ^^^^^^^^^^^^
  18 
  19 # 结果和前面的"while"循环例子相同.
  20 
  21 exit 0
例子 16-8. 重定向 for 循环

   1 #!/bin/bash
   2 
   3 if [ -z "$1" ]
   4 then
   5   Filename=names.data          # 如果没有指定文件名就使用默认值.
   6 else
   7   Filename=$1
   8 fi  
   9 
  10 line_count=`wc $Filename | awk '{ print $1 }'`
  11 #           目标文件的行数.
  12 #
  13 #  代码非常的刻意和难看，但至少展示了for循环的标准输入可以重定向...
  14 #+ 当然你要足够聪明能看出来.
  15 #
  16 #
  17 # 更简洁的办法是     line_count=$(wc -l < "$Filename")
  18 
  19 
  20 for name in `seq $line_count`  # 调用 "seq" 来打印数字序列.
  21 # while [ "$name" != Smith ]   --   for循环比单个"while"循环更复杂   --
  22 do
  23   read name                    # 从$Filename文件而非标准输入读.
  24   echo $name
  25   if [ "$name" = Smith ]       # 因为用for循环，所以需要这个累赘测试.
  26   then
  27     break
  28   fi  
  29 done <"$Filename"              # 重定向标准输入到文件 $Filename. 
  30 #    ^^^^^^^^^^^^
  31 
  32 exit 0
我们也可以修改前面的例子使其能重定向循环的标准输出.

例子 16-9. 重定向 for 循环 (标准输入和标准输出都做重定向)

   1 #!/bin/bash
   2 
   3 if [ -z "$1" ]
   4 then
   5   Filename=names.data          # 如果没有指定文件名，则使用默认值.
   6 else
   7   Filename=$1
   8 fi  
   9 
  10 Savefile=$Filename.new         # 保存结果的文件名.
  11 FinalName=Jonah                # 终止"read"时的名称.
  12 
  13 line_count=`wc $Filename | awk '{ print $1 }'`  # 目标文件的行数.
  14 
  15 
  16 for name in `seq $line_count`
  17 do
  18   read name
  19   echo "$name"
  20   if [ "$name" = "$FinalName" ]
  21   then
  22     break
  23   fi  
  24 done < "$Filename" > "$Savefile"     # 重定向标准输出到文件 $Filename,
  25 #    ^^^^^^^^^^^^^^^^^^^^^^^^^^^       并保存输出到备份文件中.
  26 
  27 exit 0
例子 16-10. 重定向 if/then 测试结构

   1 #!/bin/bash
   2 
   3 if [ -z "$1" ]
   4 then
   5   Filename=names.data   # 如果文件名没有指定，使用默认值.
   6 else
   7   Filename=$1
   8 fi  
   9 
  10 TRUE=1
  11 
  12 if [ "$TRUE" ]          # if true    和   if :   都可以.
  13 then
  14  read name
  15  echo $name
  16 fi <"$Filename"
  17 #  ^^^^^^^^^^^^
  18 
  19 # 只读了文件的第一行.
  20 # "if/then"测试结构不会自动地反复地执行，除非把它们嵌到循环里.
  21 
  22 exit 0
例子 16-11. 用于上面例子的"names.data"数据文件

   1 Aristotle
   2 Belisarius
   3 Capablanca
   4 Euler
   5 Goethe
   6 Hamurabi
   7 Jonah
   8 Laplace
   9 Maroczy
  10 Purcell
  11 Schmidt
  12 Semmelweiss
  13 Smith
  14 Turing
  15 Venn
  16 Wilson
  17 Znosko-Borowski
  18 
  19 #  此数据文件用于:
  20 #+ "redir2.sh", "redir3.sh", "redir4.sh", "redir4a.sh", "redir5.sh".
重定向代码块的标准输出有保存它的输出到文件中的作用. 

例子 16-12. 事件记录

   1 #!/bin/bash
   2 # logevents.sh,  Stephane Chazelas编写.
   3 
   4 # 把事件记录在一个文件.
   5 # 必须以root身份运行 (这样才有权限存取 /var/log).
   6 
   7 ROOT_UID=0     # 只有$UID值为 0 的用户才有root权限.
   8 E_NOTROOT=67   # 非root时运行的退出错误值.
   9 
  10 
  11 if [ "$UID" -ne "$ROOT_UID" ]
  12 then
  13   echo "Must be root to run this script."
  14   exit $E_NOTROOT
  15 fi  
  16 
  17 
  18 FD_DEBUG1=3
  19 FD_DEBUG2=4
  20 FD_DEBUG3=5
  21 
  22 # 去除下面两行中的一行的注释来使脚本记录事件.
  23 # LOG_EVENTS=1
  24 # LOG_VARS=1
  25 
  26 
  27 log()  # 把时间和日期写进日志文件.
  28 {
  29 echo "$(date)  $*" >&7     # 这会添加时间到文件中This *appends* the date to the file.
  30                               # See below看下面的.
  31 }
  32 
  33 
  34 
  35 case $LOG_LEVEL in
  36  1) exec 3>&2         4> /dev/null 5> /dev/null;;
  37  2) exec 3>&2         4>&2         5> /dev/null;;
  38  3) exec 3>&2         4>&2         5>&2;;
  39  *) exec 3> /dev/null 4> /dev/null 5> /dev/null;;
  40 esac
  41 
  42 FD_LOGVARS=6
  43 if [[ $LOG_VARS ]]
  44 then exec 6>> /var/log/vars.log
  45 else exec 6> /dev/null               # 消灭输出Bury output.
  46 fi
  47 
  48 FD_LOGEVENTS=7
  49 if [[ $LOG_EVENTS ]]
  50 then
  51   # then exec 7 >(exec gawk '{print strftime(), $0}' >> /var/log/event.log)
  52   # 上面这行在2.04版本的Bash不能工作.
  53   exec 7>> /var/log/event.log        # 添加到"event.log"文件.
  54   log                                      # 记录时间和日期.
  55 else exec 7> /dev/null                  # Bury output丢弃输出.
  56 fi
  57 
  58 echo "DEBUG3: beginning" >&${FD_DEBUG3}
  59 
  60 ls -l >&5 2>&4                       # command1 >&5 2>&4
  61 
  62 echo "Done"                                # command2 
  63 
  64 echo "sending mail" >&${FD_LOGEVENTS}   # 写"sending mail"字串到文件描述符7上.
  65 
  66 
  67 exit 0
  
  Example 17-1. 广播: 发送消息给每个登录上的用户

   1 #!/bin/bash
   2 
   3 wall <<zzz23EndOfMessagezzz23
   4 E-mail your noontime orders for pizza to the system administrator.
   5     (Add an extra dollar for anchovy or mushroom topping.)
   6 # 额外的消息文本写在这里.
   7 # 注意: 'wall' 会打印注释行.
   8 zzz23EndOfMessagezzz23
   9 
  10 # 可以使用更有效率的做法
  11 #         wall <message-file
  12 #  然而将消息模版嵌入到脚本中
  13 #+ 是一种"小吃店"(快速但是比较脏)的只能使用一次的解决办法.
  14 
  15 exit 0
  
  Example 17-2. 仿造文件: 创建一个两行的仿造文件

   1 #!/bin/bash
   2 
   3 # 用非交互的方式来使用'vi'编辑一个文件.
   4 # 模仿'sed'.
   5 
   6 E_BADARGS=65
   7 
   8 if [ -z "$1" ]
   9 then
  10   echo "Usage: `basename $0` filename"
  11   exit $E_BADARGS
  12 fi
  13 
  14 TARGETFILE=$1
  15 
  16 # 在文件中插入两行, 然后保存.
  17 #--------Begin here document-----------#
  18 vi $TARGETFILE <<x23LimitStringx23
  19 i
  20 This is line 1 of the example file.
  21 This is line 2 of the example file.
  22 ^[
  23 ZZ
  24 x23LimitStringx23
  25 #----------End here document-----------#
  26 
  27 #  注意上边^[是一个转义符,键入Ctrl+v <Esc>就行,
  28 #+ 事实上它是<Esc>键.
  29 
  30 #  Bram Moolenaar指出这种方法不能正常地用在'vim'上, (译者注: Bram Moolenaar是vim作者)
  31 #+ 因为可能会有终端的相互影响问题.
  32 
  33 exit 0
上边的脚本也可以不用vi而用ex来实现. Here document 包含ex命令列表的做法足够形成自己的类别了, 叫ex scripts.
   1 #!/bin/bash
   2 #  把所有后缀为".txt"文件
   3 #+ 中的"Smith"都替换成"Jones".
   4 
   5 ORIGINAL=Smith
   6 REPLACEMENT=Jones
   7 
   8 for word in $(fgrep -l $ORIGINAL *.txt)
   9 do
  10   # -------------------------------------
  11   ex $word <<EOF
  12   :%s/$ORIGINAL/$REPLACEMENT/g
  13   :wq
  14 EOF
  15   # :%s 是"ex"的替换命令.
  16   # :wq 是保存并退出的意思.
  17   # -------------------------------------
  18 done

与"ex scripts"相似的是cat scripts.

Example 17-3. 使用cat的多行消息

   1 #!/bin/bash
   2 
   3 #  'echo' 对于打印单行消息是非常好的,
   4 #+  但是在打印消息块时可能就有点问题了.
   5 #   'cat' here document可以解决这个限制.
   6 
   7 cat <<End-of-message
   8 -------------------------------------
   9 This is line 1 of the message.
  10 This is line 2 of the message.
  11 This is line 3 of the message.
  12 This is line 4 of the message.
  13 This is the last line of the message.
  14 -------------------------------------
  15 End-of-message
  16 
  17 #  用下边这行代替上边的第7行
  18 #+   cat > $Newfile <<End-of-message
  19 #+       ^^^^^^^^^^
  20 #+ 那么就会把输出写到文件$Newfile中, 而不是stdout.
  21 
  22 exit 0
  23 
  24 
  25 #--------------------------------------------
  26 # 下边的代码不会运行, 因为上边的"exit 0".
  27 
  28 # S.C. 指出下边代码也可以运行.
  29 echo "-------------------------------------
  30 This is line 1 of the message.
  31 This is line 2 of the message.
  32 This is line 3 of the message.
  33 This is line 4 of the message.
  34 This is the last line of the message.
  35 -------------------------------------"
  36 # 然而, 文本可能不包含双引号, 除非它们被转义.
  
  例子 23-1. 简单函数

   1 #!/bin/bash
   2 
   3 JUST_A_SECOND=1
   4 
   5 funky ()
   6 { # 这是一个最简单的函数.
   7   echo "This is a funky function."
   8   echo "Now exiting funky function."
   9 } # 函数必须在调用前声明.
  10 
  11 
  12 fun ()
  13 { # 一个稍复杂的函数.
  14   i=0
  15   REPEATS=30
  16 
  17   echo
  18   echo "And now the fun really begins."
  19   echo
  20 
  21   sleep $JUST_A_SECOND    # 嘿, 暂停一秒!
  22   while [ $i -lt $REPEATS ]
  23   do
  24     echo "----------FUNCTIONS---------->"
  25     echo "<------------ARE-------------"
  26     echo "<------------FUN------------>"
  27     echo
  28     let "i+=1"
  29   done
  30 }
  31 
  32   # 现在,调用两个函数.
  33 
  34 funky
  35 fun
  36 
  37 exit 0
函数定义必须在第一次调用函数前完成.没有像C中的函数“声明”方法.
   1 f1
   2 # 因为函数"f1"还没有定义，这会引起错误信息.
   3 
   4 declare -f f1      # 这样也没用.
   5 f1                 # 仍然会引起错误.
   6 
   7 # 然而...
   8 
   9 	  
  10 f1 ()
  11 {
  12   echo "Calling function \"f2\" from within function \"f1\"."
  13   f2
  14 }
  15 
  16 f2 ()
  17 {
  18   echo "Function \"f2\"."
  19 }
  20 
  21 f1  #  虽然在它定义前被引用过,
  22     #+ 函数"f2"实际到这儿才被调用.
  23     #  这样是允许的.
  24     
  25     # Thanks, S.C.
在一个函数内嵌套另一个函数也是可以的，但是不常用.
   1 f1 ()
   2 {
   3 
   4   f2 () # nested
   5   {
   6     echo "Function \"f2\", inside \"f1\"."
   7   }
   8 
   9 }  
  10 
  11 f2  #  引起错误.
  12     #  就是你先"declare -f f2"了也没用.
  13 
  14 echo    
  15 
  16 f1  #  什么也不做,因为调用"f1"不会自动调用"f2".
  17 f2  #  现在,可以正确的调用"f2"了,
  18     #+ 因为之前调用"f1"使"f2"在脚本中变得可见了.
  19 
  20     # Thanks, S.C.
函数声明可以出现在看上去不可能出现的地方，那些不可能的地方本该由一个命令出现的地方.
   1 ls -l | foo() { echo "foo"; }  # 允许，但没什么用.
   2 
   3 
   4 
   5 if [ "$USER" = bozo ]
   6 then
   7   bozo_greet ()   # 在if/then结构中定义了函数.
   8   {
   9     echo "Hello, Bozo."
  10   }
  11 fi  
  12 
  13 bozo_greet        # 只能由Bozo运行, 其他用户会引起错误.
  14 
  15 
  16 
  17 # 在某些上下文，像这样可能会有用.
  18 NO_EXIT=1   # 将会打开下面的函数定义.
  19 
  20 [[ $NO_EXIT -eq 1 ]] && exit() { true; }     # 在"and-list"(and列表)中定义函数.
  21 # 如果 $NO_EXIT 是 1,声明函数"exit ()".
  22 # 把"exit"取别名为"true"将会禁用内建的"exit".
  23 
  24 exit  # 调用"exit ()"函数, 而不是内建的"exit".
  25 
  26 # Thanks, S.C.
23.1. 复杂函数和函数复杂性

函数可以处理传递给它的参数并且能返回它的退出状态码(exit status)给脚本后续使用.

   1 function_name $arg1 $arg2
函数以位置来引用传递过来的参数(就好像他们是位置参数(positional parameters)), 例如$1, $2,以此类推.

例子 23-2. 带着参数的函数

   1 #!/bin/bash
   2 # 函数和参数
   3 
   4 DEFAULT=default                             # 默认的参数值.
   5 
   6 func2 () {
   7    if [ -z "$1" ]                           # 第一个参数是否长度为零?
   8    then
   9      echo "-Parameter #1 is zero length.-"  # 则没有参数传递进来.
  10    else
  11      echo "-Param #1 is \"$1\".-"
  12    fi
  13 
  14    variable=${1-$DEFAULT}                   #  
  15    echo "variable = $variable"              #  参数替换会表现出什么?
  16                                             #  ---------------------------
  17                                             #  它用于分辨没有参数和一个只有NULL值的参数.
  18                                             #
  19 
  20    if [ "$2" ]
  21    then
  22      echo "-Parameter #2 is \"$2\".-"
  23    fi
  24 
  25    return 0
  26 }
  27 
  28 echo
  29    
  30 echo "Nothing passed."   
  31 func2                          # 没有参数来调用
  32 echo
  33 
  34 
  35 echo "Zero-length parameter passed."
  36 func2 ""                       # 以一个长度为零的参数调用
  37 echo
  38 
  39 echo "Null parameter passed."
  40 func2 "$uninitialized_param"   # 以未初始化的参数来调用
  41 echo
  42 
  43 echo "One parameter passed."   
  44 func2 first           # 用一个参数来调用
  45 echo
  46 
  47 echo "Two parameters passed."   
  48 func2 first second    # 以二个参数来调用
  49 echo
  50 
  51 echo "\"\" \"second\" passed."
  52 func2 "" second       # 以第一个参数为零长度，而第二个参数是一个ASCII码组成的字符串来调用.
  53 echo                  # 
  54 
  55 exit 0
	
shift命令可以工作在传递给函数的参数 (参考例子 33-15).

但是，传给脚本的命令行参数怎么办？在函数内部可以看到它们吗？好，让我们来弄清楚.

例子 23-3. 函数和被传给脚本的命令行参数

   1 #!/bin/bash
   2 # func-cmdlinearg.sh
   3 #  以一个命令行参数来调用这个脚本,
   4 #+ 类似 $0 arg1来调用.
   5 
   6 
   7 func ()
   8 
   9 {
  10 echo "$1"
  11 }
  12 
  13 echo "First call to function: no arg passed."
  14 echo "See if command-line arg is seen."
  15 func
  16 # 不!命令行参数看不到.
  17 
  18 echo "============================================================"
  19 echo
  20 echo "Second call to function: command-line arg passed explicitly."
  21 func $1
  22 # 现在可以看到了!
  23 
  24 exit 0
与别的编程语言相比，shell脚本一般只传递值给函数，变量名(实现上是指针)如果作为参数传递给函数会被看成是字面上字符串的意思。函数解释参数是以字面上的意思来解释的.

间接变量引用(Indirect variable references) (参考例子 34-2)提供了传递变量指针给函数的一个笨拙的机制.

例子 23-4. 传递间接引用给函数

   1 #!/bin/bash
   2 # ind-func.sh: 传递间接引用给函数.
   3 
   4 echo_var ()
   5 {
   6 echo "$1"
   7 }
   8 
   9 message=Hello
  10 Hello=Goodbye
  11 
  12 echo_var "$message"        # Hello
  13 # 现在，让我们传递一个间接引用给函数.
  14 echo_var "${!message}"     # Goodbye
  15 
  16 echo "-------------"
  17 
  18 # 如果我们改变"hello"变量的值会发生什么?
  19 Hello="Hello, again!"
  20 echo_var "$message"        # Hello
  21 echo_var "${!message}"     # Hello, again!
  22 
  23 exit 0
下一个逻辑问题是：在传递参数给函数之后是否能解除参数的引用.

例子 23-5. 解除传递给函数的参数引用

   1 #!/bin/bash
   2 # dereference.sh
   3 # 给函数传递不同的参数.
   4 # Bruce W. Clare编写.
   5 
   6 dereference ()
   7 {
   8      y=\$"$1"   # 变量名.
   9      echo $y    # $Junk
  10 
  11      x=`eval "expr \"$y\" "`
  12      echo $1=$x
  13      eval "$1=\"Some Different Text \""  # 赋新值.
  14 }
  15 
  16 Junk="Some Text"
  17 echo $Junk "before"    # Some Text before
  18 
  19 dereference Junk
  20 echo $Junk "after"     # Some Different Text after
  21 
  22 exit 0
  
  return

终止一个函数.return 命令[1]可选地带一个整数参数，这个整数作为函数的"返回值"返回给调用此函数的脚本,并且这个值也被赋给变量$?.

例子 23-7. 两个数中的最大者

   1 #!/bin/bash
   2 # max.sh: 两个整数中的最大者.
   3 
   4 E_PARAM_ERR=-198    # 如果传给函数的参数少于2个时的返回值.
   5 EQUAL=-199          # 如果两个整数值相等的返回值.
   6 #  任一个传给函数的参数值溢出
   7 #
   8 
   9 max2 ()             # 返回两个整数的较大值.
  10 {                   # 注意: 参与比较的数必须小于257.
  11 if [ -z "$2" ]
  12 then
  13   return $E_PARAM_ERR
  14 fi
  15 
  16 if [ "$1" -eq "$2" ]
  17 then
  18   return $EQUAL
  19 else
  20   if [ "$1" -gt "$2" ]
  21   then
  22     return $1
  23   else
  24     return $2
  25   fi
  26 fi
  27 }
  28 
  29 max2 33 34
  30 return_val=$?
  31 
  32 if [ "$return_val" -eq $E_PARAM_ERR ]
  33 then
  34   echo "Need to pass two parameters to the function."
  35 elif [ "$return_val" -eq $EQUAL ]
  36   then
  37     echo "The two numbers are equal."
  38 else
  39     echo "The larger of the two numbers is $return_val."
  40 fi  
  41 
  42   
  43 exit 0
  44 
  45 #  练习 (容易):
  46 #  ---------------
  47 #  把这个脚本转化成交互式的脚本,
  48 #+ 也就是说，让脚本可以要求调用者输入两个整数.
	
为了函数可以返回字符串或是数组，用一个可在函数外可见的变量.
   1 count_lines_in_etc_passwd()
   2 {
   3   [[ -r /etc/passwd ]] && REPLY=$(echo $(wc -l < /etc/passwd))
   4   #  如果/etc/passwd可读，则把REPLY设置成文件的行数.
   5   #  返回一个参数值和状态信息.
   6   #  'echo'好像没有必要，但 . . .
   7   #+ 它的作用是删除输出中的多余空白字符.
   8 }
   9 
  10 if count_lines_in_etc_passwd
  11 then
  12   echo "There are $REPLY lines in /etc/passwd."
  13 else
  14   echo "Cannot count lines in /etc/passwd."
  15 fi  
  16 
  17 # Thanks, S.C.

例子 23-8. 把数字转化成罗马数字

   1 #!/bin/bash
   2 
   3 # 阿拉伯数字转化为罗马数字
   4 # 转化范围: 0 - 200
   5 # 这是比较粗糙的,但可以工作.
   6 
   7 # 扩展可接受的范围来作为脚本功能的扩充，这个作为练习完成.
   8 
   9 # 用法: roman number-to-convert
  10 
  11 LIMIT=200
  12 E_ARG_ERR=65
  13 E_OUT_OF_RANGE=66
  14 
  15 if [ -z "$1" ]
  16 then
  17   echo "Usage: `basename $0` number-to-convert"
  18   exit $E_ARG_ERR
  19 fi  
  20 
  21 num=$1
  22 if [ "$num" -gt $LIMIT ]
  23 then
  24   echo "Out of range!"
  25   exit $E_OUT_OF_RANGE
  26 fi  
  27 
  28 to_roman ()   # 在第一次调用函数前必须先定义.
  29 {
  30 number=$1
  31 factor=$2
  32 rchar=$3
  33 let "remainder = number - factor"
  34 while [ "$remainder" -ge 0 ]
  35 do
  36   echo -n $rchar
  37   let "number -= factor"
  38   let "remainder = number - factor"
  39 done  
  40 
  41 return $number
  42        # 练习:
  43        # --------
  44        # 解释这个函数是怎么工作的.
  45        # 提示: 靠不断地除来分割数字.
  46 }
  47    
  48 
  49 to_roman $num 100 C
  50 num=$?
  51 to_roman $num 90 LXXXX
  52 num=$?
  53 to_roman $num 50 L
  54 num=$?
  55 to_roman $num 40 XL
  56 num=$?
  57 to_roman $num 10 X
  58 num=$?
  59 to_roman $num 9 IX
  60 num=$?
  61 to_roman $num 5 V
  62 num=$?
  63 to_roman $num 4 IV
  64 num=$?
  65 to_roman $num 1 I
  66 
  67 echo
  68 
  69 exit 0
也参考例子 10-28.

	
函数最大可返回的正整数为255. return 命令与退出状态(exit status)的概念联系很紧密，而退出状态的值受此限制。幸运地是有多种(工作区workarounds)来对付这种要求函数返回大整数的情况.

例子 23-9. 测试函数最大的返回值

   1 #!/bin/bash
   2 # return-test.sh
   3 
   4 # 一个函数最大可能返回的值是255.
   5 
   6 return_test ()         # 无论传给函数什么都返回它.
   7 {
   8   return $1
   9 }
  10 
  11 return_test 27         # o.k.
  12 echo $?                # 返回 27.
  13   
  14 return_test 255        # 仍然 o.k.
  15 echo $?                # 返回 255.
  16 
  17 return_test 257        # 错误!
  18 echo $?                # 返回 1 (返回代码指示错误).
  19 
  20 # ======================================================
  21 return_test -151896    # 返回一个大负数可以吗?
  22 echo $?                # 是否会返回 -151896?
  23                        # 显然不会! 只返回了168.
  24 #  Bash 2.05b以前的版本允许返回大负数.
  25 #
  26 #  更新的Bash版本取消了这个问题.
  27 #  请小心! 这可能会使原先的脚本出现问题.
  28 #  
  29 # ======================================================
  30 
  31 exit 0
一种获取大整数的"返回值"的办法是简单地将要返回的值赋给一个全局变量.
   1 Return_Val=   # 用于保存函数返回巨大值的全局变量.
   2 
   3 alt_return_test ()
   4 {
   5   fvar=$1
   6   Return_Val=$fvar
   7   return   # 返回 0 (指示成功).
   8 }
   9 
  10 alt_return_test 1
  11 echo $?                              # 0
  12 echo "return value = $Return_Val"    # 1
  13 
  14 alt_return_test 256
  15 echo "return value = $Return_Val"    # 256
  16 
  17 alt_return_test 257
  18 echo "return value = $Return_Val"    # 257
  19 
  20 alt_return_test 25701
  21 echo "return value = $Return_Val"    #25701

更优雅的做法是在函数用 echo 打印"返回值到标准输出",然后使用命令替换（command substitution）捕捉此值. 参考33.7节中这种用法的讨论.

例子 23-10. 比较两个大整数

   1 #!/bin/bash
   2 # max2.sh: 求两个大整数的较大值.
   3 
   4 #  这是先前 "max.sh" 的修改版本,
   5 #+ 以允许比较大整数.
   6 
   7 EQUAL=0             # 如果两个值相等返回的值.
   8 E_PARAM_ERR=-99999  # 没有足够的参数传递给函数N.
   9 #           ^^^^^^    参数的值超出范围是可以接受的.
  10 
  11 max2 ()             # "返回" 两个整数的较大者.
  12 {
  13 if [ -z "$2" ]
  14 then
  15   echo $E_PARAM_ERR
  16   return
  17 fi
  18 
  19 if [ "$1" -eq "$2" ]
  20 then
  21   echo $EQUAL
  22   return
  23 else
  24   if [ "$1" -gt "$2" ]
  25   then
  26     retval=$1
  27   else
  28     retval=$2
  29   fi
  30 fi
  31 
  32 echo $retval        # 打印(到标准输出), 而不是用return返回值.
  33                     # 为什么?
  34 }
  35 
  36 
  37 return_val=$(max2 33001 33997)
  38 #            ^^^^             函数名
  39 #                 ^^^^^ ^^^^^ 传递的参数
  40 #  这是命令替换格式的一种:
  41 #+ 可以把函数当成一个命令看待,
  42 #+ 并把函数的标准输出赋值给变量"return_val."
  43 
  44 
  45 # ========================= 输出 ========================
  46 if [ "$return_val" -eq "$E_PARAM_ERR" ]
  47   then
  48   echo "Error in parameters passed to comparison function!"
  49 elif [ "$return_val" -eq "$EQUAL" ]
  50   then
  51     echo "The two numbers are equal."
  52 else
  53     echo "The larger of the two numbers is $return_val."
  54 fi
  55 # =========================================================
  56   
  57 exit 0
  58 
  59 #  练习:
  60 #  ---------
  61 #  1) 找一种测试传递给函数的参数更优雅的办法.
  62 #
  63 #  2) 简化"输出"段的if/then结构
  64 #  3) 重写脚本使脚本能从命令行参数中取得要比较的整数.
  
  例子 23-11. 用户名的真实名Real name from username

   1 #!/bin/bash
   2 # realname.sh
   3 #
   4 # 由用户名而从/etc/passwd取得"真实名".
   5 
   6 
   7 ARGCOUNT=1       # 需要一个参数.
   8 E_WRONGARGS=65
   9 
  10 file=/etc/passwd
  11 pattern=$1
  12 
  13 if [ $# -ne "$ARGCOUNT" ]
  14 then
  15   echo "Usage: `basename $0` USERNAME"
  16   exit $E_WRONGARGS
  17 fi  
  18 
  19 file_excerpt ()  # 以要求的模式来扫描文件，然后打印文件相关的部分.
  20 {
  21 while read line  # "while" does not necessarily need "[ condition ]"
  22 do
  23   echo "$line" | grep $1 | awk -F":" '{ print $5 }'  # awk指定使用":"为界定符.
  24 done
  25 } <$file  # 重定向函数的标准输入.
  26 
  27 file_excerpt $pattern
  28 
  29 # Yes, this entire script could be reduced to
  30 #       grep PATTERN /etc/passwd | awk -F":" '{ print $5 }'
  31 # or
  32 #       awk -F: '/PATTERN/ {print $5}'
  33 # or
  34 #       awk -F: '($1 == "username") { print $5 }' # real name from username
  35 # 但是,这些可能起不到示例的作用.
  36 
  37 exit 0
还有一个办法，可能是更好理解的重定向函数标准输入方法。它为函数内的一个括号内的代码块调用标准输入重定向.
   1 # 用下面的代替:
   2 Function ()
   3 {
   4  ...
   5  } < file
   6 
   7 # 也试一下这个:
   8 Function ()
   9 {
  10   {
  11     ...
  12    } < file
  13 }
  14 
  15 # 同样,
  16 
  17 Function ()  # 可以工作.
  18 {
  19   {
  20    echo $*
  21   } | tr a b
  22 }
  23 
  24 Function ()  # 这个不会工作
  25 {
  26   echo $*
  27 } | tr a b   # 这儿的内嵌代码块是强制的.
  28 
  29 
  30 # Thanks, S.C.
  
  "与列表(and list)"和"或列表(or list)" 结构提供一种处理一串连续命令的方法. 它们能有效地替代复杂的嵌套if/then语句甚至可以代替case语句.

连接命令

与列表(and list)
   1 command-1 && command-2 && command-3 && ... command-n
如果每个命令都返回真值(0)将会依次执行下去. 当某个命令返回假值(非零值), 整个命令链就会结束执行(第一个返回假的命令将会是最后一个执行的命令，后面的都不再执行).

例子 25-1. 使用"与列表(and list)"来测试命令行参数

   1 #!/bin/bash
   2 # "and list"
   3 
   4 if [ ! -z "$1" ] && echo "Argument #1 = $1" && [ ! -z "$2" ] && echo "Argument #2 = $2"
   5 then
   6   echo "At least 2 arguments passed to script."
   7   # 所有连接起来的命令都返回真.
   8 else
   9   echo "Less than 2 arguments passed to script."
  10   # 整个命令列表中至少有一个命令返回假值.
  11 fi  
  12 # 注意"if [ ! -z $1 ]" 可以工作,但它是有所假定的等价物,
  13 #   if [ -n $1 ] 不会工作.
  14 #     但是, 加引用可以让它工作.
  15 #  if [ -n "$1" ] 就可以了.
  16 #     小心!
  17 # 最好总是引起要测试的变量.
  18 
  19 
  20 # 这是使用"纯粹"的 if/then 语句完成的同等功能.
  21 if [ ! -z "$1" ]
  22 then
  23   echo "Argument #1 = $1"
  24 fi
  25 if [ ! -z "$2" ]
  26 then
  27   echo "Argument #2 = $2"
  28   echo "At least 2 arguments passed to script."
  29 else
  30   echo "Less than 2 arguments passed to script."
  31 fi
  32 # 这会更长且不如"与列表"精致.
  33 
  34 
  35 exit 0
例子 25-2. 用"与列表"的另一个命令行参数测试

   1 #!/bin/bash
   2 
   3 ARGS=1        # 期望的参数个数.
   4 E_BADARGS=65  # 如果用户给出不正确的参数个数的退出码.
   5 
   6 test $# -ne $ARGS && echo "Usage: `basename $0` $ARGS argument(s)" && exit $E_BADARGS
   7 #  如果 条件1 测试为真(表示传给脚本的参数不对),
   8 #+ 则余下的命令会被执行，并且脚本结束运行.
   9 
  10 # 下面的代码只有当上面的测试失败时才会执行.
  11 echo "Correct number of arguments passed to this script."
  12 
  13 exit 0
  14 
  15 # 为了检查退出码，脚本结束后用"echo $?"来查看退出码.

当然,一个与列表也能给变量设置默认值.
   1 arg1=$@       # 不管怎样，设置变量$arg1为命令行参数.
   2 
   3 [ -z "$arg1" ] && arg1=DEFAULT
   4               # 如果没有在命令行上指定参数则把$arg1设置为DEFAULT.
或列表(or list)
   1 command-1 || command-2 || command-3 || ... command-n
只要前一个命令返回假命令链就会依次执行下去. 一旦有一个命令返回真, 命令链就会结束(第一个返回真的命令将会是最后一个执行的命令). 这显然和"与列表"正好相反.

例子 25-3. "或列表"和"与列表"的结合使用

   1 #!/bin/bash
   2 
   3 #  delete.sh, 不是很聪明的文件删除功能.
   4 #  用法: delete filename
   5 
   6 E_BADARGS=65
   7 
   8 if [ -z "$1" ]
   9 then
  10   echo "Usage: `basename $0` filename"
  11   exit $E_BADARGS  # 没有参数? 跳出脚本.
  12 else  
  13   file=$1          # 设置文件名.
  14 fi  
  15 
  16 
  17 [ ! -f "$file" ] && echo "File \"$file\" not found. \
  18 Cowardly refusing to delete a nonexistent file."
  19 # 与列表, 用于文件不存在时给出一个错误信息.
  20 # 注意 echo 命令的参数用了一个转义符继续使第二行也是这个命令的参数.
  21 
  22 [ ! -f "$file" ] || (rm -f $file; echo "File \"$file\" deleted.")
  23 # 或列表, 用于存在文件时删除此文件.
  24 
  25 # 注意上面两个相反的逻辑.
  26 # 与列表为真时才执行, 或列表为假时执行.
  27 
  28 exit 0
  
  例子 27-2. 搜索与一个PID相关的进程

   1 #!/bin/bash
   2 # pid-identifier.sh: 给出指定PID的进程的程序全路径.
   3 
   4 ARGNO=1  # 此脚本期望的参数个数.
   5 E_WRONGARGS=65
   6 E_BADPID=66
   7 E_NOSUCHPROCESS=67
   8 E_NOPERMISSION=68
   9 PROCFILE=exe
  10 
  11 if [ $# -ne $ARGNO ]
  12 then
  13   echo "Usage: `basename $0` PID-number" >&2  # 帮助信息重定向到标准出错.
  14   exit $E_WRONGARGS
  15 fi  
  16 
  17 pidno=$( ps ax | grep $1 | awk '{ print $1 }' | grep $1 )
  18 # 搜索命令"ps"输出的第一列.
  19 # 然后再次确认是真正我们要寻找的进程，而不是这个脚本调用而产生的进程.
  20 # 后一个"grep $1"会滤掉这个可能产生的进程.
  21 #
  22 #    pidno=$( ps ax | awk '{ print $1 }' | grep $1 )
  23 #    也可以, 由 Teemu Huovila指出.
  24 
  25 if [ -z "$pidno" ]  # 如果过滤完后结果是一个空字符串,
  26 then                # 没有对应的PID进程在运行.
  27   echo "No such process running."
  28   exit $E_NOSUCHPROCESS
  29 fi  
  30 
  31 # 也可以用:
  32 #   if ! ps $1 > /dev/null 2>&1
  33 #   then                # 没有对应的PID进程在运行.
  34 #     echo "No such process running."
  35 #     exit $E_NOSUCHPROCESS
  36 #    fi
  37 
  38 # 为了简化整个进程，使用"pidof".
  39 
  40 
  41 if [ ! -r "/proc/$1/$PROCFILE" ]  # 检查读权限.
  42 then
  43   echo "Process $1 running, but..."
  44   echo "Can't get read permission on /proc/$1/$PROCFILE."
  45   exit $E_NOPERMISSION  # 普通用户不能存取/proc目录的某些文件.
  46 fi  
  47 
  48 # 最后两个测试可以用下面的代替:
  49 #    if ! kill -0 $1 > /dev/null 2>&1 # '0'不是一个信号，
  50                                       # 但这样可以测试是否可以
  51                                       # 向该进程发送信号.
  52 #    then echo "PID doesn't exist or you're not its owner" >&2
  53 #    exit $E_BADPID
  54 #    fi
  55 
  56 
  57 
  58 exe_file=$( ls -l /proc/$1 | grep "exe" | awk '{ print $11 }' )
  59 # 或       exe_file=$( ls -l /proc/$1/exe | awk '{print $11}' )
  60 #
  61 # /proc/pid-number/exe 是进程程序全路径的符号链接。
  62 #
  63 
  64 if [ -e "$exe_file" ]  # 如果 /proc/pid-number/exe 存在 ...
  65 then                 # 则相应的进程存在.
  66   echo "Process #$1 invoked by $exe_file."
  67 else
  68   echo "No such process running."
  69 fi  
  70 
  71 
  72 # 这个被详细讲解的脚本几乎可以用下面的命令代替：
  73 # ps ax | grep $1 | awk '{ print $5 }'
  74 # 然而, 这样并不会工作...
  75 # 因为'ps'输出的第5列是进程的argv[0]（即命令行第一个参数，调用时程序用的程序路径本身）,
  76 # 但不是可执行文件.
  77 #
  78 # 然而, 下面的两个都可以工作.
  79 #       find /proc/$1/exe -printf '%l\n'
  80 #       lsof -aFn -p $1 -d txt | sed -ne 's/^n//p'
  81 
  82 # 由Stephane Chazelas附加注释.
  83 
  84 exit 0
例子 27-3. 网络连接状态

   1 #!/bin/bash
   2 
   3 PROCNAME=pppd        # ppp 守护进程
   4 PROCFILENAME=status  # 在这儿寻找信息.
   5 NOTCONNECTED=65
   6 INTERVAL=2           # 两秒刷新一次.
   7 
   8 pidno=$( ps ax | grep -v "ps ax" | grep -v grep | grep $PROCNAME | awk '{ print $1 }' )
   9 # 搜索ppp守护进程'pppd'的进程号.
  10 # 一定要过滤掉由搜索进程产生的该行进程.
  11 #
  12 #  正如Oleg Philon指出的那样,
  13 #+ 使用"pidof"命令会相当的简单.
  14 #  pidno=$( pidof $PROCNAME )
  15 #
  16 #  颇有良心的建议:
  17 #+ 当命令序列变得复杂的时候，去寻找更简洁的办法。 .
  18 
  19 
  20 if [ -z "$pidno" ]   # 如果没有找到此进程号,则进程没有运行.
  21 then
  22   echo "Not connected."
  23   exit $NOTCONNECTED
  24 else
  25   echo "Connected."; echo
  26 fi
  27 
  28 while [ true ]       # 死循环，这儿可以有所改进.
  29 do
  30 
  31   if [ ! -e "/proc/$pidno/$PROCFILENAME" ]
  32   # 进程运行时，对应的"status"文件会存在.
  33   then
  34     echo "Disconnected."
  35     exit $NOTCONNECTED
  36   fi
  37 
  38 netstat -s | grep "packets received"  # 取得一些连接统计.
  39 netstat -s | grep "packets delivered"
  40 
  41 
  42   sleep $INTERVAL
  43   echo; echo
  44 
  45 done
  46 
  47 exit 0
  48 
  49 # 当要停止它时，可以用Control-C终止.
  50 
  51 #    练习:
  52 #    ---------
  53 #    改进这个脚本，使它能按"q"键退出.
  54 #    给脚本更友好的界面.
	
一般来说, 写/proc目录里的文件是危险 ,因为这样会破坏这个文件系统或摧毁机器.
	
一些系统命令, 例如 procinfo, free, vmstat, lsdev, 和uptime 也能做类似 的事情.

例子 28-2. 用/dev/zero创建一个交换临时文件

   1 #!/bin/bash
   2 # 创建一个交换文件.
   3 
   4 ROOT_UID=0         # Root 用户的 $UID 是 0.
   5 E_WRONG_USER=65    # 不是 root?
   6 
   7 FILE=/swap
   8 BLOCKSIZE=1024
   9 MINBLOCKS=40
  10 SUCCESS=0
  11 
  12 
  13 # 这个脚本必须用root来运行.
  14 if [ "$UID" -ne "$ROOT_UID" ]
  15 then
  16   echo; echo "You must be root to run this script."; echo
  17   exit $E_WRONG_USER
  18 fi  
  19   
  20 
  21 blocks=${1:-$MINBLOCKS}          #  如果命令行没有指定，
  22                                  #+ 则设置为默认的40块.
  23 # 上面这句等同如：
  24 # --------------------------------------------------
  25 # if [ -n "$1" ]
  26 # then
  27 #   blocks=$1
  28 # else
  29 #   blocks=$MINBLOCKS
  30 # fi
  31 # --------------------------------------------------
  32 
  33 
  34 if [ "$blocks" -lt $MINBLOCKS ]
  35 then
  36   blocks=$MINBLOCKS              # 最少要有 40 个块长.
  37 fi  
  38 
  39 
  40 echo "Creating swap file of size $blocks blocks (KB)."
  41 dd if=/dev/zero of=$FILE bs=$BLOCKSIZE count=$blocks  # 把零写入文件.
  42 
  43 mkswap $FILE $blocks             # 将此文件建为交换文件（或称交换分区）.
  44 swapon $FILE                     # 激活交换文件.
  45 
  46 echo "Swap file created and activated."
  47 
  48 exit $SUCCESS
  
  例子 28-3. 创建ramdisk

   1 #!/bin/bash
   2 # ramdisk.sh
   3 
   4 #  "ramdisk"是系统RAM内存的一段，
   5 #+ 它可以被当成是一个文件系统来操作.
   6 #  它的优点是存取速度非常快 (包括读和写).
   7 #  缺点: 易失性, 当计算机重启或关机时会丢失数据.
   8 #+       会减少系统可用的RAM.
   9 #
  10 #  那么ramdisk有什么作用呢?
  11 #  保存一个较大的数据集在ramdisk, 比如一张表或字典,
  12 #+ 这样可以加速数据查询, 因为在内存里查找比在磁盘里查找快得多.
  13 
  14 
  15 E_NON_ROOT_USER=70             # 必须用root来运行.
  16 ROOTUSER_NAME=root
  17 
  18 MOUNTPT=/mnt/ramdisk
  19 SIZE=2000                      # 2K 个块 (可以合适的做修改)
  20 BLOCKSIZE=1024                 # 每块有1K (1024 byte) 的大小
  21 DEVICE=/dev/ram0               # 第一个 ram 设备
  22 
  23 username=`id -nu`
  24 if [ "$username" != "$ROOTUSER_NAME" ]
  25 then
  26   echo "Must be root to run \"`basename $0`\"."
  27   exit $E_NON_ROOT_USER
  28 fi
  29 
  30 if [ ! -d "$MOUNTPT" ]         #  测试挂载点是否已经存在了,
  31 then                           #+ 如果这个脚本已经运行了好几次了就不会再建这个目录了
  32   mkdir $MOUNTPT               #+ 因为前面已经建立了.
  33 fi
  34 
  35 dd if=/dev/zero of=$DEVICE count=$SIZE bs=$BLOCKSIZE  # 把RAM设备的内容用零填充.
  36                                                       # 为何需要这么做?
  37 mke2fs $DEVICE                 # 在RAM设备上创建一个ext2文件系统.
  38 mount $DEVICE $MOUNTPT         # 挂载设备.
  39 chmod 777 $MOUNTPT             # 使普通用户也可以存取这个ramdisk.
  40                                # 但是, 只能由root来缷载它.
  41 
  42 echo "\"$MOUNTPT\" now available for use."
  43 # 现在 ramdisk 即使普通用户也可以用来存取文件了.
  44 
  45 #  注意, ramdisk是易失的, 所以当计算机系统重启或关机时ramdisk里的内容会消失.
  46 #
  47 #  拷贝所有你想保存文件到一个常规的磁盘目录下.
  48 
  49 # 重启之后, 运行这个脚本再次建立起一个 ramdisk.
  50 # 仅重新加载 /mnt/ramdisk 而没有其他的步骤将不会正确工作.
  51 
  52 #  如果加以改进, 这个脚本可以放在 /etc/rc.d/rc.local,
  53 #+ 以使系统启动时能自动设立一个ramdisk.
  54 #  这样很合适速度要求高的数据库服务器.
  55 
  56 exit 0
  
  例子 33-1. shell 包装

   1 #!/bin/bash
   2 
   3 # 这是一个把文件中的空行删除的简单脚本.
   4 # 没有参数检查.
   5 #
   6 # 你可能想增加类似下面的代码:
   7 #
   8 # E_NOARGS=65
   9 # if [ -z "$1" ]
  10 # then
  11 #  echo "Usage: `basename $0` target-file"
  12 #  exit $E_NOARGS
  13 # fi
  14 
  15 
  16 # 就像从命令行调用下面的命令：
  17 #    sed -e '/^$/d' filename
  18 #
  19 
  20 sed -e /^$/d "$1"
  21 #  The '-e' 意味着后面跟的是编辑命令 (这是可选的).
  22 #  '^' 匹配行的开头, '$' 则是行的结尾.
  23 #  这个表达式匹配行首和行尾之间什么也没有的行,
  24 #+ 即空白行.
  25 #  'd'是删除命令.
  26 
  27 #  引号引起命令行参数就允许在文件名中使用空白字符和特殊字符
  28 #
  29 
  30 #  注意这个脚本不能真正的修改目标文件.
  31 #  如果你需要保存修改，就要重定向到某个输出文件里.
  32 
  33 exit 0
例子 33-2. 稍微复杂一些的shell包装

   1 #!/bin/bash
   2 
   3 #  "subst", 把一个文件中的一个模式替换成一个模式的脚本
   4 #
   5 #  例如, "subst Smith Jones letter.txt".
   6 
   7 ARGS=3         # 脚本要求三个参数.
   8 E_BADARGS=65   # 传递了错误的参数个数给脚本.
   9 
  10 if [ $# -ne "$ARGS" ]
  11 # 测试脚本参数的个数 (这是好办法).
  12 then
  13   echo "Usage: `basename $0` old-pattern new-pattern filename"
  14   exit $E_BADARGS
  15 fi
  16 
  17 old_pattern=$1
  18 new_pattern=$2
  19 
  20 if [ -f "$3" ]
  21 then
  22     file_name=$3
  23 else
  24     echo "File \"$3\" does not exist."
  25     exit $E_BADARGS
  26 fi
  27 
  28 
  29 #  这儿是实现功能的代码.
  30 
  31 # -----------------------------------------------
  32 sed -e "s/$old_pattern/$new_pattern/g" $file_name
  33 # -----------------------------------------------
  34 
  35 #  's' 在sed命令里表示替换,
  36 #+ /pattern/表示匹配地址.
  37 #  The "g"也叫全局标志使sed会在每一行有$old_pattern模式出现的所有地方替换,
  38 #+ 而不只是匹配第一个出现的地方.
  39 #  参考'sed'的有关书籍了解更深入的解释.
  40 
  41 exit 0    # 脚本成功调用会返回 0.
例子 33-3. 写到日志文件的shell包装

   1 #!/bin/bash
   2 #  普通的shell包装，执行一个操作并记录在日志里
   3 #
   4 
   5 # 需要设置下面的两个变量.
   6 OPERATION=
   7 #         可以是一个复杂的命令链,
   8 #+        例如awk脚本或是管道 . . .
   9 LOGFILE=
  10 #         不管怎么样，命令行参数还是要提供给操作的.
  11 
  12 
  13 OPTIONS="$@"
  14 
  15 
  16 # 记录操作.
  17 echo "`date` + `whoami` + $OPERATION "$@"" >> $LOGFILE
  18 # 现在, 执行操作.
  19 exec $OPERATION "$@"
  20 
  21 # 在操作之前记录日志是必须的.
  22 # 为什么?
  
  例子 33-8. 递归调用自己本身的（无用）脚本

   1 #!/bin/bash
   2 # recurse.sh
   3 
   4 #  脚本能否递归地调用自己?
   5 #  是的, 但这有什么实际的用处吗?
   6 #  (看下面的.)
   7 
   8 RANGE=10
   9 MAXVAL=9
  10 
  11 i=$RANDOM
  12 let "i %= $RANGE"  # 产生一个从 0 到 $RANGE - 1 之间的随机数.
  13 
  14 if [ "$i" -lt "$MAXVAL" ]
  15 then
  16   echo "i = $i"
  17   ./$0             #  脚本递归地调用再生成一个和自己一样的实例.
  18 fi                 #  每个子脚本做的事都一样,
  19                    #+ 直到产生的变量 $i 和变量 $MAXVAL 相等.
  20 
  21 #  用"while"循环代替"if/then"测试会引起错误.
  22 #  解释为什么会这样.
  23 
  24 exit 0
  25 
  26 # 注:
  27 # ----
  28 # 脚本要正确地工作必须有执行权限.
  29 # 这是指用"sh"命令来调用这个脚本而没有设置正确权限导致的问题.
  30 # 请解释原因.
例子 33-9. 递归调用自己本身的（有用）脚本

   1 #!/bin/bash
   2 # pb.sh: 电话本（phone book）
   3 
   4 # 由Rick Boivie编写,已得到使用许可.
   5 # 由ABS文档作者修改.
   6 
   7 MINARGS=1     #  脚本需要至少一个参数.
   8 DATAFILE=./phonebook
   9               #  在当前目录下名为"phonebook"的数据文件必须存在
  10               #
  11 PROGNAME=$0
  12 E_NOARGS=70   #  没有参数的错误值.
  13 
  14 if [ $# -lt $MINARGS ]; then
  15       echo "Usage: "$PROGNAME" data"
  16       exit $E_NOARGS
  17 fi      
  18 
  19 
  20 if [ $# -eq $MINARGS ]; then
  21       grep $1 "$DATAFILE"
  22       #  如果$DATAFILE文件不存在，'grep' 会打印一个错误信息.
  23 else
  24       ( shift; "$PROGNAME" $* ) | grep $1
  25       # 脚本递归调用本身.
  26 fi
  27 
  28 exit 0        #  脚本在这儿退出.
  29               #  因此Therefore, 从这行开始可以写没有#开头的的注释行
  30 	      #
  31 
  32 # ------------------------------------------------------------------------
  33 "phonebook"文件的例子:
  34 
  35 John Doe        1555 Main St., Baltimore, MD 21228          (410) 222-3333
  36 Mary Moe        9899 Jones Blvd., Warren, NH 03787          (603) 898-3232
  37 Richard Roe     856 E. 7th St., New York, NY 10009          (212) 333-4567
  38 Sam Roe         956 E. 8th St., New York, NY 10009          (212) 444-5678
  39 Zoe Zenobia     4481 N. Baker St., San Francisco, SF 94338  (415) 501-1631
  40 # ------------------------------------------------------------------------
  41 
  42 $bash pb.sh Roe
  43 Richard Roe     856 E. 7th St., New York, NY 10009          (212) 333-4567
  44 Sam Roe         956 E. 8th St., New York, NY 10009          (212) 444-5678
  45 
  46 $bash pb.sh Roe Sam
  47 Sam Roe         956 E. 8th St., New York, NY 10009          (212) 444-5678
  48 
  49 #  当超过一个参数传给这个脚本时,
  50 #+ 它只打印包含所有参数的行.
例子 33-10. 另一个递归调用自己本身的（有用）脚本

   1 #!/bin/bash
   2 # usrmnt.sh, 由Anthony Richardson编写
   3 # 得到允许在此使用.
   4 
   5 # usage:       usrmnt.sh
   6 # 描述: 挂载设备, 调用者必须列在/etc/sudoers文件的MNTUSERS组里
   7 #
   8 
   9 # ----------------------------------------------------------
  10 #  这是一个用户挂载设备的脚本，它用sudo来调用自己.
  11 #  只有拥有合适权限的用户才能用
  12 
  13 #   usermount /dev/fd0 /mnt/floppy
  14 
  15 # 来代替
  16 
  17 #   sudo usermount /dev/fd0 /mnt/floppy
  18 
  19 #  我使用相同的技术来处理我所有的sudo脚本, 
  20 #+ 因为我觉得它很方便.
  21 # ----------------------------------------------------------
  22 
  23 #  如果 SUDO_COMMAND 变量没有设置，我们不能通过sudo来运行脚本本身.
  24 #+ 传递用户的真实ID和组ID . . .
  25 
  26 if [ -z "$SUDO_COMMAND" ]
  27 then
  28    mntusr=$(id -u) grpusr=$(id -g) sudo $0 $*
  29    exit 0
  30 fi
  31 
  32 # 如果我们以sudo来调用运行，就会运行这儿.
  33 /bin/mount $* -o uid=$mntusr,gid=$grpusr
  34 
  35 exit 0
  36 
  37 # 附注 (由脚本作者加注): 
  38 # -------------------------------------------------
  39 
  40 # 1) Linux允许在/etc/fstab文件中使用"users"选项 
  41 #    以使任何用户能挂载可移动的介质.
  42 #    但是, 在一个服务器上, 
  43 #    我只想有限的几个用户可以存取可移动介质.
  44 #    我发现使用sudo可以有更多的控制.
  45 
  46 # 2) 我也发现sudo能通过组更方便地达成目的.
  47 # 
  48 
  49 # 3) 这个方法使给予任何想给合适权限的人使用mount命令
  50 #    所以要小心使用.
  51 #    你也可以开发类似的脚本mntfloppy, mntcdrom,和 mntsamba来使mount命令得到更好的控制
  52 # 
  53 # 
  54 # 
	
过多层次的递归调用会耗尽脚本的堆栈空间，会引起段错误.

例子 33-11. 一个 "彩色的" 地址资料库

   1 #!/bin/bash
   2 # ex30a.sh: ex30.sh的"彩色" 版本.
   3 #            没有加工处理的地址资料库
   4 
   5 
   6 clear                                   # 清除屏幕.
   7 
   8 echo -n "          "
   9 echo -e '\E[37;44m'"\033[1mContact List\033[0m"
  10                                         # 白色为前景色，蓝色为背景色
  11 echo; echo
  12 echo -e "\033[1mChoose one of the following persons:\033[0m"
  13                                         # 粗体
  14 tput sgr0
  15 echo "(Enter only the first letter of name.)"
  16 echo
  17 echo -en '\E[47;34m'"\033[1mE\033[0m"   # 蓝色
  18 tput sgr0                               # 把色彩设置为"常规"
  19 echo "vans, Roland"                     # "[E]vans, Roland"
  20 echo -en '\E[47;35m'"\033[1mJ\033[0m"   # 红紫色
  21 tput sgr0
  22 echo "ones, Mildred"
  23 echo -en '\E[47;32m'"\033[1mS\033[0m"   # 绿色
  24 tput sgr0
  25 echo "mith, Julie"
  26 echo -en '\E[47;31m'"\033[1mZ\033[0m"   # 红色
  27 tput sgr0
  28 echo "ane, Morris"
  29 echo
  30 
  31 read person
  32 
  33 case "$person" in
  34 # 注意变量被引起来了.
  35 
  36   "E" | "e" )
  37   # 接受大小写的输入.
  38   echo
  39   echo "Roland Evans"
  40   echo "4321 Floppy Dr."
  41   echo "Hardscrabble, CO 80753"
  42   echo "(303) 734-9874"
  43   echo "(303) 734-9892 fax"
  44   echo "revans@zzy.net"
  45   echo "Business partner & old friend"
  46   ;;
  47 
  48   "J" | "j" )
  49   echo
  50   echo "Mildred Jones"
  51   echo "249 E. 7th St., Apt. 19"
  52   echo "New York, NY 10009"
  53   echo "(212) 533-2814"
  54   echo "(212) 533-9972 fax"
  55   echo "milliej@loisaida.com"
  56   echo "Girlfriend"
  57   echo "Birthday: Feb. 11"
  58   ;;
  59 
  60 # 稍后为 Smith 和 Zane 增加信息.
  61 
  62           * )
  63    # 默认选项Default option.	  
  64    # 空的输入(直接按了回车) 也会匹配这儿.
  65    echo
  66    echo "Not yet in database."
  67   ;;
  68 
  69 esac
  70 
  71 tput sgr0                               # 把色彩重设为"常规".
  72 
  73 echo
  74 
  75 exit 0
例子 33-12. 画盒子

   1 #!/bin/bash
   2 # Draw-box.sh: 用ASCII字符画一个盒子.
   3 
   4 # Stefano Palmeri编写,文档作者作了少量编辑.
   5 # 征得作者同意在本书使用.
   6 
   7 
   8 ######################################################################
   9 ###  draw_box 函数的注释  ###
  10 
  11 #  "draw_box" 函数使用户可以在终端上画一个盒子.
  12 #
  13 #
  14 #  用法: draw_box ROW COLUMN HEIGHT WIDTH [COLOR] 
  15 #  ROW 和 COLUMN 定位要画的盒子的左上角.       
  16 #
  17 #  ROW 和 COLUMN 必须要大于0且小于目前终端的尺寸.
  18 #
  19 #  HEIGHT 是盒子的行数，必须 > 0. 
  20 #  HEIGHT + ROW 必须 <= 终端的高度. 
  21 #  WIDTH 是盒子的列数，必须 > 0.
  22 #  WIDTH + COLUMN 必须 <= 终端的宽度.
  23 #
  24 #  例如: 如果你当前终端的尺寸是 20x80,
  25 #  draw_box 2 3 10 45 是合法的
  26 #  draw_box 2 3 19 45 的 HEIGHT 值是错的 (19+2 > 20)
  27 #  draw_box 2 3 18 78 的 WIDTH 值是错的 (78+3 > 80)
  28 #
  29 #  COLOR 是盒子边框的颜色.
  30 #  它是第5个参数，并且它是可选的.
  31 #  0=黑色 1=红色 2=绿色 3=棕褐色 4=蓝色 5=紫色 6=青色 7=白色.
  32 #  如果你传给这个函数错的参数,
  33 #+ 它就会以代码65退出,
  34 #+ 没有其他的信息打印到标准出错上.
  35 #
  36 #  在画盒子之前要清屏.
  37 #  函数内不包含有清屏命令.
  38 #  这使用户可以画多个盒子，甚至叠接多个盒子.
  39 
  40 ###  draw_box 函数注释结束  ### 
  41 ######################################################################
  42 
  43 draw_box(){
  44 
  45 #=============#
  46 HORZ="-"
  47 VERT="|"
  48 CORNER_CHAR="+"
  49 
  50 MINARGS=4
  51 E_BADARGS=65
  52 #=============#
  53 
  54 
  55 if [ $# -lt "$MINARGS" ]; then                 # 如果参数小于4，退出.
  56     exit $E_BADARGS
  57 fi
  58 
  59 # 搜寻参数中的非数字的字符.
  60 # 能用其他更好的办法吗 (留给读者的练习?).
  61 if echo $@ | tr -d [:blank:] | tr -d [:digit:] | grep . &> /dev/null; then
  62    exit $E_BADARGS
  63 fi
  64 
  65 BOX_HEIGHT=`expr $3 - 1`   #  -1 是需要的，因为因为边角的"+"是高和宽共有的部分. 
  66 BOX_WIDTH=`expr $4 - 1`    #
  67 T_ROWS=`tput lines`        #  定义当前终端长和宽的尺寸， 
  68 T_COLS=`tput cols`         #
  69          
  70 if [ $1 -lt 1 ] || [ $1 -gt $T_ROWS ]; then    #  如果参数是数字就开始检查有效性.
  71    exit $E_BADARGS                             #
  72 fi
  73 if [ $2 -lt 1 ] || [ $2 -gt $T_COLS ]; then
  74    exit $E_BADARGS
  75 fi
  76 if [ `expr $1 + $BOX_HEIGHT + 1` -gt $T_ROWS ]; then
  77    exit $E_BADARGS
  78 fi
  79 if [ `expr $2 + $BOX_WIDTH + 1` -gt $T_COLS ]; then
  80    exit $E_BADARGS
  81 fi
  82 if [ $3 -lt 1 ] || [ $4 -lt 1 ]; then
  83    exit $E_BADARGS
  84 fi                                 # 参数检查完毕.
  85 
  86 plot_char(){                       # 函数内的函数.
  87    echo -e "\E[${1};${2}H"$3
  88 }
  89 
  90 echo -ne "\E[3${5}m"               # 如果传递了盒子边框颜色参数，则设置它.
  91 
  92 # start drawing the box
  93 
  94 count=1                                         #  用plot_char函数画垂直线
  95 for (( r=$1; count<=$BOX_HEIGHT; r++)); do      #
  96   plot_char $r $2 $VERT
  97   let count=count+1
  98 done 
  99 
 100 count=1
 101 c=`expr $2 + $BOX_WIDTH`
 102 for (( r=$1; count<=$BOX_HEIGHT; r++)); do
 103   plot_char $r $c $VERT
 104   let count=count+1
 105 done 
 106 
 107 count=1                                        #  用plot_char函数画水平线
 108 for (( c=$2; count<=$BOX_WIDTH; c++)); do      #
 109   plot_char $1 $c $HORZ
 110   let count=count+1
 111 done 
 112 
 113 count=1
 114 r=`expr $1 + $BOX_HEIGHT`
 115 for (( c=$2; count<=$BOX_WIDTH; c++)); do
 116   plot_char $r $c $HORZ
 117   let count=count+1
 118 done 
 119 
 120 plot_char $1 $2 $CORNER_CHAR                   # 画盒子的角.
 121 plot_char $1 `expr $2 + $BOX_WIDTH` +
 122 plot_char `expr $1 + $BOX_HEIGHT` $2 +
 123 plot_char `expr $1 + $BOX_HEIGHT` `expr $2 + $BOX_WIDTH` +
 124 
 125 echo -ne "\E[0m"             #  恢复最初的颜色.
 126 
 127 P_ROWS=`expr $T_ROWS - 1`    #  在终端的底部打印提示符.
 128 
 129 echo -e "\E[${P_ROWS};1H"
 130 }      
 131 
 132 
 133 # 现在, 让我们来画一个盒子.
 134 clear                       # 清屏.
 135 R=2      # 行
 136 C=3      # 列
 137 H=10     # 高
 138 W=45     # 宽
 139 col=1    # 颜色(红)
 140 draw_box $R $C $H $W $col   # 画盒子.
 141 
 142 exit 0
 143 
 144 # 练习:
 145 # --------
 146 # 增加可以在盒子里打印文本的选项
最简单也可能是最有用的ANSI转义序列是加粗文本, \033[1m ... \033[0m. \033 触发转义序列, 而 "[1" 启用加粗属性, 而"[0" 表示切换回禁用加粗状态. "m"则表示终止一个转义序列.
 bash$ echo -e "\033[1mThis is bold text.\033[0m"
 	      
一种相似的转义序列可切换下划线效果 (在 rxvt 和 aterm 上).
 bash$ echo -e "\033[4mThis is underlined text.\033[0m"
 	      
	
echo使用-e选项可以启用转义序列.

其他的转义序列可用于更改文本或/和背景色彩.

 bash$ echo -e '\E[34;47mThis prints in blue.'; tput sgr0
 
 
 bash$ echo -e '\E[33;44m'"yellow text on blue background"; tput sgr0
 
 
 bash$ echo -e '\E[1;33;44m'"BOLD yellow text on blue background"; tput sgr0
 
 例子 33-13. 显示彩色文本

   1 #!/bin/bash
   2 # color-echo.sh: 用彩色来显示文本.
   3 
   4 # 依照需要修改这个脚本.
   5 # 这比手写彩色的代码更容易一些.
   6 
   7 black='\E[30;47m'
   8 red='\E[31;47m'
   9 green='\E[32;47m'
  10 yellow='\E[33;47m'
  11 blue='\E[34;47m'
  12 magenta='\E[35;47m'
  13 cyan='\E[36;47m'
  14 white='\E[37;47m'
  15 
  16 
  17 alias Reset="tput sgr0"      #  把文本属性重设回原来没有清屏前的
  18                              #
  19 
  20 
  21 cecho ()                     # Color-echo.
  22                              # 参数 $1 = 要显示的信息
  23                              # 参数 $2 = 颜色
  24 {
  25 local default_msg="No message passed."
  26                              # 不是非要一个本地变量.
  27 
  28 message=${1:-$default_msg}   # 默认的信息.
  29 color=${2:-$black}           # 如果没有指定，默认使用黑色.
  30 
  31   echo -e "$color"
  32   echo "$message"
  33   Reset                      # 重设文本属性.
  34 
  35   return
  36 }  
  37 
  38 
  39 # 现在，让我们试试.
  40 # ----------------------------------------------------
  41 cecho "Feeling blue..." $blue
  42 cecho "Magenta looks more like purple." $magenta
  43 cecho "Green with envy." $green
  44 cecho "Seeing red?" $red
  45 cecho "Cyan, more familiarly known as aqua." $cyan
  46 cecho "No color passed (defaults to black)."
  47        # 缺失 $color （色彩）参数.
  48 cecho "\"Empty\" color passed (defaults to black)." ""
  49        # 空的 $color （色彩）参数.
  50 cecho
  51        # $message（信息） 和 $color （色彩）参数都缺失.
  52 cecho "" ""
  53        # 空的 $message （信息）和 $color （色彩）参数.
  54 # ----------------------------------------------------
  55 
  56 echo
  57 
  58 exit 0
  59 
  60 # 练习:
  61 # ---------
  62 # 1) 为'cecho ()'函数增加粗体的效果.
  63 # 2) 增加可选的彩色背景.
例子 33-14. "赛马" 游戏

   1 #!/bin/bash
   2 # horserace.sh: 非常简单的赛马模拟.
   3 # 作者: Stefano Palmeri
   4 # 已取得使用许可.
   5 
   6 ################################################################
   7 #  脚本目的:
   8 #  使用转义字符和终端颜色.
   9 #
  10 #  练习:
  11 #  编辑脚本使其更具有随机性,
  12 #+ 设置一个假的赌场 . . .     
  13 #  嗯 . . . 嗯 . . . 这个开始使我想起了一部电影 . . .
  14 #
  15 #  脚本给每匹马一个随机的障碍.
  16 #  不均等会以障碍来计算
  17 #+ 并且用一种欧洲风格表达出来.
  18 #  例如: 机率(odds)=3.75 意味着如果你押1美元赢,
  19 #+ 你可以赢得3.75美元.
  20 # 
  21 #  脚本已经在GNU/Linux操作系统上测试过 OS,
  22 #+ 测试终端有xterm 和 rxvt, 及 konsole.
  23 #  测试机器有AMD 900 MHz 的处理器,
  24 #+ 平均比赛时间是75秒.    
  25 #  在更快的计算机上比赛时间应该会更低.
  26 #  所以, 如果你想有更多的悬念，重设USLEEP_ARG 变量的值.
  27 #
  28 #  由Stefano Palmeri编写.
  29 ################################################################
  30 
  31 E_RUNERR=65
  32 
  33 # 检查 md5sum 和 bc 是不是安装了. 
  34 if ! which bc &> /dev/null; then
  35    echo bc is not installed.  
  36    echo "Can\'t run . . . "
  37    exit $E_RUNERR
  38 fi
  39 if ! which md5sum &> /dev/null; then
  40    echo md5sum is not installed.  
  41    echo "Can\'t run . . . "
  42    exit $E_RUNERR
  43 fi
  44 
  45 #  更改下面的变量值可以使脚本执行的更慢.
  46 #  它会作为usleep的参数 (man usleep)  
  47 #+ 并且它的单位是微秒 (500000微秒 = 半秒).
  48 USLEEP_ARG=0  
  49 
  50 #  如果脚本接收到ctrl-c中断，清除临时目录, 恢复终端光标和颜色 
  51 #
  52 trap 'echo -en "\E[?25h"; echo -en "\E[0m"; stty echo;\
  53 tput cup 20 0; rm -fr  $HORSE_RACE_TMP_DIR'  TERM EXIT
  54 #  参考调试的章节了解'trap'的更多解释
  55 
  56 # 给脚本设置一个唯一（实际不是绝对唯一的）的临时目录名.
  57 HORSE_RACE_TMP_DIR=$HOME/.horserace-`date +%s`-`head -c10 /dev/urandom | md5sum | head -c30`
  58 
  59 # 创建临时目录，并切换到该目录下.
  60 mkdir $HORSE_RACE_TMP_DIR
  61 cd $HORSE_RACE_TMP_DIR
  62 
  63 
  64 #  这个函数把光标移动到行为 $1 列为 $2 然后打印 $3.
  65 #  例如: "move_and_echo 5 10 linux" 等同于
  66 #+ "tput cup 4 9; echo linux", 但是用一个命令代替了两个.
  67 #  注: "tput cup" 表示在终端左上角的 0 0 位置,
  68 #+ echo 是在终端的左上角的 1 1 位置.
  69 move_and_echo() {
  70           echo -ne "\E[${1};${2}H""$3" 
  71 }
  72 
  73 # 产生1-9之间伪随机数的函数. 
  74 random_1_9 () {
  75                 head -c10 /dev/urandom | md5sum | tr -d [a-z] | tr -d 0 | cut -c1 
  76 }
  77 
  78 #  画马时模拟运动的两个函数. 
  79 draw_horse_one() {
  80                echo -n " "//$MOVE_HORSE//
  81 }
  82 draw_horse_two(){
  83               echo -n " "\\\\$MOVE_HORSE\\\\ 
  84 }   
  85 
  86 
  87 # 取得当前的终端尺寸.
  88 N_COLS=`tput cols`
  89 N_LINES=`tput lines`
  90 
  91 # 至少需要 20-行 X 80-列 的终端尺寸. 检查一下.
  92 if [ $N_COLS -lt 80 ] || [ $N_LINES -lt 20 ]; then
  93    echo "`basename $0` needs a 80-cols X 20-lines terminal."
  94    echo "Your terminal is ${N_COLS}-cols X ${N_LINES}-lines."
  95    exit $E_RUNERR
  96 fi
  97 
  98 
  99 # 开始画赛场.
 100 
 101 # 需要一个80个字符的字符串，看下面的.
 102 BLANK80=`seq -s "" 100 | head -c80`
 103 
 104 clear
 105 
 106 # 把前景和背景颜色设置成白色的.
 107 echo -ne '\E[37;47m'
 108 
 109 # 把光标移到终端的左上角.
 110 tput cup 0 0 
 111 
 112 # 画六条白线.
 113 for n in `seq 5`; do
 114       echo $BLANK80        # 线是用80个字符组成的字符串.  
 115 done
 116 
 117 # 把前景色设置成黑色. 
 118 echo -ne '\E[30m'
 119 
 120 move_and_echo 3 1 "START  1"            
 121 move_and_echo 3 75 FINISH
 122 move_and_echo 1 5 "|"
 123 move_and_echo 1 80 "|"
 124 move_and_echo 2 5 "|"
 125 move_and_echo 2 80 "|"
 126 move_and_echo 4 5 "|  2"
 127 move_and_echo 4 80 "|"
 128 move_and_echo 5 5 "V  3"
 129 move_and_echo 5 80 "V"
 130 
 131 # 把前景色设置成红色. 
 132 echo -ne '\E[31m'
 133 
 134 # 一些ASCII艺术.
 135 move_and_echo 1 8 "..@@@..@@@@@...@@@@@.@...@..@@@@..."
 136 move_and_echo 2 8 ".@...@...@.......@...@...@.@......."
 137 move_and_echo 3 8 ".@@@@@...@.......@...@@@@@.@@@@...."
 138 move_and_echo 4 8 ".@...@...@.......@...@...@.@......."
 139 move_and_echo 5 8 ".@...@...@.......@...@...@..@@@@..."
 140 move_and_echo 1 43 "@@@@...@@@...@@@@..@@@@..@@@@."
 141 move_and_echo 2 43 "@...@.@...@.@.....@.....@....."
 142 move_and_echo 3 43 "@@@@..@@@@@.@.....@@@@...@@@.."
 143 move_and_echo 4 43 "@..@..@...@.@.....@.........@."
 144 move_and_echo 5 43 "@...@.@...@..@@@@..@@@@.@@@@.."
 145 
 146 
 147 # 把前景和背景颜色设为绿色.
 148 echo -ne '\E[32;42m'
 149 
 150 # 画11行绿线.
 151 tput cup 5 0
 152 for n in `seq 11`; do
 153       echo $BLANK80
 154 done
 155 
 156 # 把前景色设为黑色. 
 157 echo -ne '\E[30m'
 158 tput cup 5 0
 159 
 160 # 画栅栏. 
 161 echo "++++++++++++++++++++++++++++++++++++++\
 162 ++++++++++++++++++++++++++++++++++++++++++"
 163 
 164 tput cup 15 0
 165 echo "++++++++++++++++++++++++++++++++++++++\
 166 ++++++++++++++++++++++++++++++++++++++++++"
 167 
 168 # 把前景和背景色设回白色.
 169 echo -ne '\E[37;47m'
 170 
 171 # 画3条白线.
 172 for n in `seq 3`; do
 173       echo $BLANK80
 174 done
 175 
 176 # 把前景色设为黑色.
 177 echo -ne '\E[30m'
 178 
 179 # 创建9个文件来保存障碍物.
 180 for n in `seq 10 7 68`; do
 181       touch $n
 182 done  
 183 
 184 # 设置脚本要画的马的类型为第一种类型.
 185 HORSE_TYPE=2
 186 
 187 #  为每匹马创建位置文件和机率文件.
 188 #+ 在这些文件里保存了该匹马当前的位置,
 189 #+ 类型和机率.
 190 for HN in `seq 9`; do
 191       touch horse_${HN}_position
 192       touch odds_${HN}
 193       echo \-1 > horse_${HN}_position
 194       echo $HORSE_TYPE >>  horse_${HN}_position
 195       # 给马定义随机的障碍物.
 196        HANDICAP=`random_1_9`
 197       # 检查random_1_9函数是否返回了有效值.
 198       while ! echo $HANDICAP | grep [1-9] &> /dev/null; do
 199                 HANDICAP=`random_1_9`
 200       done
 201       # 给马定义最后的障碍的位置. 
 202       LHP=`expr $HANDICAP \* 7 + 3`
 203       for FILE in `seq 10 7 $LHP`; do
 204             echo $HN >> $FILE
 205       done   
 206      
 207       # 计算机率.
 208       case $HANDICAP in 
 209               1) ODDS=`echo $HANDICAP \* 0.25 + 1.25 | bc`
 210                                  echo $ODDS > odds_${HN}
 211               ;;
 212               2 | 3) ODDS=`echo $HANDICAP \* 0.40 + 1.25 | bc`
 213                                        echo $ODDS > odds_${HN}
 214               ;;
 215               4 | 5 | 6) ODDS=`echo $HANDICAP \* 0.55 + 1.25 | bc`
 216                                              echo $ODDS > odds_${HN}
 217               ;; 
 218               7 | 8) ODDS=`echo $HANDICAP \* 0.75 + 1.25 | bc`
 219                                        echo $ODDS > odds_${HN}
 220               ;; 
 221               9) ODDS=`echo $HANDICAP \* 0.90 + 1.25 | bc`
 222                                   echo $ODDS > odds_${HN}
 223       esac
 224 
 225 
 226 done
 227 
 228 
 229 # 打印机率.
 230 print_odds() {
 231 tput cup 6 0
 232 echo -ne '\E[30;42m'
 233 for HN in `seq 9`; do
 234       echo "#$HN odds->" `cat odds_${HN}`
 235 done
 236 }
 237 
 238 # 在起跑线上画马.
 239 draw_horses() {
 240 tput cup 6 0
 241 echo -ne '\E[30;42m'
 242 for HN in `seq 9`; do
 243       echo /\\$HN/\\"                               "
 244 done
 245 }
 246 
 247 print_odds
 248 
 249 echo -ne '\E[47m'
 250 # 等待回车按键开始赛马.
 251 # 转义序列'\E[?25l'禁显了光标.
 252 tput cup 17 0
 253 echo -e '\E[?25l'Press [enter] key to start the race...
 254 read -s
 255 
 256 #  禁用了终端的常规显示功能.
 257 #  这避免了赛跑时不小心按了按键键入显示字符而弄乱了屏幕.
 258 #  
 259 stty -echo
 260 
 261 # --------------------------------------------------------
 262 # 开始赛跑.
 263 
 264 draw_horses
 265 echo -ne '\E[37;47m'
 266 move_and_echo 18 1 $BLANK80
 267 echo -ne '\E[30m'
 268 move_and_echo 18 1 Starting...
 269 sleep 1
 270 
 271 # 设置终点线的列数.
 272 WINNING_POS=74
 273 
 274 # 记录赛跑开始的时间.
 275 START_TIME=`date +%s`
 276 
 277 # COL 是由下面的"while"结构使用的.
 278 COL=0    
 279 
 280 while [ $COL -lt $WINNING_POS ]; do
 281                    
 282           MOVE_HORSE=0     
 283           
 284           # 检查random_1_9函数是否返回了有效值.
 285           while ! echo $MOVE_HORSE | grep [1-9] &> /dev/null; do
 286                 MOVE_HORSE=`random_1_9`
 287           done
 288           
 289           # 取得随机取得的马的类型和当前位置.
 290           HORSE_TYPE=`cat  horse_${MOVE_HORSE}_position | tail -1`
 291           COL=$(expr `cat  horse_${MOVE_HORSE}_position | head -1`) 
 292           
 293           ADD_POS=1
 294           # 检查当前的位置是否是障碍物的位置. 
 295           if seq 10 7 68 | grep -w $COL &> /dev/null; then
 296                 if grep -w $MOVE_HORSE $COL &> /dev/null; then
 297                       ADD_POS=0
 298                       grep -v -w  $MOVE_HORSE $COL > ${COL}_new
 299                       rm -f $COL
 300                       mv -f ${COL}_new $COL
 301                       else ADD_POS=1
 302                 fi 
 303           else ADD_POS=1
 304           fi
 305           COL=`expr $COL + $ADD_POS`
 306           echo $COL >  horse_${MOVE_HORSE}_position  # 保存新位置.
 307                             
 308          # 选择要画的马的类型.         
 309           case $HORSE_TYPE in 
 310                 1) HORSE_TYPE=2; DRAW_HORSE=draw_horse_two
 311                 ;;
 312                 2) HORSE_TYPE=1; DRAW_HORSE=draw_horse_one 
 313           esac       
 314           echo $HORSE_TYPE >>  horse_${MOVE_HORSE}_position # 保存当前类型.
 315          
 316           # 把前景色设为黑，背景色设为绿.
 317           echo -ne '\E[30;42m'
 318           
 319           # 把光标位置移到新的马的位置.
 320           tput cup `expr $MOVE_HORSE + 5`  `cat  horse_${MOVE_HORSE}_position | head -1` 
 321           
 322           # 画马.
 323           $DRAW_HORSE
 324            usleep $USLEEP_ARG
 325           
 326            # 当所有的马都越过15行的之后，再次打印机率.          
 327            touch fieldline15
 328            if [ $COL = 15 ]; then
 329              echo $MOVE_HORSE >> fieldline15  
 330            fi
 331            if [ `wc -l fieldline15 | cut -f1 -d " "` = 9 ]; then
 332                print_odds
 333                : > fieldline15
 334            fi           
 335           
 336           # 取得领头的马.
 337           HIGHEST_POS=`cat *position | sort -n | tail -1`          
 338           
 339           # 把背景色重设为白色.
 340           echo -ne '\E[47m'
 341           tput cup 17 0
 342           echo -n Current leader: `grep -w $HIGHEST_POS *position | cut -c7`"                              "           
 343 
 344 done  
 345 
 346 # 取得赛马结束的时间.
 347 FINISH_TIME=`date +%s`
 348 
 349 # 背景色设为绿色并且启用闪动的功能.
 350 echo -ne '\E[30;42m'
 351 echo -en '\E[5m'
 352 
 353 # 使获胜的马闪动.
 354 tput cup `expr $MOVE_HORSE + 5` `cat  horse_${MOVE_HORSE}_position | head -1`
 355 $DRAW_HORSE
 356 
 357 # 禁用闪动文本.
 358 echo -en '\E[25m'
 359 
 360 # 把前景和背景色设为白色.
 361 echo -ne '\E[37;47m'
 362 move_and_echo 18 1 $BLANK80
 363 
 364 # 前景色设为黑色.
 365 echo -ne '\E[30m'
 366 
 367 # 闪动获胜的马.
 368 tput cup 17 0
 369 echo -e "\E[5mWINNER: $MOVE_HORSE\E[25m""  Odds: `cat odds_${MOVE_HORSE}`"\
 370 "  Race time: `expr $FINISH_TIME - $START_TIME` secs"
 371 
 372 # 恢复光标和最初的颜色.
 373 echo -en "\E[?25h"
 374 echo -en "\E[0m"
 375 
 376 # 恢复回显功能.
 377 stty echo
 378 
 379 # 删除赛跑的临时文件.
 380 rm -rf $HORSE_RACE_TMP_DIR
 381 
 382 tput cup 19 0
 383 
 384 exit 0


例子 33-19. 在shell脚本中调用的窗口部件

   1 #!/bin/bash
   2 # dialog.sh: 使用 'gdialog' 窗口部件.
   3 # 必须在你的系统里安装'gdialog'才能运行此脚本.
   4 # 版本 1.1 (04/05/05 修正)
   5 
   6 # 这个脚本的灵感源自下面的文章.
   7 #     "Scripting for X Productivity," by Marco Fioretti,
   8 #      LINUX JOURNAL, Issue 113, September 2003, pp. 86-9.
   9 # Thank you, all you good people at LJ.
  10 
  11 
  12 # 在窗口中的输入错误.
  13 E_INPUT=65
  14 # 输入窗口显示的尺寸.
  15 HEIGHT=50
  16 WIDTH=60
  17 
  18 # 输出文件名 (由脚本名构建而来).
  19 OUTFILE=$0.output
  20 
  21 # 把这个脚本的内容显示在窗口中.
  22 gdialog --title "Displaying: $0" --textbox $0 $HEIGHT $WIDTH
  23 
  24 
  25 
  26 # 现在，保存输入到输出文件中.
  27 echo -n "VARIABLE=" > $OUTFILE
  28 gdialog --title "User Input" --inputbox "Enter variable, please:" \
  29 $HEIGHT $WIDTH 2>> $OUTFILE
  30 
  31 
  32 if [ "$?" -eq 0 ]
  33 # 检查退出状态是一个好习惯.
  34 then
  35   echo "Executed \"dialog box\" without errors."
  36 else
  37   echo "Error(s) in \"dialog box\" execution."
  38         # 或者, 点击"Cancel", 而不是"OK" 按钮.
  39   rm $OUTFILE
  40   exit $E_INPUT
  41 fi
  42 
  43 
  44 
  45 # 现在，我们重新取得并显示保存的变量.
  46 . $OUTFILE   # 'Source' 保存的文件（即执行）.
  47 echo "The variable input in the \"input box\" was: "$VARIABLE""
  48 
  49 
  50 rm $OUTFILE  # 清除临时文件.
  51              # 有些应用可能需要保留这些文件.
  52 
  53 exit $?
  
  
 
 
 
 
 
 Shell部分转义字符：
\a		生成声音提示
\b		退格符
\e		ESC字符
\f		换页符
\n
\r		回车符
\t
\v		竖向制表符
\\
\'
\nnn	采用1,2或3位八进制数值表示等价ASCII字符
\xHH	—————十六进制
单引号中的所有元字符均作为普通字符常量处理。
/bin		包含系统，管理员和普通用户可以共享的各种通用程序，如cat,cp,mv,rm,ls,ps等常用的基本命令，bash等
/boot	包含系统引导程序，linux内核程序文件vmlinuz，磁盘内存映像文件initrd及grub引导程序和配置文件
		grub其中还有GRUB配置文件，以及3种不同类型的初始引导程序等
/dev		在linux系统中，任何设备均对应一个或多个特殊文件（设备文件），这个目录包含了系统支持的所有设备文件。console表示系统控制台，lp0表示打印机，ttyXX表示系统的串口设备，cdrom，dsp文件表示系统的音响设备，写到这个文件的任何数据，将会被重定向到音响设备。mem表示物理内存，kmem表示系统内核战胜的虚拟内存，sda表示连接到主控制器的第一个磁盘，sda1/sda2则分别表示第一个和第二个磁盘分区。
/etc		整个linux系统的中心，包含所有系统管理和维护方面的配置文件。还有其他大量的配置文件分别位于单独子目录中，通常应注意备件这个目录中的重要配置文件，以便需要时能够快速地恢复系统。
/home	用户主目录的根目录。
/lib		包含系统引导过程及运行系统命令所需要的内核模块和各种动态链接共享库文件（.so）内核模块（驱动程序）位于/lib/modules/kernel-version子目录中。
/lost+found	每个文件系统分区都存在一个此目录，用于存储fsck命令在检测与修复文件系统时删除的文件或目录。Linux系统要求正常的关机。异常停机，会导致文件系统损坏，重新启动，会使用fsck命令对文件系统进行检测与修复。检测文件系统期间，fsck会尝试修复任何受损的文件，部分被恢复的文件或无法恢复的数据块将会被放置在每个文件系统的lost+found目录中。如果这个目录中还有受损的数据文件，可以使用debugfs等工具，尝试自行恢复丢失的数据，如果是系统文件，也许需要重新安装相应的软件包。
/media	移动不住介质的安装点。
/mnt		文件系统的临时安装点。这是一个通用的安装点，可以临时安装任何文件系统或远程资源。如果愿意，也可以在此目录中创建若干 子目录，以便安装不同的设备，例如，使用/mnt/cdrom,/mnt/usd分别安装CD和U盘等。
/opt			应用程序等附加软件的安装目录。
/proc		进程文件系统proc的根目录。其中部分文件分别对应当前正在运行的进程，可用于访问当前进程的地址空间。这是一个非常特殊的虚拟文件系统，其中并不包含“实际的”文件，而是可用以引用 当前运行系统的系统信息。如CPU，内存，运行时间，软件配置，及硬件配置等信息。以数字命名的目录对应于一个实际的进程，而这个数字，则表示进程的ID。这些大小为0的文件，相当于一个指向内核数据空间的指针，可据以查询相应的进程信息。由于这个原因，可以把/proc文件系统看作系统内核的一个控制和信息中心。事实上，许多系统命令只是直接显示这个文件系统中的部分文件内容。
	net其中的文件分别表示各种网络协议的状态与统计信息
	sys有各种系统信息，也包含系统内核与TCP/IP网络等的可调参数。
/root		超级用户的家目录
/sbin		包含与系统引导，管理和维护及硬件配置等方面有关的命令或脚本文件，fdisk,init,ifconfig等。供root用。
/srv			用于存储本地系统提供的服务进程所用的数据文件（现为空目录）
/sys			系统各种设备配置信息的根目录，block子目录中含有磁盘及磁盘分区的配置信息，bus目录包含pci，usb等的配置信息和驱动程序。
/tmp		临时文件目录，存储系统运行过程中生成的临时文件，也可以供用户存储自己的临时文件。其中的许多文件对于当前正在运行的进程而言是非常重要的，删除这样的文件可能会导致系统瘫痪。因此，一般不要自己删除这个目录中的文件，除非确实有把握。在大多数系统，尤其是在UNIX系统中，伴随着系统的启动过程，清除此目录。
/usr			即可以作为一个单独的文件系统，也可以作为根目录下的一个子目录，其中存有系统提供的各种共享数据，如用户命令，库函数，头文件和文档等。
	bin用户经常使用 的各种命令
	games游戏和教育程序
	includeC语言的头文件
	lib各种共享的库函数
	sbin管理员的东东
	share共享目录，包含man,info,doc,locale,vim,zoneinfo等子目录。
	src存放Linux系统内核的源代码和文档等
/var		即可作为一个单独的文件系统，也可作为根目录下的一个子目录，用于不住各种可变长的数据文件，临时文件
	cacheAPT和samba等程序使用的工作目录，缓存程序使用的各种数据文件
	lib存储软件包特定的动态链接共享库，配置文件，数据文件和状态信息
	mail每个用户电子邮件的邮箱文件
文件：从理论上讲，文件是由一系列连续的字节流组成的，最后 以一个EOF字符结束。但从物理实现来讲，文件实际上是由存储介质上的一系列数据块组成的，而组成文件的数据块，并不一定是连接的。
原则上，文件名可由任何字符组成，但若包含一些打印字符，空白，及SHELL元字符，实际用着会特别麻烦。。。
单从文件名来看，Linux系统中大部分文件都无从知道其类型，没有对文件的命名强加任何约定，但习惯上，以.c作为C源程序文件名的后缀，.sh作为脚本文件名的后缀。按照惯例，可执行程序的文件名不加后缀。
od -c 文件名可用来显示二进制数据文件。
为了保证目录的完整性，操作系统不允许用户直接修改目录文件。用户在目录中创建文件，由操作系统把文件加到目录中。删除文件时，由操作系统从目录文件中删除相应的文件名。目录文件始终是由操作系统负责维护的。
特殊文件（设备文件）不包含任何数据，只是提供一种机制，在文件系统中建立一个物理设备与文件名之间的映射。当提交一个读写特殊文件的请求时，系统将会直接调用相应的设备驱动程序。而驱动程序则负责在控制进程与相关的物理设备之间传输数据。（块设备和字符设备）
4个特殊文件
/dev/null是一个无底油，写入这个文件，数据就会消失。。。读取等同读取/dev/zero文件
/dev/zero可以提供任意数量的数值0,当程序从这个文件中读取256个字节时，将会收到256个0.写入等同楼上。。。
/dev/mem提供计算机的物理内存接口。读取他的字节地址被解释为物理内存地址。
/dev/keme提供系统内核的虚拟内存接口。从头开始读这个，会读取系统内核从第一个字节开始的数据。
Linux系统也采用了实际用户ID和有效用户ID。通过设置有效用户ID，用户能够临时地以超级用户身份执行某些特权命令。如passwd修改密码期间，有有效ID暂时变为超级用户ID，因而可以访问shadow等文件，修改密码。退出passwd命令，用户的有效ID又恢复原状。访问权限字段中的第一个S表示已经设置了有效用户ID.u+s,g+s这样的x->s...root要先执行下，才能使上述设置发挥作用。用户执行相应命令时，其有效用户ID才能变为超级用户ID，仅执行过程。
创建命令：touch 文件名 ，> 文件名，echo "str">文件名，cat > 文件名 “moreSTR”CTRL+D，VIM等工具。
许多vim命令前面都可以加一个计数值 ，表明相应命令需要重复执行的次数。3dd表示删除文本行的动作需要执行3次，最终结果是删除3行数据。同样可以用以移动光标2Ctrl+F表示前滚两次。
.命令可以重复执行先前的文本编辑命令。如dd后，用.，就又执行了一次dd。
vim可以编辑多文件vim file1 file2，用:e filename或者:n filename转到指定文件，:n命令转到下一个文件。
set all将会输出VIM编辑器当前支持的所有选项及默认设置。
改变某个选项:set option，取消某选项设置，:set nooption，部分选项如下。
嗯。。。需要再看吧。。。
永久性的设定vim环境/etc/vim/vimrc文件或者userhome/.vimrc or .exrc文件中。
示例
set showmode
ab abc 中国农业银行
ab boc 中国银行
...
实际上，还可以在每个目录中创建一个自己的.vimrc文件，适应不同需要。仅当主目录的.exrc文件包含set exrc，其他目录中的.vimrc文件才能发挥作用。
Linux系统提供了丰富的系统命令和各种各样的实用程序，只要经过适当的组合，基本上都可以满足绝大部分应用需求，而不必重新编写新的程序。这是Shell脚本最大的功用所在。chmod a+rx *.sh
Shell编程吸取了UNIX/Linux系统把复杂任务分解成简单子任务的优良传统，可以把各种系统工具和实用程序灵活地组合在一起，完成特定的功能需求。这理一种非常好的解决问题的手段，避免了针对各种各样的用户需求，都 要重新开发一套复杂工具的烦恼。事实上，Linux系统已经提供了丰富的，功能强大的系统工具和实用程序，只要灵活地运用这些现成的工具，就可以满足我们的绝大部分需求。
运行方式：一，sh *.sh             二，加上RX权限，运行，这个好，推荐。可以读取标准输入这个。
exit[n]终止脚本同时向调用者返回一个数值为n的出口状态。n，0—255的。正常终止应返回0.错误返回1-255
启用root：为root用户设置密码。sudo passwd root即可。/etc/gdm/gdm.conf把AllowRoot=true即可。
再次封锁超级用户，使用sudo passwd -l root即可启用。

