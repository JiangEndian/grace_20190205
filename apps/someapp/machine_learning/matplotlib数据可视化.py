#!/usr/bin/env python3

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
from matplotlib import animation





#Animation 动画############################################################
fig, ax = plt.subplots()

x = np.arange(0, 2*np.pi, 0.01) #0-2π内的正弦曲线（0.1为间隔，其实只有一维现在）
#print(x)
#[ 0.    0.01  0.02  0.03  0.04  0.05  0.06  0.07  0.08  0.09  0.1   0.11
#.....
  #6.24  6.25  6.26  6.27  6.28]
line, = ax.plot(x, np.sin(x)) #一个sin图像，现在是有X轴数据和其对应的Y轴数据了，一根这样的正弦线

#自定义动画函数animate，用来更新每一帧上各个x对应的y坐标值，参数表示第i帧，Y变成新的sin(x+i/100)都
def animate(i): #不理解不理解。。。还好，听说矩阵相乘大家都不理解，就用。。。
    line.set_ydata(np.sin(x+i/50)) #这个变化范围大点就变化快了
    return line, 

def init():
    line.set_ydata(np.sin(x))
    return line, 
    
#frames：一次循环包含的帧数， interval更新频率，以ms计，越大越卡
ani = animation.FuncAnimation(fig=fig, func=animate, frames=1000, init_func=init, interval=20, blit=False)

plt.show()



#Subplot 多合一显示，不用，直接一个一个来，或者用时再看就行，就是多图一块显示
#Subplot 分格显示，就是把窗口随意切分显示多图
#图中图，整个Figure 1包含了三个图，其中两个小图title inside 1和title inside 2又出现在大图title中
#次坐标轴 即在同个图上有第2个y轴存在
#20200616, 19:15, 3D数据#################################################
exit(0)

fig = plt.figure() #图片的窗口容器
ax = Axes3D(fig) #加上3D的Axes:轴线 

X = np.arange(-4, 4, 0.25)
Y = np.arange(-4, 4, 0.25)
#print(X, Y) #-4到4,以0.25为间隔
#[-4.   -3.75 -3.5  -3.25 -3.   -2.75 -2.5  -2.25 -2.   -1.75 -1.5  -1.25
 #-1.   -0.75 -0.5  -0.25  0.    0.25  0.5   0.75  1.    1.25  1.5   1.75
  #2.    2.25  2.5   2.75  3.    3.25  3.5   3.75] 
  #[-4.   -3.75 -3.5  -3.25 -3.   -2.75 -2.5  -2.25 -2.   -1.75 -1.5  -1.25
 #-1.   -0.75 -0.5  -0.25  0.    0.25  0.5   0.75  1.    1.25  1.5   1.75
  #2.    2.25  2.5   2.75  3.    3.25  3.5   3.75]

X, Y = np.meshgrid(X, Y) #x-y平面的网格，本来是一个X,Y面的，现在成了X不变，Y直接从-4至3.75平移生成了这么些个
#print(X, Y) #-4到4,以0.25为间隔，然后有点奇怪的处理，看不懂的
#[[-4.   -3.75 -3.5  ...,  3.25  3.5   3.75]
 #[-4.   -3.75 -3.5  ...,  3.25  3.5   3.75]
 #[-4.   -3.75 -3.5  ...,  3.25  3.5   3.75]
 #..., 
 #[-4.   -3.75 -3.5  ...,  3.25  3.5   3.75]
 #[-4.   -3.75 -3.5  ...,  3.25  3.5   3.75]
 #[-4.   -3.75 -3.5  ...,  3.25  3.5   3.75]] 
 #[[-4.   -4.   -4.   ..., -4.   -4.   -4.  ]
 #[-3.75 -3.75 -3.75 ..., -3.75 -3.75 -3.75]
 #[-3.5  -3.5  -3.5  ..., -3.5  -3.5  -3.5 ]
 #..., 
 #[ 3.25  3.25  3.25 ...,  3.25  3.25  3.25]
 #[ 3.5   3.5   3.5  ...,  3.5   3.5   3.5 ]
 #[ 3.75  3.75  3.75 ...,  3.75  3.75  3.75]]

R = np.sqrt(X**2 + Y**2)
#print(R) #平面的X轴和Y轴数据统统平方下再加一块开方，是我不懂的方程式
#[[ 5.65685425  5.48292805  5.31507291 ...,  5.15388203  5.31507291
   #5.48292805]
 #[ 5.48292805  5.30330086  5.12957113 ...,  4.96235831  5.12957113
   #5.30330086]
 #[ 5.31507291  5.12957113  4.94974747 ...,  4.77624329  4.94974747
   #5.12957113]
 #...,
 #[ 5.15388203  4.96235831  4.77624329 ...,  4.59619408  4.77624329
   #4.96235831]
 #[ 5.31507291  5.12957113  4.94974747 ...,  4.77624329  4.94974747
   #5.12957113]
 #[ 5.48292805  5.30330086  5.12957113 ...,  4.96235831  5.12957113
   #5.30330086]]
Z = np.sin(R) #Z轴数据 通过这样的sin函数。是我不懂的数学公式。这个3D面的方程
#print(Z)
#[[-0.58617619 -0.7175353  -0.82381719 ..., -0.90411471 -0.82381719
  #-0.7175353 ]
 #[-0.7175353  -0.830433   -0.91423432 ..., -0.96892001 -0.91423432
  #-0.830433  ]
 #[-0.82381719 -0.91423432 -0.97196248 ..., -0.99796201 -0.97196248
  #-0.91423432]
 #..., 
 #[-0.90411471 -0.96892001 -0.99796201 ..., -0.99325696 -0.99796201
  #-0.96892001]
 #[-0.82381719 -0.91423432 -0.97196248 ..., -0.99796201 -0.97196248
  #-0.91423432]
 #[-0.7175353  -0.830433   -0.91423432 ..., -0.96892001 -0.91423432
  #-0.830433  ]]

#rstride 和cstride 代表row 和 column 的步子，越小越密集平滑
ax.plot_surface(X, Y, Z, rstride=1, cstride=1, cmap=plt.get_cmap('rainbow')) #plot 3D的方式

#从Z轴投影，即对XY平面投影
ax.contourf(X, Y, Z, zdir='z', offset=-2, cmap='rainbow') #加上等高线图， 从Z轴压下去
ax.set_zlim(-2, 2) #限制Z轴

plt.show()


#20200616, 19:07, image图片################################################
exit(0)

a = np.array([0.313660827978, 0.365348418405, 0.423733120134,
              0.365348418405, 0.439599930621, 0.525083754405,
              0.423733120134, 0.525083754405, 0.651536351379]).reshape(3,3)

#nearest清晰，None, none等
plt.imshow(a, interpolation='nearest', cmap='bone', origin='lower')
plt.colorbar() #也有参数，比如压缩之类

plt.xticks(())
plt.yticks(())
plt.show()

#20200615, 18:51, contours 等高线图########################################
exit(0)

def f(x, y):
    #the height function
    return (1 - x/2 + x**5 + y**3) * np.exp(-x**2 - y**2)

n = 256
x = np.linspace(-3, 3, n) #在区间 [-3,3] 中均匀分布的256个值
y = np.linspace(-3, 3, n)
X,Y = np.meshgrid(x, y) #在二维平面中将每一个x和每一个y分别对应起来，编织成栅格
#print(X, Y)

# use plt.contourf to filling contours #填充颜色，热色map
# X, Y and value for (X,Y) point
plt.contourf(X, Y, f(X, Y), 8, alpha=.75, cmap=plt.cm.hot)

#开始画等高线图
# use plt.contour to add contour lines #8代表线的密集程度，0就分两半了，8分10块,100超级密集
C = plt.contour(X, Y, f(X, Y), 8, colors='black', linewidth=.5)

plt.clabel(C, inline=True, fontsize=10) #添加高度数字， label在线里·真
plt.xticks(())
plt.yticks(())

plt.show()


#20200615, 18:39, bar柱状图-基本图形-加颜色和数据 ##########################
exit(0)

n = 12
X = np.arange(n) #0到11的整数
Y1 = (1 - X / float(n)) * np.random.uniform(0.5, 1.0, n) #均匀分布的随机数据
Y2 = (1 - X / float(n)) * np.random.uniform(0.5, 1.0, n)

plt.bar(X, +Y1, facecolor='#9999ff', edgecolor='white') #主颜色和边框颜色
plt.bar(X, -Y2, facecolor='#ff9999', edgecolor='white')

for x, y in zip(X, Y1): #上方和下方加上数值，保留两位小数，横向居中对齐，纵向底部/顶部对齐
    #ha: horizontal alignment正确排放 排成直线
    plt.text(x + 0.04, y + 0.05, '%.2f' % y, ha='center', va='bottom')
for x, y in zip(X, Y2):
    plt.text(x + 0.04, -y - 0.05, '-%.2f' % y, ha='center', va='top')

plt.xlim(-0.5, n) #限制数据范围
plt.xticks(()) #取消边框小标注
plt.ylim(-1.25, 1.25)
plt.yticks(())

plt.show()

#20200615, 18:31, Scatter散点图#############################################
exit(0)

n = 1024
X = np.random.normal(0, 1, n) #标准正态分布，平均数0, 方差1, n个
Y = np.random.normal(0, 1, n)
T = np.arctan2(Y, X) #for color value #为了好看

plt.scatter(X, Y, s=75, c=T, alpha=0.5) #X和Y为location, size为75大小， 颜色为T, 半透明
#plt.scatter(np.arange(5), np.arange(5))
plt.xlim((-1.5, 1.5))
plt.ylim((-1.5, 1.5)) #显示区域
plt.xticks(()) #隐藏ticks小标注
plt.yticks(())
plt.show()


#20200615, 18:26, Annotation 标注，基本图-移动坐标-添加注释#################
#annotation  （文本或图表的）注解，注释，跳过～～～知道这个不会


#20200615, 11:36, legend图例-添加图例，调整位置和名称########################
exit(0)

x = np.linspace(-3, 3, 50)
y1 = 2*x + 1
y2 = x**2

plt.figure()

plt.xlim((-1, 2))
plt.ylim((-2, 3))

plt.xlabel('I am x')
plt.ylabel('I am y')

new_ticks = np.linspace(-1, 2, 5)
plt.xticks(new_ticks)
plt.yticks([-2, -1.8, -1, 1.22, 3, ], 
        [r'$really\ bad$', r'$bad$', r'$normal$', 'good α', 'really good']) 

l1,  = plt.plot(x, y2, label='up') #图例会用到这label作为此线的名称
l2,  = plt.plot(x, y1, color='red', linewidth=1.0, linestyle='--', label='down') #加个线的变量名列表
#plt.legend() #handles, labels, loc, 
#plt.show() #生成了一个默认的小legend图例在左上方

plt.legend(handles=[l1,l2,], labels=['aaa', 'bbb'], loc='best')
plt.show() #线的名字被重设为aaa,bbb，位置倒是没动。可能默认就是best。。。默认就好～～～

#20200615, 11:27, 设置坐标轴2-设置不同名字和位置/调整坐标轴###################
exit(0)

x = np.linspace(-3, 3, 50)
y1 = 2*x + 1
y2 = x**2

plt.figure()
plt.plot(x, y2)
plt.plot(x, y1, color='red', linewidth=1.0, linestyle='--')

plt.xlim((-1, 2))
plt.ylim((-2, 3))

plt.xlabel('I am x')
plt.ylabel('I am y')

new_ticks = np.linspace(-1, 2, 5)
plt.xticks(new_ticks)
plt.yticks([-2, -1.8, -1, 1.22, 3, ], 
        [r'$really\ bad$', r'$bad$', r'$normal$', 'good α', 'really good']) 

ax = plt.gca() #把上面的图设置为ax
ax.spines['right'].set_color('none') #图的脊柱 
ax.spines['top'].set_color('none')
#plt.show() #顶线的和右边线消失了

ax.xaxis.set_ticks_position('bottom') #用底线代替X
ax.yaxis.set_ticks_position('left') #用左边线代替Y
ax.spines['bottom'].set_position(('data', -1)) #X轴bottom位置变成-1(在Y轴上）
ax.spines['left'].set_position(('data', 0)) #把Y轴left位置设置为0（在X轴上这是当然的）
plt.show() #图不变，坐标轴移动，或者，指定的spine移动


#20200615, 11:14, 设置坐标轴1-调整坐标轴名字和间隔#################
exit(0)

x = np.linspace(-3, 3, 50)
y1 = 2*x + 1
y2 = x**2

plt.figure()
plt.plot(x, y2)
plt.plot(x, y1, color='red', linewidth=1.0, linestyle='--')
#plt.show() #U,加虚斜线#

plt.xlim((-1, 2))
plt.ylim((-2, 3))
#plt.show() #取值范围为x:{-1, 2}, y:{-2, 3}，就相当于从原图中截取这块

plt.xlabel('I am x')
plt.ylabel('I am y')
#plt.show() #X和Y轴名字

new_ticks = np.linspace(-1, 2, 5)
#print(new_ticks)
#[-1.   -0.25  0.5   1.25  2.  ]

plt.xticks(new_ticks)
#plt.show() #换了X轴的小标，小记号

plt.yticks([-2, -1.8, -1, 1.22, 3, ], 
        [r'$really\ bad$', r'$bad$', r'$normal$', 'good α', 'really good']) #换字体
        #换字体，也可以转义特殊符号。。。直接打就行呗。。。嗯。看来，神真的给我更多的恩典。。。
plt.show() #Y轴的小标就变成了文字




#20200614, 21:40, figure图像（数字/身影/图案）####################
exit(0)

x = np.linspace(-3, 3, 50)
#print(x)
#[-3.         -2.87755102 -2.75510204 -2.63265306 -2.51020408 -2.3877551
 #-2.26530612 -2.14285714 -2.02040816 -1.89795918 -1.7755102  -1.65306122
 #-1.53061224 -1.40816327 -1.28571429 -1.16326531 -1.04081633 -0.91836735
 #-0.79591837 -0.67346939 -0.55102041 -0.42857143 -0.30612245 -0.18367347
 #-0.06122449  0.06122449  0.18367347  0.30612245  0.42857143  0.55102041
  #0.67346939  0.79591837  0.91836735  1.04081633  1.16326531  1.28571429
  #1.40816327  1.53061224  1.65306122  1.7755102   1.89795918  2.02040816
  #2.14285714  2.26530612  2.3877551   2.51020408  2.63265306  2.75510204
  #2.87755102  3.        ]

y1 = 2*x + 1
y2 = x**2

plt.figure() #第一个figure
plt.plot(x, y1)

plt.figure(num=3, figsize=(8,5)) #新开一个figure,默认为figure1, 2, 3，可以指定
plt.plot(x, y2)
plt.plot(x, y1, color='red', linewidth=10, linestyle='--') #两条线了，多条红的虚线

plt.show() #这样就可以一个程序开多张图了





#20200614, 21:17, plot基础应用
exit(0)

x = np.linspace(-1, 1, 50)
#print(x)
#[-1.         -0.95918367 -0.91836735 -0.87755102 -0.83673469 -0.79591837
 #-0.75510204 -0.71428571 -0.67346939 -0.63265306 -0.59183673 -0.55102041
 #-0.51020408 -0.46938776 -0.42857143 -0.3877551  -0.34693878 -0.30612245
 #-0.26530612 -0.2244898  -0.18367347 -0.14285714 -0.10204082 -0.06122449
 #-0.02040816  0.02040816  0.06122449  0.10204082  0.14285714  0.18367347
  #0.2244898   0.26530612  0.30612245  0.34693878  0.3877551   0.42857143
  #0.46938776  0.51020408  0.55102041  0.59183673  0.63265306  0.67346939
  #0.71428571  0.75510204  0.79591837  0.83673469  0.87755102  0.91836735
  #0.95918367  1.        ]

y = 2 * x + 1
#print(y)
#[-1.         -0.91836735 -0.83673469 -0.75510204 -0.67346939 -0.59183673
 #-0.51020408 -0.42857143 -0.34693878 -0.26530612 -0.18367347 -0.10204082
 #-0.02040816  0.06122449  0.14285714  0.2244898   0.30612245  0.3877551
  #0.46938776  0.55102041  0.63265306  0.71428571  0.79591837  0.87755102
  #0.95918367  1.04081633  1.12244898  1.20408163  1.28571429  1.36734694
  #1.44897959  1.53061224  1.6122449   1.69387755  1.7755102   1.85714286
  #1.93877551  2.02040816  2.10204082  2.18367347  2.26530612  2.34693878
  #2.42857143  2.51020408  2.59183673  2.67346939  2.75510204  2.83673469
  #2.91836735  3.        ]

#plt.plot(x, y) #把这x和y两组数据加入，成为横纵座标的描述
#plt.show() #一个-1,-1 到 1,3的线段

y = x**2
#print(y)
#[  1.00000000e+00   9.20033319e-01   8.43398584e-01   7.70095793e-01
   #7.00124948e-01   6.33486047e-01   5.70179092e-01   5.10204082e-01
   #4.53561016e-01   4.00249896e-01   3.50270721e-01   3.03623490e-01
   #2.60308205e-01   2.20324865e-01   1.83673469e-01   1.50354019e-01
   #1.20366514e-01   9.37109538e-02   7.03873386e-02   5.03956685e-02
   #3.37359434e-02   2.04081633e-02   1.04123282e-02   3.74843815e-03
   #4.16493128e-04   4.16493128e-04   3.74843815e-03   1.04123282e-02
   #2.04081633e-02   3.37359434e-02   5.03956685e-02   7.03873386e-02
   #9.37109538e-02   1.20366514e-01   1.50354019e-01   1.83673469e-01
   #2.20324865e-01   2.60308205e-01   3.03623490e-01   3.50270721e-01
   #4.00249896e-01   4.53561016e-01   5.10204082e-01   5.70179092e-01
   #6.33486047e-01   7.00124948e-01   7.70095793e-01   8.43398584e-01
   #9.20033319e-01   1.00000000e+00]

plt.plot(x, y) #这样的x和y座标描述，是一个y=x**2的图吧。嗯，有负有正，是个U型图
plt.show() #U型图



